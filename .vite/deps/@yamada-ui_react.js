import {
  require_react_dom
} from "./chunk-YUNTBJI6.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-45FXRYJS.js";

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
var init_emotion_memoize_esm = __esm({
  "node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment29 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement3(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment29;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement3;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length2, i, keys2;
        if (Array.isArray(a)) {
          length2 = a.length;
          if (length2 != b.length) return false;
          for (i = length2; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        var it;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b.get(i.value[0]))) return false;
          return true;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length2 = a.length;
          if (length2 != b.length) return false;
          for (i = length2; i-- !== 0; )
            if (a[i] !== b[i]) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length2 = keys2.length;
        if (length2 !== Object.keys(b).length) return false;
        for (i = length2; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
        if (hasElementType && a instanceof Element) return false;
        for (i = length2; i-- !== 0; ) {
          if ((keys2[i] === "_owner" || keys2[i] === "__v" || keys2[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys2[i]], b[keys2[i]])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    module.exports = function isEqual2(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React29 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React29.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign2 = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props2, {
                  value: prevLog
                }),
                info: assign2({}, props2, {
                  value: prevInfo
                }),
                warn: assign2({}, props2, {
                  value: prevWarn
                }),
                error: assign2({}, props2, {
                  value: prevError
                }),
                group: assign2({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame3 = componentFrameCache.get(fn2);
            if (frame3 !== void 0) {
              return frame3;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component3) {
          var prototype = Component3.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config2, self) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props2, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props2, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props2, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props2, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props2) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props: props2,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config2, maybeKey, source, self) {
          {
            var propName;
            var props2 = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key = "" + config2.key;
            }
            if (hasValidRef(config2)) {
              ref = config2.ref;
              warnIfStringRefCannotBeAutoConverted(config2, self);
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props2[propName] = config2[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props2[propName] === void 0) {
                  props2[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props2, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props2, displayName);
              }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props2);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement7(object2) {
          {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node3, parentType) {
          {
            if (typeof node3 !== "object") {
              return;
            }
            if (isArray2(node3)) {
              for (var i = 0; i < node3.length; i++) {
                var child = node3[i];
                if (isValidElement7(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement7(node3)) {
              if (node3._store) {
                node3._store.validated = true;
              }
            } else if (node3) {
              var iteratorFn = getIteratorFn(node3);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node3.entries) {
                  var iterator = iteratorFn.call(node3);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement7(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes2;
            if (typeof type === "function") {
              propTypes2 = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes2 = type.propTypes;
            } else {
              return;
            }
            if (propTypes2) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes2, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type, props2, key, isStaticChildren, source, self) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray2(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props2, key, source, self);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props2.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray2(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            {
              if (hasOwnProperty2.call(props2, "key")) {
                var componentName = getComponentNameFromType(type);
                var keys2 = Object.keys(props2).filter(function(k) {
                  return k !== "key";
                });
                var beforeExample = keys2.length > 0 ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
                if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                  var afterExample = keys2.length > 0 ? "{" + keys2.join(": ..., ") + ": ...}" : "{}";
                  error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                  didWarnAboutKeySpread[componentName + beforeExample] = true;
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props2, key) {
          {
            return jsxWithValidation(type, props2, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props2, key) {
          {
            return jsxWithValidation(type, props2, key, false);
          }
        }
        var jsx158 = jsxWithValidationDynamic;
        var jsxs78 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx158;
        exports.jsxs = jsxs78;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var emotion_is_prop_valid_esm_exports = {};
__export(emotion_is_prop_valid_esm_exports, {
  default: () => isPropValid
});
var reactPropsRegex, isPropValid;
var init_emotion_is_prop_valid_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
    init_emotion_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    isPropValid = memoize(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement7, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate2) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props2, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props2[propName] == null) {
            if (isRequired) {
              if (props2[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate2(props2, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate2(props2, propName, componentName, location, propFullName, secret) {
          var propValue = props2[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate2(props2, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props2[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeChecker() {
        function validate2(props2, propName, componentName, location, propFullName) {
          var propValue = props2[propName];
          if (!isValidElement7(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeTypeChecker() {
        function validate2(props2, propName, componentName, location, propFullName) {
          var propValue = props2[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate2(props2, propName, componentName, location, propFullName) {
          if (!(props2[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props2[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate2(props2, propName, componentName, location, propFullName) {
          var propValue = props2[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is2(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate2(props2, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props2[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate2(props2, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props2, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createNodeChecker() {
        function validate2(props2, propName, componentName, location, propFullName) {
          if (!isNode2(props2[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate2(props2, propName, componentName, location, propFullName) {
          var propValue = props2[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate2(props2, propName, componentName, location, propFullName) {
          var propValue = props2[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props2[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props2[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement7(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e) {
          e.stopPropagation();
          if (options.format) {
            e.preventDefault();
            if (typeof e.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e.clipboardData.clearData();
              e.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e.preventDefault();
            options.onCopy(e.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/@yamada-ui/utils/dist/chunk-5OUUTZYQ.mjs
var interopDefault = (module) => module.default || module;

// node_modules/@yamada-ui/utils/dist/chunk-KT4SLZO6.mjs
var toNumber = (n) => {
  const num = parseFloat(n);
  return typeof num !== "number" || Number.isNaN(num) ? 0 : num;
};
var toPrecision = (n, precision) => {
  n = toNumber(n);
  const scale2 = 10 ** (precision != null ? precision : 10);
  n = Math.round(n * scale2) / scale2;
  return precision ? n.toFixed(precision) : n.toString();
};
var countDecimal = (n) => {
  if (!Number.isFinite(n)) return 0;
  let e = 1;
  let p = 0;
  while (Math.round(n * e) / e !== n) {
    e *= 10;
    p += 1;
  }
  return p;
};
var roundNumberToStep = (n, from2, step) => {
  const nextValue = Math.round((n - from2) / step) * step + from2;
  const precision = countDecimal(step);
  return toPrecision(nextValue, precision);
};
var valueToPercent = (n, min2, max2) => (n - min2) * 100 / (max2 - min2);
var percentToValue = (n, min2, max2) => (max2 - min2) * n + min2;
var clampNumber = (n, min2, max2) => Math.min(Math.max(n, min2), max2);

// node_modules/@yamada-ui/utils/dist/chunk-NBL5H4TH.mjs
var is = (x, y) => x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
var isNumber = (value) => typeof value === "number";
var isNotNumber = (value) => typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value);
var isNumeric = (value) => !isNaN(parseFloat(String(value))) && isFinite(Number(value)) && /^-?\d*\.?\d+$/.test(String(value));
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";
var isBoolean = (value) => typeof value === "boolean";
var isUndefined = (value) => typeof value === "undefined" && value === void 0;
var isNull = (value) => value === null;
var isObject = (value) => value !== null && (typeof value === "object" || typeof value === "function") && !isArray(value);
var isArray = (value) => Array.isArray(value);
var isEmpty = (value) => !isArray(value) || !value.length || value.every((v) => v == null);
var isFunction = (value) => typeof value === "function";
var isUnit = (value) => /[0-9].*(em|rem|ex|rex|cap|rcap|ch|rch|ic|ric|lh|rlh|vw|svw|lvw|dvw|vh|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax|cm|mm|Q|in|pc|pt|px|%|cqw|cqh|cqi|cqb|cqmin|cqmax)$/.test(
  value
);
var cast = (value) => value;

// node_modules/@yamada-ui/utils/dist/chunk-ZFE4ZWCP.mjs
var React = __toESM(require_react(), 1);
var createContext2 = ({
  strict = true,
  errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
  name,
  defaultValue
} = {}) => {
  const Context = React.createContext(defaultValue);
  Context.displayName = name;
  const useContext27 = () => {
    var _a;
    const context = React.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext27);
      throw error;
    }
    return context;
  };
  return [
    Context.Provider,
    useContext27,
    Context
  ];
};
var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : React.useEffect;
var useUnmountEffect = (callback) => (
  // eslint-disable-next-line react-hooks/exhaustive-deps
  React.useEffect(() => () => callback(), [])
);
var useIsMounted = ({
  rerender = false,
  delay: delay2 = 0
} = {}) => {
  const isMountedRef = React.useRef(false);
  const [isMounted, setIsMounted] = React.useState(false);
  useSafeLayoutEffect(() => {
    isMountedRef.current = true;
    let timeoutId = null;
    if (rerender) {
      if (delay2 > 0) {
        timeoutId = setTimeout(() => setIsMounted(true), delay2);
      } else {
        setIsMounted(true);
      }
    }
    return () => {
      isMountedRef.current = false;
      if (rerender) setIsMounted(false);
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [delay2, rerender]);
  return [React.useCallback(() => isMountedRef.current, []), isMounted];
};
var getValidChildren = (children) => React.Children.toArray(children).filter(
  (child) => React.isValidElement(child)
);
var isValidElement2 = (child) => React.isValidElement(child) || isString(child) || isNumber(child);
var findChildren = (children, ...types) => children.find((child) => types.some((type) => child.type === type)) ? children.sort(
  (a, b) => types.some((type) => a.type === type) ? -1 : types.some((type) => b.type === type) ? 1 : 0
) : [void 0, ...children];
var includesChildren = (children, ...types) => children.some((child) => {
  if (types.some((type) => child.type === type)) return true;
  const children2 = getValidChildren(child.props.children);
  return children2.length ? includesChildren(children2, ...types) : false;
});
var omitChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type !== type));
var pickChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type === type));
var cx = (...classNames2) => classNames2.filter(Boolean).join(" ");
var isRefObject = (val) => isObject(val) && "current" in val;
var assignRef = (ref, value) => {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
};
var mergeRefs = (...refs) => (node3) => {
  refs.forEach((ref) => {
    assignRef(ref, node3);
  });
};
var useMergeRefs = (...refs) => React.useMemo(() => mergeRefs(...refs), [refs]);
var useCallbackRef = (callback, deps = []) => {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useCallback(
    (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    deps
  );
};
var useUpdateEffect = (callback, deps) => {
  const renderCycleRef = React.useRef(false);
  const effectCycleRef = React.useRef(false);
  React.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) return callback();
    effectCycleRef.current = true;
  }, deps);
  React.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};
var useAsync = (func2, deps = []) => {
  const [state, callback] = useAsyncFunc(func2, deps, { loading: true });
  React.useEffect(() => {
    callback();
  }, [callback]);
  return state;
};
var useAsyncFunc = (func2, deps = [], initialState2 = { loading: false }) => {
  const lastCallId = React.useRef(0);
  const [isMounted] = useIsMounted();
  const [state, setState] = React.useState(initialState2);
  const callback = React.useCallback(
    (...args) => {
      const callId = ++lastCallId.current;
      if (!state.loading)
        setState((prevState) => ({ ...prevState, loading: true }));
      return func2(...args).then(
        (value) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ value, loading: false });
          return value;
        },
        (error) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ error, loading: false });
          return error;
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return [state, callback];
};
var useAsyncRetry = (func2, deps = []) => {
  const [attempt, setAttempt] = React.useState(0);
  const state = useAsync(func2, [...deps, attempt]);
  const stateLoading = state.loading;
  const retry = React.useCallback(() => {
    if (stateLoading) return;
    setAttempt((currentAttempt) => currentAttempt + 1);
  }, [...deps, stateLoading]);
  return { ...state, retry };
};
var createIdCounter = 0;
var createId = (prefix3) => `${prefix3}-${++createIdCounter}-${(/* @__PURE__ */ new Date()).getTime()}`;

// node_modules/@yamada-ui/utils/dist/chunk-2AQWXBLU.mjs
var escape = (value, replaceValue = "") => value.replace(/\s+/g, replaceValue);
var antonym = (value) => {
  switch (value) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "left":
      return "right";
    case "right":
      return "left";
    case "start":
      return "end";
    case "end":
      return "start";
    case "x":
      return "y";
    case "y":
      return "x";
    case "enter":
      return "exit";
    case "exit":
      return "enter";
    case "vertical":
      return "horizontal";
    case "horizontal":
      return "vertical";
    case "up":
      return "down";
    case "down":
      return "up";
    case "block":
      return "inline";
    case "inline":
      return "block";
    default:
      return value;
  }
};
var toCamelCase = (value) => value.toLowerCase().replace(/[_-](.)/g, (_, val) => val.toUpperCase()).replace(/^(.)/, (_, val) => val.toUpperCase());
var toKebabCase = (value) => value.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase().replace(/^-/, "");
var toTitleCase = (value) => value.replace(/([A-Z])/g, " $1").replace(/[_-](.)/g, (_, val) => ` ${val.toUpperCase()}`).replace(/^./, (str) => str.toUpperCase()).trim();

// node_modules/@yamada-ui/utils/dist/chunk-WV6P7ZCI.mjs
var filterEmpty = (array) => array.filter((value) => value != null);

// node_modules/@yamada-ui/utils/dist/chunk-L56KWSQO.mjs
var toExpression = (operator, ...args) => args.join(` ${operator} `).replace(/calc/g, "");
var add = (...args) => `calc(${toExpression("+", ...args)})`;
var subtract = (...args) => `calc(${toExpression("-", ...args)})`;
var multiply = (...args) => `calc(${toExpression("*", ...args)})`;
var divide = (...args) => `calc(${toExpression("/", ...args)})`;
var negate = (value) => {
  if (value != null && !isNaN(parseFloat(value.toString())))
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...args) => calc(add(x, ...args)),
    subtract: (...args) => calc(subtract(x, ...args)),
    multiply: (...args) => calc(multiply(x, ...args)),
    divide: (...args) => calc(divide(x, ...args)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@yamada-ui/utils/dist/chunk-4RMQGQHI.mjs
var omitObjectHelper = (obj, path) => {
  if (!path.length) return obj;
  const [primaryKey, ...restKeys] = path;
  if (restKeys.length === 0 && primaryKey in obj) {
    const { [primaryKey]: _, ...rest } = obj;
    return rest;
  }
  if (obj[primaryKey] && isObject(obj[primaryKey])) {
    return {
      ...obj,
      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys)
    };
  }
  return obj;
};
var omitObject = (obj, keys2) => {
  return keys2.reduce((prev2, key) => {
    const path = isString(key) ? key.split(".") : [];
    return omitObjectHelper(prev2, path);
  }, obj);
};
var pickObject = (obj, keys2, fallbackValue = "__fallback") => keys2.reduce((prev2, key) => {
  const path = isString(key) ? key.split(".") : [];
  if (!path.length) return prev2;
  const value = getMemoizedObject(obj, key, fallbackValue);
  if (value === fallbackValue) return prev2;
  prev2 = merge(
    prev2,
    path.reduceRight(
      (prev22, key2) => ({ [key2]: key2 === path.at(-1) ? value : prev22 }),
      {}
    )
  );
  return prev2;
}, {});
var splitObject = (obj, keys2) => {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(obj)) {
    if (keys2.includes(key)) {
      picked[key] = value;
    } else {
      omitted[key] = value;
    }
  }
  return [picked, omitted];
};
var filterObject = (obj, func2) => {
  const result = {};
  Object.entries(obj).forEach(([key, value]) => {
    const shouldPass = func2(key, value, obj);
    if (shouldPass) result[key] = value;
  });
  return result;
};
var filterUndefined = (obj) => filterObject(obj, (_, val) => val !== null && val !== void 0);
var merge = (target, source, mergeArray = false) => {
  let result = Object.assign({}, target);
  if (isObject(source)) {
    if (isObject(target)) {
      for (const [sourceKey, sourceValue] of Object.entries(source)) {
        const targetValue = target[sourceKey];
        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {
          result[sourceKey] = targetValue.concat(...sourceValue);
        } else if (!isFunction(sourceValue) && isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
          result[sourceKey] = merge(targetValue, sourceValue, mergeArray);
        } else {
          Object.assign(result, { [sourceKey]: sourceValue });
        }
      }
    } else {
      result = source;
    }
  }
  return result;
};
var flattenObject = (obj, maxDepth2 = Infinity, omitKeys = []) => {
  if (!isObject(obj) && !isArray(obj) || !maxDepth2) return obj;
  return Object.entries(obj).reduce((result, [key, value]) => {
    if (isObject(value) && !Object.keys(value).some((key2) => omitKeys.includes(key2))) {
      Object.entries(flattenObject(value, maxDepth2 - 1, omitKeys)).forEach(
        ([childKey, childValue]) => {
          result[`${key}.${childKey}`] = childValue;
        }
      );
    } else {
      result[key] = value;
    }
    return result;
  }, {});
};
var objectFromEntries = (entries) => entries.reduce((result, [key, value]) => {
  result[key] = value;
  return result;
}, {});
var keysFormObject = (obj) => Object.keys(obj);
var replaceObject = (objOrArray, callBack) => {
  if (isArray(objOrArray)) {
    return objOrArray.map(callBack);
  } else if (isObject(objOrArray)) {
    return Object.entries(objOrArray).reduce((obj, [key, value]) => {
      obj[key] = callBack(value);
      return obj;
    }, {});
  } else {
    return callBack(objOrArray);
  }
};
var getObject = (obj, path, fallback, i) => {
  const k = isString(path) ? path.split(/\[(.*?)\]|\./).filter(Boolean) : [path];
  for (i = 0; i < k.length; i += 1) {
    if (!obj) break;
    obj = obj[k[i]];
  }
  return obj === void 0 ? fallback : obj;
};
var memoizeObject = (func2) => {
  const cache2 = /* @__PURE__ */ new WeakMap();
  const memoizedFunc = (obj, path, fallback, i) => {
    if (isUndefined(obj)) return func2(obj, path, fallback);
    if (!cache2.has(obj)) cache2.set(obj, /* @__PURE__ */ new Map());
    const map = cache2.get(obj);
    if (map.has(path)) return map.get(path);
    const value = func2(obj, path, fallback, i);
    map.set(path, value);
    return value;
  };
  return memoizedFunc;
};
var getMemoizedObject = memoizeObject(getObject);
var assignAfter = (target, ...sources) => {
  if (target == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null) continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue;
      if (nextKey in result) delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
};

// node_modules/color2k/dist/index.exports.import.es.mjs
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
var ColorError = class extends Error {
  constructor(color2) {
    super(`Failed to parse color: "${color2}"`);
  }
};
var ColorError$1 = ColorError;
function parseToRgba(color2) {
  if (typeof color2 !== "string") throw new ColorError$1(color2);
  if (color2.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
  let normalizedColor = color2.trim();
  normalizedColor = namedColorRegex.test(color2) ? nameToHex(color2) : color2;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color2);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color2);
    return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color2);
}
function hash(str) {
  let hash5 = 5381;
  let i = str.length;
  while (i) {
    hash5 = hash5 * 33 ^ str.charCodeAt(--i);
  }
  return (hash5 >>> 0) % 2341;
}
var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next2) => {
  const key = colorToInt(next2.substring(0, 3));
  const hex2 = colorToInt(next2.substring(3)).toString(16);
  let prefix3 = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix3 += "0";
  }
  acc[key] = `${prefix3}${hex2}`;
  return acc;
}, {});
function nameToHex(color2) {
  const normalizedColorName = color2.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result) throw new ColorError$1(color2);
  return `#${result}`;
}
var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
var namedColorRegex = /^[a-z]+$/i;
var roundColor = (color2) => {
  return Math.round(color2 * 255);
};
var hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function parseToHsla(color2) {
  const [red, green, blue, alpha2] = parseToRgba(color2).map((value, index) => (
    // 3rd index is alpha channel which is already normalized
    index === 3 ? value : value / 255
  ));
  const max2 = Math.max(red, green, blue);
  const min2 = Math.min(red, green, blue);
  const lightness = (max2 + min2) / 2;
  if (max2 === min2) return [0, 0, lightness, alpha2];
  const delta = max2 - min2;
  const saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
  const hue = 60 * (red === max2 ? (green - blue) / delta + (green < blue ? 6 : 0) : green === max2 ? (blue - red) / delta + 2 : (red - green) / delta + 4);
  return [hue, saturation, lightness, alpha2];
}
function hsla(hue, saturation, lightness, alpha2) {
  return `hsla(${(hue % 360).toFixed()}, ${guard(0, 100, saturation * 100).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
}
function darken(color2, amount) {
  const [hue, saturation, lightness, alpha2] = parseToHsla(color2);
  return hsla(hue, saturation, lightness - amount, alpha2);
}
function rgba(red, green, blue, alpha2) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
}
function mix(color1, color2, weight) {
  const normalize = (n, index) => (
    // 3rd index is alpha channel which is already normalized
    index === 3 ? n : n / 255
  );
  const [r1, g1, b1, a1] = parseToRgba(color1).map(normalize);
  const [r2, g2, b2, a2] = parseToRgba(color2).map(normalize);
  const alphaDelta = a2 - a1;
  const normalizedWeight = weight * 2 - 1;
  const combinedWeight = normalizedWeight * alphaDelta === -1 ? normalizedWeight : normalizedWeight + alphaDelta / (1 + normalizedWeight * alphaDelta);
  const weight2 = (combinedWeight + 1) / 2;
  const weight1 = 1 - weight2;
  const r3 = (r1 * weight1 + r2 * weight2) * 255;
  const g = (g1 * weight1 + g2 * weight2) * 255;
  const b = (b1 * weight1 + b2 * weight2) * 255;
  const a = a2 * weight + a1 * (1 - weight);
  return rgba(r3, g, b, a);
}
function lighten(color2, amount) {
  return darken(color2, -amount);
}
function transparentize(color2, amount) {
  const [r2, g, b, a] = parseToRgba(color2);
  return rgba(r2, g, b, a - amount);
}
function toHex(color2) {
  const [r2, g, b, a] = parseToRgba(color2);
  let hex2 = (x) => {
    const h = guard(0, 255, x).toString(16);
    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex2(r2)}${hex2(g)}${hex2(b)}${a < 1 ? hex2(Math.round(a * 255)) : ""}`;
}
function toRgba(color2) {
  return rgba(...parseToRgba(color2));
}
function toHsla(color2) {
  return hsla(...parseToHsla(color2));
}

// node_modules/@yamada-ui/utils/dist/chunk-2D5DJ5AJ.mjs
var SEMANTIC_COLOR_SCHEMES = [
  "mono",
  "primary",
  "secondary",
  "info",
  "success",
  "warning",
  "danger",
  "link"
];
var COLOR_SCHEMES = [
  "gray",
  "neutral",
  "red",
  "rose",
  "pink",
  "flashy",
  "orange",
  "amber",
  "yellow",
  "lime",
  "green",
  "emerald",
  "teal",
  "cyan",
  "sky",
  "blue",
  "indigo",
  "violet",
  "purple",
  "fuchsia"
];
var TONES = [
  50,
  100,
  200,
  300,
  400,
  500,
  600,
  700,
  800,
  900,
  950
];
var isGray = (colorScheme) => colorScheme === "gray" || colorScheme === "neutral";
var isAccessible = (colorScheme) => colorScheme === "yellow" || colorScheme === "cyan" || colorScheme === "lime";
var getColor = (color2, fallback = "#000000") => (theme = {}, colorMode) => {
  var _a, _b, _c, _d, _e, _f;
  const [token2, tone] = color2.split(".");
  if (tone) {
    const [, relatedToken] = (_c = Object.entries((_b = (_a = theme.semantics) == null ? void 0 : _a.colorSchemes) != null ? _b : {}).find(
      ([semanticToken]) => token2 === semanticToken
    )) != null ? _c : [];
    if (relatedToken) color2 = `${relatedToken}.${tone}`;
  } else {
    const [, relatedColor] = (_f = Object.entries((_e = (_d = theme.semantics) == null ? void 0 : _d.colors) != null ? _e : {}).find(
      ([semanticToken]) => token2 === semanticToken
    )) != null ? _f : [];
    if (relatedColor) color2 = relatedColor;
  }
  const hex2 = getMemoizedObject(theme, `colors.${color2}`, color2);
  try {
    if (isArray(hex2)) {
      return toHex(String(colorMode !== "dark" ? hex2[0] : hex2[1]));
    } else {
      return toHex(String(hex2));
    }
  } catch {
    try {
      return toHex(fallback);
    } catch {
      return "#000000";
    }
  }
};
var lightenColor = (color2, amount) => (theme, colorMode) => {
  const raw = getColor(color2, color2)(theme, colorMode);
  return toHex(lighten(raw, amount / 100));
};
var darkenColor = (color2, amount) => (theme, colorMode) => {
  const raw = getColor(color2, color2)(theme, colorMode);
  return toHex(darken(raw, amount / 100));
};
var tintColor = (color2, amount) => (theme, colorMode) => {
  const raw = getColor(color2, color2)(theme, colorMode);
  return toHex(mix(raw, "#fff", amount / 100));
};
var shadeColor = (color2, amount) => (theme, colorMode) => {
  const raw = getColor(color2, color2)(theme, colorMode);
  return toHex(mix(raw, "#000", amount / 100));
};
var transparentizeColor = (color2, alpha2) => (theme, colorMode) => {
  const raw = getColor(color2, color2)(theme, colorMode);
  return transparentize(raw, 1 - alpha2);
};
var randomColor = ({
  string: string2,
  colors: colors2
} = {}) => {
  const fallback = randomHex();
  if (string2 && colors2) return randomColorFromList(string2, colors2);
  if (string2 && !colors2) return randomColorFromString(string2);
  if (colors2 && !string2) return randomFromList(colors2);
  return fallback;
};
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
var randomColorFromString = (str) => {
  let hash5 = 0;
  if (str.length === 0) return hash5.toString();
  for (let i = 0; i < str.length; i += 1) {
    hash5 = str.charCodeAt(i) + ((hash5 << 5) - hash5);
    hash5 = hash5 & hash5;
  }
  let color2 = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash5 >> j * 8 & 255;
    color2 += `00${value.toString(16)}`.substr(-2);
  }
  return color2;
};
var randomColorFromList = (str, list) => {
  let index = 0;
  if (str.length === 0) return list[0];
  for (let i = 0; i < str.length; i += 1) {
    index = str.charCodeAt(i) + ((index << 5) - index);
    index = index & index;
  }
  index = (index % list.length + list.length) % list.length;
  return list[index];
};
var randomFromList = (list) => list[Math.floor(Math.random() * list.length)];
var getBrightness = (color2) => {
  const [r2, g, b] = parseToRgba(color2);
  return (r2 * 299 + g * 587 + b * 114) / 1e3;
};
var isTone = (color2) => (theme, colorMode) => {
  const raw = theme ? getColor(color2)(theme, colorMode) : color2;
  const brightness = getBrightness(raw);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
var isLight = (color2) => (theme, colorMode) => isTone(color2)(theme, colorMode) === "dark";
var isDark = (color2) => (theme, colorMode) => isTone(color2)(theme, colorMode) === "light";
var convertColor = (color2, fallback) => (format) => {
  try {
    const isAlpha = format.endsWith("a");
    if (/^[0-9a-fA-F]{6}$/.test(color2)) color2 = "#" + color2;
    if (format.startsWith("hex")) {
      let hexa = toHex(color2);
      if (isAlpha) {
        if (hexa.length === 7) hexa += "ff";
      } else {
        hexa = hexa.replace(new RegExp("(?<=^#([0-9a-fA-F]{6}))[0-9a-fA-F]{2}$"), "");
      }
      return hexa;
    } else if (format.startsWith("hsl")) {
      let hsla22 = toHsla(color2);
      if (!isAlpha) {
        hsla22 = hsla22.replace(/hsla/, "hsl");
        hsla22 = hsla22.replace(/,\s*\d+(\.\d+)?\)$/, ")");
      }
      return hsla22;
    } else {
      let rgba22 = toRgba(color2);
      if (!isAlpha) {
        rgba22 = rgba22.replace(/rgba/, "rgb");
        rgba22 = rgba22.replace(/,\s*\d+(\.\d+)?\)$/, ")");
      }
      return rgba22;
    }
  } catch {
    if (fallback) return convertColor(fallback)(format);
  }
};
var calcFormat = (color2) => {
  if (color2.startsWith("hsl")) {
    return color2.startsWith("hsla") ? "hsla" : "hsl";
  } else if (color2.startsWith("rgb")) {
    return color2.startsWith("rgba") ? "rgba" : "rgb";
  } else {
    return color2.length === 9 ? "hexa" : "hex";
  }
};
var getAlpha = (color2) => parseToRgba(color2)[3];
var alphaToHex = (a) => {
  if (0 > a) a = 0;
  if (1 < a) a = 1;
  return Math.round(a * 255).toString(16).padStart(2, "0");
};
var parseToRgba2 = (color2, fallback) => {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color2)) color2 = "#" + color2;
    return parseToRgba(color2);
  } catch {
    if (fallback) return parseToRgba(fallback);
  }
};
var parseToHsla2 = (color2, fallback) => {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color2)) color2 = "#" + color2;
    return parseToHsla(color2);
  } catch {
    if (fallback) return parseToHsla(fallback);
  }
};
var parseToHsv = (color2, fallback) => {
  var _a;
  let [r2, g, b, a] = (_a = parseToRgba2(color2, fallback)) != null ? _a : [255, 255, 255, 1];
  r2 = r2 / 255;
  g = g / 255;
  b = b / 255;
  const [min2, max2] = [Math.min(r2, g, b), Math.max(r2, g, b)];
  const delta = max2 - min2;
  let [h, v, s] = [0, max2, max2 == 0 ? 0 : delta / max2];
  switch (min2) {
    case max2:
      h = 0;
      break;
    case r2:
      h = 60 * ((b - g) / delta) + 180;
      break;
    case g:
      h = 60 * ((r2 - b) / delta) + 300;
      break;
    case b:
      h = 60 * ((g - r2) / delta) + 60;
      break;
  }
  return [h, s, v, a];
};
var rgbaTo = ([r2, g, b, a], fallback) => (format = "hex") => convertColor(rgba(r2, g, b, a), fallback)(format);
var hslaTo = ([h, s, l, a], fallback) => (format = "hex") => convertColor(hsla(h, s, l, a), fallback)(format);
var hsvTo = ([h, s, v, a], fallback) => (format = "hex") => {
  h = h / 60;
  let rgb = [v, v, v];
  let i = Math.floor(h);
  let f = h - i;
  let p = v * (1 - s);
  let q = v * (1 - s * f);
  let t = v * (1 - s * (1 - f));
  switch (i) {
    case 0:
    case 6:
      rgb = [v, t, p];
      break;
    case 1:
      rgb = [q, v, p];
      break;
    case 2:
      rgb = [p, v, t];
      break;
    case 3:
      rgb = [p, q, v];
      break;
    case 4:
      rgb = [t, p, v];
      break;
    case 5:
      rgb = [v, p, q];
      break;
  }
  let color2 = `rgb(${rgb.map((v2) => Math.round(v2 * 255)).join(", ")})`;
  if (isNumber(a)) color2 = color2.replace(/\)$/, `, ${a})`);
  return convertColor(color2, fallback)(format);
};
var sameColor = (color2, comparison) => {
  var _a, _b;
  if (!color2) return false;
  if (!comparison) return false;
  const a = (_a = parseToRgba2(color2)) != null ? _a : [];
  const b = (_b = parseToRgba2(comparison)) != null ? _b : [];
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

// node_modules/@yamada-ui/utils/dist/chunk-S35WPDIT.mjs
var createdDom = () => !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getPlatform = () => {
  var _a, _b;
  return (_b = (_a = navigator.userAgentData) == null ? void 0 : _a.platform) != null ? _b : navigator.platform;
};
var vendor = (v) => createdDom() && v.test(navigator.vendor);
var platform = (v) => createdDom() && v.test(getPlatform());
var isMac = () => platform(/^mac/i);
var isApple = () => platform(/mac|iphone|ipad|ipod/i);
var isSafari = () => isApple() && vendor(/apple/i);
var isElement = (el) => el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
var isHTMLElement = (el) => {
  var _a;
  if (!isElement(el)) return false;
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
};
var isHidden = (el) => {
  if (el.parentElement && isHidden(el.parentElement)) return true;
  return el.hidden;
};
var isDisabled = (el) => Boolean(el.getAttribute("disabled")) === true || Boolean(el.getAttribute("data-disabled")) === true || Boolean(el.getAttribute("aria-disabled")) === true;
var isVisible = (el) => el.offsetWidth > 0 && el.offsetHeight > 0;
var hasTabIndex = (el) => el.hasAttribute("tabindex");
var isContentEditable = (el) => {
  const value = el.getAttribute("contenteditable");
  return value !== "false" && value != null;
};
var isContains = (parent, child) => {
  return parent === child || (parent == null ? void 0 : parent.contains(child));
};
var getPx = (value) => {
  if (isNumber(value)) return value;
  if (isUndefined(value)) return 0;
  if (value.includes("px")) return parseFloat(value);
  const isBrowser4 = createdDom();
  let fontSize = 16;
  if (isBrowser4) {
    const style = window.getComputedStyle(document.documentElement);
    const computedFontSize = parseFloat(style.fontSize);
    if (!isNaN(computedFontSize)) fontSize = computedFontSize;
  }
  return parseFloat(value) * fontSize;
};
var getEventRelatedTarget = (ev) => {
  var _a;
  return (_a = ev.relatedTarget) != null ? _a : ev.currentTarget.ownerDocument.activeElement;
};
var dataAttr = (condition) => condition ? "" : void 0;
var ariaAttr = (condition) => condition ? true : void 0;
var focusableElList = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
];
var focusableElSelector = focusableElList.join();
var getAllFocusable = (container) => {
  const focusableEls = Array.from(
    container.querySelectorAll(focusableElSelector)
  );
  focusableEls.unshift(container);
  return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
};
var isFocusable = (el) => {
  if (!isHTMLElement(el) || isHidden(el) || isDisabled(el)) {
    return false;
  }
  const { localName } = el;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0) return true;
  const others = {
    a: () => el.hasAttribute("href"),
    audio: () => el.hasAttribute("controls"),
    video: () => el.hasAttribute("controls")
  };
  if (localName in others) return others[localName]();
  if (isContentEditable(el)) return true;
  return hasTabIndex(el);
};
var hasNegativeTabIndex = (el) => hasTabIndex(el) && el.tabIndex === -1;
var isTabbable = (el) => el ? isHTMLElement(el) && isFocusable(el) && !hasNegativeTabIndex(el) : false;
var isTouchDevice = () => "ontouchstart" in window;
var getOwnerWindow = (node3) => {
  var _a, _b;
  return (_b = (_a = getOwnerDocument(node3)) == null ? void 0 : _a.defaultView) != null ? _b : window;
};
var getOwnerDocument = (el) => isElement(el) ? el.ownerDocument : document;
var getActiveElement = (el) => getOwnerDocument(el).activeElement;
var isActiveElement = (el) => {
  return getActiveElement(el) === el;
};

// node_modules/@yamada-ui/utils/dist/chunk-MMZ4T26E.mjs
var isMouseEvent = (ev) => {
  const win = getEventWindow(ev);
  if (typeof win.PointerEvent !== "undefined" && ev instanceof win.PointerEvent)
    return !!(ev.pointerType === "mouse");
  return ev instanceof win.MouseEvent;
};
var isTouchEvent = (ev) => !!ev.touches;
var isMultiTouchEvent = (ev) => isTouchEvent(ev) && ev.touches.length > 1;
var getEventWindow = (ev) => {
  var _a;
  return (_a = ev.view) != null ? _a : window;
};
var pointFromTouch = (e, type = "page") => {
  const point2 = e.touches[0] || e.changedTouches[0];
  return { x: point2[`${type}X`], y: point2[`${type}Y`] };
};
var pointFromMouse = (point2, type = "page") => ({
  x: point2[`${type}X`],
  y: point2[`${type}Y`]
});
var getEventPoint = (ev, type = "page") => isTouchEvent(ev) ? pointFromTouch(ev, type) : pointFromMouse(ev, type);
var addDomEvent = (target, type, cb, options) => {
  target.addEventListener(type, cb, options);
  return () => {
    target.removeEventListener(type, cb, options);
  };
};
var filter = (cb) => (ev) => {
  const isMouse = isMouseEvent(ev);
  if (!isMouse || isMouse && ev.button === 0) cb(ev);
};
var wrap = (cb, filterPrimary = false) => {
  const listener = (ev) => cb(ev, { point: getEventPoint(ev) });
  const fn2 = filterPrimary ? filter(listener) : listener;
  return fn2;
};
var addPointerEvent = (target, type, cb, options) => addDomEvent(target, type, wrap(cb, type === "pointerdown"), options);

// node_modules/@yamada-ui/utils/dist/chunk-VRHGQ632.mjs
var noop = () => {
};
var runIfFunc = (valOrFunc, ...args) => isFunction(valOrFunc) ? valOrFunc(...args) : valOrFunc;
var handlerAll = (...funcs) => (event, ...args) => {
  funcs.some((func2) => {
    func2 == null ? void 0 : func2(event, ...args);
    return event == null ? void 0 : event.defaultPrevented;
  });
};
var funcAll = (...funcs) => (...args) => funcs.forEach((func2) => func2 == null ? void 0 : func2(...args));

// node_modules/@yamada-ui/core/node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var React3 = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate2(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet2 = sheetForTag(tag);
      try {
        sheet2.insertRule(rule, sheet2.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props2, children, length2) {
  return { value, root, parent, type, props: props2, children, line, column, length: length2, return: "" };
}
function copy(root, props2) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props2);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props2 = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index, offset2, rules, points, type, props2 = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference2, reference2, props2, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props2 = [], length2), children), rules, children, length2, points, rule ? props2 : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset2, rules, points, type, props2, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props2[k++] = z;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props2, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
init_emotion_memoize_esm();
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
  return function(element, index, children) {
    if (element.type !== "rule" || cache2.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node3 = commentContainer[i];
        if (node3.line < element.line) {
          break;
        }
        if (node3.column < element.column) {
          if (isIgnoringComment(node3)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node3) {
      var dataEmotionAttribute = node3.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node3);
      node3.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node3) {
        var attrib = node3.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node3);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache2.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet2, shouldCache) {
      currentSheet = sheet2;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet2.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@yamada-ui/core/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func2) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func2(arg);
    cache2.set(arg, ret);
    return ret;
  };
};

// node_modules/@yamada-ui/core/node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
init_emotion_memoize_esm();
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes6 = interpolation;
      if (keyframes6.anim === 1) {
        cursor = {
          name: keyframes6.name,
          styles: keyframes6.styles,
          next: cursor
        };
        return keyframes6.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        if (serializedStyles.map !== void 0) {
          styles2 += serializedStyles.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string2 += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string2 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string2 += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      if (templateStringsArr[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += templateStringsArr[i];
    }
  }
  var sourceMap;
  {
    styles2 = styles2.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  {
    var devStyles = {
      name,
      styles: styles2,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React2 = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React2["useInsertionEffect"] ? React2["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React2.useLayoutEffect;

// node_modules/@yamada-ui/core/node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var isBrowser2 = true;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = React3.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
if (true) {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func2) {
  return (0, import_react.forwardRef)(function(props2, ref) {
    var cache2 = (0, import_react.useContext)(EmotionCacheContext);
    return func2(props2, cache2, ref);
  });
};
if (!isBrowser2) {
  withEmotionCache = function withEmotionCache3(func2) {
    return function(props2) {
      var cache2 = (0, import_react.useContext)(EmotionCacheContext);
      if (cache2 === null) {
        cache2 = createCache({
          key: "css"
        });
        return React3.createElement(EmotionCacheContext.Provider, {
          value: cache2
        }, func2(props2, cache2));
      } else {
        return func2(props2, cache2);
      }
    };
  };
}
var ThemeContext = React3.createContext({});
if (true) {
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var ThemeProvider = function ThemeProvider2(props2) {
  var theme = React3.useContext(ThemeContext);
  if (props2.theme !== theme) {
    theme = createCacheWithTheme(theme)(props2.theme);
  }
  return React3.createElement(ThemeContext.Provider, {
    value: theme
  }, props2.children);
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var Insertion = function Insertion2(_ref2) {
  var cache2 = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props2, cache2, ref) {
  var cssProp = props2.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props2[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props2.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props2.className);
  } else if (props2.className != null) {
    className = props2.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React3.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props2[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props2) {
    if (hasOwnProperty.call(props2, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
      newProps[key] = props2[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React3.createElement(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@yamada-ui/core/node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var React4 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var pkg = {
  name: "@emotion/react",
  version: "11.11.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props2, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (props2.className || props2.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles2 = props2.styles;
  var serialized = serializeStyles([styles2], void 0, React4.useContext(ThemeContext));
  if (!isBrowser2) {
    var _ref2;
    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      serializedStyles += next2.styles;
      next2 = next2.next;
    }
    var shouldCache = cache2.compat === true;
    var rules = cache2.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache2.sheet, shouldCache);
    if (shouldCache) {
      return null;
    }
    return React4.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + "-global " + serializedNames, _ref2.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref2.nonce = cache2.sheet.nonce, _ref2));
  }
  var sheetRef = React4.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet2 = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node3 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet2.before = cache2.sheet.tags[0];
    }
    if (node3 !== null) {
      rehydrating = true;
      node3.setAttribute("data-emotion", key);
      sheet2.hydrate([node3]);
    }
    sheetRef.current = [sheet2, rehydrating];
    return function() {
      sheet2.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet2 = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet2.tags.length) {
      var element = sheet2.tags[sheet2.tags.length - 1].nextElementSibling;
      sheet2.before = element;
      sheet2.flush();
    }
    cache2.insert("", serialized, sheet2, false);
  }, [cache2, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge2(registered, css4, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css4(registeredStyles);
}
var Insertion3 = function Insertion4(_ref2) {
  var cache2 = _ref2.cache, serializedArr = _ref2.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache2, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props2, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css4 = function css5() {
    if (hasRendered && true) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx3 = function cx4() {
    if (hasRendered && true) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge2(cache2.registered, css4, classnames(args));
  };
  var content = {
    css: css4,
    cx: cx3,
    theme: React4.useContext(ThemeContext)
  };
  var ele = props2.children(content);
  hasRendered = true;
  return React4.createElement(React4.Fragment, null, React4.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = "EmotionClassNames";
}
if (true) {
  isBrowser4 = true;
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser4 && !isTestEnv) {
    globalContext = // $FlowIgnore
    typeof globalThis !== "undefined" ? globalThis : isBrowser4 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser4;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@yamada-ui/core/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react_fast_compare = __toESM(require_react_fast_compare(), 1);

// node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js
function insertWithoutScoping(cache2, serialized) {
  if (cache2.inserted[serialized.name] === void 0) {
    return cache2.insert("", serialized, cache2.sheet, true);
  }
}
function merge3(registered, css4, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css4(registeredStyles);
}
var createEmotion = function createEmotion2(options) {
  var cache2 = createCache(options);
  cache2.sheet.speedy = function(value) {
    if (this.ctr !== 0) {
      throw new Error("speedy must be changed before any rules are inserted");
    }
    this.isSpeedy = value;
  };
  cache2.compat = true;
  var css4 = function css5() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered, void 0);
    insertStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var keyframes6 = function keyframes7() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var serialized = serializeStyles(args, cache2.registered);
    var animation2 = "animation-" + serialized.name;
    insertWithoutScoping(cache2, {
      name: serialized.name,
      styles: "@keyframes " + animation2 + "{" + serialized.styles + "}"
    });
    return animation2;
  };
  var injectGlobal2 = function injectGlobal3() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    var serialized = serializeStyles(args, cache2.registered);
    insertWithoutScoping(cache2, serialized);
  };
  var cx3 = function cx4() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return merge3(cache2.registered, css4, classnames3(args));
  };
  return {
    css: css4,
    cx: cx3,
    injectGlobal: injectGlobal2,
    keyframes: keyframes6,
    hydrate: function hydrate2(ids) {
      ids.forEach(function(key) {
        cache2.inserted[key] = true;
      });
    },
    flush: function flush2() {
      cache2.registered = {};
      cache2.inserted = {};
      cache2.sheet.flush();
    },
    // $FlowFixMe
    sheet: cache2.sheet,
    cache: cache2,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache2.registered),
    merge: merge3.bind(null, cache2.registered, css4)
  };
};
var classnames3 = function classnames4(args) {
  var cls = "";
  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames4(arg);
        } else {
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// node_modules/@emotion/css/dist/emotion-css.esm.js
var _createEmotion = createEmotion({
  key: "css"
});
var flush = _createEmotion.flush;
var hydrate = _createEmotion.hydrate;
var cx2 = _createEmotion.cx;
var merge4 = _createEmotion.merge;
var getRegisteredStyles2 = _createEmotion.getRegisteredStyles;
var injectGlobal = _createEmotion.injectGlobal;
var keyframes3 = _createEmotion.keyframes;
var css2 = _createEmotion.css;
var sheet = _createEmotion.sheet;
var cache = _createEmotion.cache;

// node_modules/@yamada-ui/core/dist/index.mjs
var import_react9 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@yamada-ui/core/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var React5 = __toESM(require_react());
init_emotion_is_prop_valid_esm();
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var Insertion5 = function Insertion6(_ref2) {
  var cache2 = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  if (true) {
    if (tag === void 0) {
      throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
    }
  }
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      if (args[0][0] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
      }
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        if (args[0][i] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
        }
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props2, cache2, ref) {
      var FinalTag = shouldUseAs && props2.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props2;
      if (props2.theme == null) {
        mergedProps = {};
        for (var key in props2) {
          mergedProps[key] = props2[key];
        }
        mergedProps.theme = React5.useContext(ThemeContext);
      }
      if (typeof props2.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props2.className);
      } else if (props2.className != null) {
        className = props2.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props2) {
        if (shouldUseAs && _key === "as") continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props2[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return React5.createElement(React5.Fragment, null, React5.createElement(Insertion5, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), React5.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && true) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};

// node_modules/@yamada-ui/core/node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
var import_react3 = __toESM(require_react());
init_emotion_is_prop_valid_esm();
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});

// node_modules/@yamada-ui/core/dist/index.mjs
var import_react14 = __toESM(require_react(), 1);
var pseudos = {
  /**
   * The CSS `:hover` pseudo-class.
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * The CSS `:hover` pseudo-class.
   */
  _nativeHover: "&:hover",
  /**
   * The CSS `:active` pseudo-class.
   */
  _active: "&:active, &[data-active]",
  /**
   * The CSS `:active` pseudo-class.
   */
  _nativeActive: "&:active",
  /**
   * The CSS `:target` pseudo-class.
   */
  _target: "&:target, &[data-target]",
  /**
   * The CSS `:not(:target)` pseudo-class.
   */
  _notTarget: "&:not(:target)",
  /**
   * The CSS `:target` pseudo-class.
   */
  _nativeTarget: "&:target",
  /**
   * The CSS `:focus` pseudo-class.
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * The CSS `:focus` pseudo-class.
   */
  _nativeFocus: "&:focus",
  /**
   * The CSS `:focus-visible` pseudo-class.
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * The CSS `:focus-visible` pseudo-class.
   */
  _nativeFocusVisible: "&:focus-visible",
  /**
   * The CSS `:focus-within` pseudo-class.
   */
  _focusWithin: "&:focus-within, &[data-focus-within]",
  /**
   * The CSS `:focus-within` pseudo-class.
   */
  _nativeFocusWithin: "&:focus-within",
  /**
   * The CSS `:disabled` pseudo-class.
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * The CSS `:disabled` pseudo-class.
   */
  _nativeDisabled: "&:disabled, &[disabled]",
  /**
   * The CSS `:read-only` pseudo-class.
   */
  _readOnly: "&[readonly], &[aria-readonly=true], &[data-readonly]",
  /**
   * The CSS `:read-only` pseudo-class.
   */
  _nativeReadOnly: "&[readonly], &[aria-readonly=true]",
  /**
   * The CSS `:indeterminate` pseudo-class.
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * The CSS `::before` pseudo-element.
   */
  _before: "&::before",
  /**
   * The CSS `::after` pseudo-element.
   */
  _after: "&::after",
  /**
   * The CSS `::marker` pseudo-element.
   */
  _marker: "&::marker",
  /**
   * The CSS `::first-letter` pseudo-element.
   */
  _firstLetter: "&::first-letter",
  /**
   * The CSS `::first-line` pseudo-element.
   */
  _firstLine: "&::first-line",
  /**
   * The CSS `:empty` pseudo-class.
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`.
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * The CSS `:checked` pseudo-class.
   */
  _checked: "&:checked, &[data-checked], &[aria-checked=true]",
  /**
   * The CSS `:checked` pseudo-class.
   */
  _nativeChecked: "&:checked",
  /**
   * The CSS `:invalid` pseudo-class.
   */
  _invalid: "&[data-invalid], &[aria-invalid=true]",
  /**
   * The CSS `:valid` pseudo-class.
   */
  _valid: "&:valid, &[data-valid], &[data-state=valid]",
  /**
   * The CSS `:valid` pseudo-class.
   */
  _nativeValid: "&:valid",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`.
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * The CSS `[hidden=true]` pseudo-class.
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * The CSS `[hidden=true]` pseudo-class.
   */
  _nativeHidden: "&[hidden]",
  /**
   * The CSS `:visited` pseudo-class.
   */
  _visited: "&:visited",
  /**
   * The CSS `::placeholder` pseudo-element.
   */
  _placeholder: "&::placeholder, &[data-placeholder]",
  /**
   * The CSS `:placeholder-shown` pseudo-class.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * The CSS `:fullscreen` pseudo-class.
   */
  _fullScreen: "&:fullscreen",
  /**
   * The CSS `::selection` pseudo-element.
   */
  _selection: "&::selection",
  /**
   * The CSS `:nth-of-type(even)` pseudo-class.
   */
  _even: "&:nth-of-type(even)",
  /**
   * The CSS `:nth-of-type(odd)` pseudo-class.
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * The CSS `:first-of-type` pseudo-class.
   */
  _first: "&:first-of-type",
  /**
   * The CSS `:last-of-type` pseudo-class.
   */
  _last: "&:last-of-type",
  /**
   * The CSS `:not(:first-of-type)` pseudo-class.
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * The CSS `:not(:last-of-type)` pseudo-class.
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * The CSS `:-webkit-autofill` pseudo-class.
   */
  _autofill: "&:-webkit-autofill",
  _filled: "&[data-filled]",
  _start: "&[data-start]",
  _end: "&[data-end]",
  _outside: "&:where([data-outside])",
  _between: "&[data-between]",
  _weekend: "&:where([data-weekend])",
  _holiday: "&[data-holiday]",
  _today: "&[data-today]",
  _accept: "&[data-accept]",
  _reject: "&[data-reject]",
  _idle: "&[data-idle]",
  _loading: "&[data-loading], &[aria-busy=true]",
  _loaded: "&[data-loaded]",
  _ripple: "& .ui-ripple",
  /**
   * The CSS `:vertical` pseudo-class.
   */
  _vertical: "&:vertical, &[aria-orientation=vertical], &[data-orientation=vertical]",
  /**
   * The CSS `:horizontal` pseudo-class.
   */
  _horizontal: "&:horizontal, &[aria-orientation=horizontal], &[data-orientation=horizontal]",
  /**
   * The CSS `::-webkit-scrollbar` pseudo-element.
   */
  _scrollbar: "&::-webkit-scrollbar",
  /**
   * The CSS `::-webkit-scrollbar-track` pseudo-element.
   */
  _scrollbarTrack: "&::-webkit-scrollbar-track",
  /**
   * The CSS `::-webkit-scrollbar-track-piece` pseudo-element.
   */
  _scrollbarTrackPiece: "&::-webkit-scrollbar-track-piece",
  /**
   * The CSS `::-webkit-scrollbar-thumb` pseudo-element.
   */
  _scrollbarThumb: "&::-webkit-scrollbar-thumb",
  /**
   * The CSS `::-webkit-scrollbar-button` pseudo-element.
   */
  _scrollbarButton: "&::-webkit-scrollbar-button",
  /**
   * The CSS `::-webkit-scrollbar-corner` pseudo-element.
   */
  _scrollbarCorner: "&::-webkit-scrollbar-corner",
  /**
   * The CSS `@media (prefers-color-scheme: dark)` media feature.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * The CSS `@media (prefers-reduced-motion: reduce)` media feature.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-mode` is applied to any parent of
   * this component or element.
   */
  _dark: ".ui-dark &:not([data-mode]), [data-mode=dark] &:not([data-mode]), &[data-mode=dark]",
  /**
   * Styles for when `data-mode` is applied to any parent of
   * this component or element.
   */
  _light: ".ui-light &:not([data-mode]), [data-mode=light] &:not([data-mode]), &[data-mode=light]"
};
var pseudosProperties = Object.keys(pseudos);
var pseudosSelectors = Object.values(pseudos);
var DEFAULT_VAR_PREFIX = "ui";
var globalValues = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]);
var isCSSFunction = (value) => isString(value) && value.includes("(") && value.includes(")");
var getCSSFunction = (value) => {
  var _a;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const [, type, values] = (_a = regex.exec(value)) != null ? _a : [];
  return { type, values };
};
var splitValues = (values, cb = (current) => current === ",", addSeparator = false) => {
  const result = [];
  let value = "";
  let depth = 0;
  for (let i = 0; i < values.length; i++) {
    const current = values[i];
    const prev2 = values[i - 1];
    const next2 = values[i + 1];
    if (current === "(") depth++;
    if (current === ")") depth--;
    if (cb(current, prev2, next2) && depth === 0) {
      if (value) result.push(value.trim());
      if (addSeparator) result.push(current);
      value = "";
    } else {
      value += current;
    }
  }
  if (value) result.push(value.trim());
  return result.filter(Boolean);
};
var isCSSVar = (value) => /^var\(--.+\)$/.test(value);
var analyzeCSSValue = (value) => {
  let n = parseFloat(value.toString());
  const unit = value.toString().replace(String(n), "");
  return { isUnitless: !unit, value, unit };
};
var tokenToCSSVar = (token2, value) => (theme) => {
  const match2 = isString(value) ? value.match(/fallback\(([^,)]+),?\s*([^]+)?\)/) : null;
  const [, resolvedValue, fallbackValue] = match2 != null ? match2 : [];
  if (resolvedValue) value = resolvedValue;
  const resolvedToken = `${token2}.${value}`;
  if (isObject(theme.__cssMap) && resolvedToken in theme.__cssMap) {
    return theme.__cssMap[resolvedToken].ref;
  } else {
    return fallbackValue != null ? fallbackValue : value;
  }
};
var mode = (light, dark) => (colorMode = "light") => colorMode === "light" ? light : dark;
var keyframes4 = (...arg) => keyframes(...arg);
var combineFunctions = (a, b) => (value, ...args) => b(a(value, ...args), ...args);
var pipe = (...transformers) => transformers.reduce(combineFunctions);
var styleSheet = createdDom() ? new StyleSheet({ key: "css", container: document.head }) : void 0;
var transformAnimationValue = (value) => Object.entries(value).reduce((prev2, [key, value2]) => {
  if (key === "duration") {
    prev2["animationDuration"] = value2;
  } else if (key === "timingFunction") {
    prev2["animationTimingFunction"] = value2;
  } else {
    prev2[key] = value2;
  }
  return prev2;
}, {});
var animation = (value, theme, css22) => {
  if (value == null || globalValues.has(value)) return value;
  if (isObject(value)) {
    const {
      keyframes: keyframes22,
      animationDuration = "0s",
      animationTimingFunction = "ease",
      delay: delay2 = "0s",
      iterationCount = "1",
      direction = "normal",
      fillMode = "none",
      playState = "running"
    } = css22(transformAnimationValue(value))(theme);
    const { name, styles: styles2 } = keyframes(keyframes22);
    styleSheet == null ? void 0 : styleSheet.insert(styles2);
    return `${name} ${animationDuration} ${animationTimingFunction} ${delay2} ${iterationCount} ${direction} ${fillMode} ${playState}`;
  } else if (value.includes(",")) {
    value = value.split(",").map((value2) => {
      value2 = value2.trim();
      value2 = tokenToCSSVar("animations", value2)(theme);
      return value2;
    }).join(",");
    return value;
  } else {
    value = tokenToCSSVar("animations", value)(theme);
    return value;
  }
};
var generateAtRule = (identifier2) => (values, theme) => values.reduce(
  (prev2, {
    type,
    name,
    query,
    css: css22,
    w,
    width,
    minW,
    minWidth,
    maxW,
    maxWidth,
    h,
    height,
    minH,
    minHeight,
    maxH,
    maxHeight,
    ...rest
  }) => {
    var _a;
    width != null ? width : width = w;
    minWidth != null ? minWidth : minWidth = minW;
    maxWidth != null ? maxWidth : maxWidth = maxW;
    height != null ? height : height = h;
    minHeight != null ? minHeight : minHeight = minH;
    maxHeight != null ? maxHeight : maxHeight = maxH;
    if (!query) {
      const resolvedRest = filterUndefined({
        width,
        minWidth,
        maxWidth,
        height,
        minHeight,
        maxHeight,
        ...rest
      });
      query = Object.entries(resolvedRest).map(([key, value]) => {
        value = tokenToCSSVar("sizes", value)(theme);
        return `(${toKebabCase(key)}: ${value})`;
      }).join(" and ");
    }
    const condition = `@${identifier2} ${(_a = type != null ? type : name) != null ? _a : ""} ${query}`;
    prev2[condition] = css22;
    return prev2;
  },
  {}
);
var OPERATORS = ["+", "-", "*", "/"];
var getValue = (value, fallbackValue = "") => (token2, theme, ...rest) => {
  if (!value) return fallbackValue;
  const prevent = isCSSFunction(value);
  if (prevent) {
    return generateCalc(token2)(value, theme, ...rest);
  } else {
    if (isNumeric(value)) return value;
    const resolvedToken = `${token2}.${value}`;
    return resolvedToken in theme.__cssMap ? theme.__cssMap[resolvedToken].ref : value;
  }
};
var isOperator = (value) => new RegExp(`\\s[${OPERATORS.join("\\")}]\\s`).test(value);
var generateCalc = (token2) => (value, theme, ...rest) => {
  if (value == null || globalValues.has(value)) return value;
  const prevent = isCSSFunction(value);
  if (!prevent) return value;
  let { type, values } = getCSSFunction(value);
  if (!type || !values) return value;
  switch (type) {
    case "calc": {
      const computedValues = splitValues(
        values,
        (char2, prev2, next2) => isOperator(`${prev2}${char2}${next2}`),
        true
      ).map((value2) => {
        if (OPERATORS.includes(value2)) return value2;
        return getValue(value2)(token2, theme, ...rest);
      });
      return `calc(${computedValues.join(" ")})`;
    }
    case "min":
    case "max": {
      let [firstValue, secondValue, ...otherValues] = splitValues(values);
      firstValue = getValue(firstValue, "100%")(token2, theme, ...rest);
      secondValue = getValue(secondValue, "100%")(token2, theme, ...rest);
      otherValues = otherValues.map(
        (value2) => getValue(value2)(token2, theme, ...rest)
      );
      return `${type}(${firstValue}, ${secondValue}` + (otherValues.length ? `, ${otherValues.join(", ")}` : "") + ")";
    }
    case "clamp": {
      let [min2, preferred, max2] = splitValues(values);
      if (!max2) {
        max2 = preferred;
        preferred = "";
      }
      min2 = getValue(min2)(token2, theme, ...rest);
      preferred = getValue(preferred, "100%")(token2, theme, ...rest);
      max2 = getValue(max2)(token2, theme, ...rest);
      return `clamp(${min2}, ${preferred}, ${max2})`;
    }
    case "minmax": {
      let [min2, max2] = splitValues(values);
      min2 = getValue(min2)(token2, theme, ...rest);
      max2 = getValue(max2)(token2, theme, ...rest);
      return `minmax(${min2}, ${max2})`;
    }
    case "fit-content": {
      let [value2] = splitValues(values);
      value2 = getValue(value2)(token2, theme, ...rest);
      return `fit-content(${value2})`;
    }
    default:
      return value;
  }
};
var DEFAULT_METHOD = "in srgb";
var methods = {
  srgb: "in srgb",
  "srgb-linear": "in srgb-linear",
  "display-p3": "in display-p3",
  "a98-rgb": "in a98-rgb",
  "prophoto-rgb": "in prophoto-rgb",
  rec2020: "in rec2020",
  lab: "in lab",
  oklab: "in oklab",
  xyz: "in xyz",
  "xyz-d50": "in xyz-d50",
  "xyz-d65": "in xyz-d65"
};
var getColor2 = (value, theme) => {
  if (!value) return "";
  let [color2, percent2, ...rest] = value.split(" ").filter(Boolean);
  if (rest.length) return value;
  const token2 = `colors.${color2}`;
  color2 = token2 in theme.__cssMap ? theme.__cssMap[token2].ref : color2;
  if (percent2 && !percent2.endsWith("%")) percent2 = `${percent2}%`;
  return !percent2 ? color2 : `${color2} ${percent2}`;
};
var colorMix = (value, theme) => {
  if (value == null || globalValues.has(value)) return value;
  const prevent = isCSSFunction(value);
  if (!prevent) return value;
  const { type, values } = getCSSFunction(value);
  if (!values) return value;
  switch (type) {
    case "mix":
    case "color-mix": {
      let [color2, color1, method] = splitValues(values).reverse();
      if (method) {
        method = method in methods ? methods[method] : method;
      } else {
        method = DEFAULT_METHOD;
      }
      color1 = getColor2(color1, theme);
      color2 = getColor2(color2, theme);
      return `color-mix(${method}` + (color1 ? `, ${color1}` : "") + (color2 ? `, ${color2}` : "") + ")";
    }
    case "tint":
    case "shade":
    case "transparentize": {
      const [color2, percent2] = splitValues(values);
      const color1 = getColor2(`${color2} ${percent2}`, theme);
      const color22 = type === "transparentize" ? "transparent" : type === "tint" ? "#fff" : "#000";
      return `color-mix(${DEFAULT_METHOD}, ${color1}, ${color22})`;
    }
    case "tone": {
      const [color2, tone] = splitValues(values);
      const color1 = getColor2(color2, theme);
      if (!tone) return color1;
      let ratio = parseInt(tone) || 500;
      if (ratio < 50 && 950 < ratio) ratio = 500;
      if (ratio === 500) return color1;
      const color22 = ratio < 500 ? "#fff" : "#000";
      const percent2 = `${100 - Math.abs(ratio - 500) * 2 / 10}%`;
      return `color-mix(${DEFAULT_METHOD}, ${color1} ${percent2}, ${color22})`;
    }
    default:
      return value;
  }
};
var generateFilter = (type = "filter") => (value) => {
  if (value !== "auto") return value;
  if (type === "filter") {
    return [
      "var(--ui-blur, /*!*/ /*!*/)",
      "var(--ui-brightness, /*!*/ /*!*/)",
      "var(--ui-contrast, /*!*/ /*!*/)",
      "var(--ui-drop-shadow, /*!*/ /*!*/)",
      "var(--ui-grayscale, /*!*/ /*!*/)",
      "var(--ui-hue-rotate, /*!*/ /*!*/)",
      "var(--ui-invert, /*!*/ /*!*/)",
      "var(--ui-opacity, /*!*/ /*!*/)",
      "var(--ui-saturate, /*!*/ /*!*/)",
      "var(--ui-sepia, /*!*/ /*!*/)"
    ].join(" ");
  } else {
    return [
      "var(--ui-backdrop-blur, /*!*/ /*!*/)",
      "var(--ui-backdrop-brightness, /*!*/ /*!*/)",
      "var(--ui-backdrop-contrast, /*!*/ /*!*/)",
      "var(--ui-backdrop-drop-shadow, /*!*/ /*!*/)",
      "var(--ui-backdrop-grayscale, /*!*/ /*!*/)",
      "var(--ui-backdrop-hue-rotate, /*!*/ /*!*/)",
      "var(--ui-backdrop-invert, /*!*/ /*!*/)",
      "var(--ui-backdrop-opacity, /*!*/ /*!*/)",
      "var(--ui-backdrop-saturate, /*!*/ /*!*/)",
      "var(--ui-backdrop-sepia, /*!*/ /*!*/)"
    ].join(" ");
  }
};
var directions = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var directionValues = new Set(Object.values(directions));
var gradient = (value, theme) => {
  if (value == null || globalValues.has(value)) return value;
  const prevent = isCSSFunction(value);
  if (!prevent) return `url('${value}')`;
  let { type, values } = getCSSFunction(value);
  if (!type || !values) return value;
  type = type.includes("-gradient") ? type : `${type}-gradient`;
  const [maybeDirection, ...colors2] = splitValues(values);
  if (!colors2.length) return value;
  const direction = maybeDirection in directions ? directions[maybeDirection] : maybeDirection;
  colors2.unshift(direction);
  const computedValues = colors2.map((_color) => {
    if (directionValues.has(_color)) return _color;
    const i = _color.indexOf(" ");
    let [color2, _ratio] = i !== -1 ? [_color.slice(0, i), _color.slice(i + 1)] : [_color];
    const ratio = isCSSFunction(_ratio) ? _ratio : _ratio && _ratio.split(" ");
    const token2 = `colors.${color2}`;
    color2 = token2 in theme.__cssMap ? theme.__cssMap[token2].ref : color2;
    if (ratio) {
      return [color2, ...isArray(ratio) ? ratio : [ratio]].join(" ");
    } else {
      return color2;
    }
  });
  return `${type}(${computedValues.join(", ")})`;
};
var repeats = {
  fill: "auto-fill",
  fit: "auto-fit"
};
var grid = (value, theme, ...rest) => {
  if (value == null || globalValues.has(value)) return value;
  const values = splitValues(value, (current) => current === " ");
  if (!values.length) return value;
  const computedValues = values.map((value2) => {
    const prevent = isCSSFunction(value2);
    if (!prevent) {
      const token2 = `sizes.${value2}`;
      return token2 in theme.__cssMap ? theme.__cssMap[token2].ref : value2;
    }
    const { type, values: values2 } = getCSSFunction(value2);
    if (!type || !values2) return value2;
    if (type === "repeat") {
      let [repeat, tracks] = splitValues(values2);
      repeat = repeat in repeats ? repeats[repeat] : repeat;
      tracks = grid(tracks, theme, ...rest);
      return `repeat(${repeat}, ${tracks})`;
    } else {
      return generateCalc("sizes")(value2, theme, ...rest);
    }
  });
  return computedValues.join(" ");
};
var transformValues = [
  "rotate(var(--ui-rotate, 0))",
  "scaleX(var(--ui-scale-x, 1))",
  "scaleY(var(--ui-scale-y, 1))",
  "skewX(var(--ui-skew-x, 0))",
  "skewY(var(--ui-skew-y, 0))"
];
var transform = (value) => {
  if (value === "auto")
    return [
      "translateX(var(--ui-translate-x, 0))",
      "translateY(var(--ui-translate-y, 0))",
      ...transformValues
    ].join(" ");
  if (value === "auto-3d")
    return [
      "translate3d(var(--ui-translate-x, 0), var(--ui-translate-y, 0), 0)",
      ...transformValues
    ].join(" ");
  return value;
};
var transforms = {
  var: (values, theme) => values.reduce((prev2, { __prefix, name, token: token2, value }) => {
    var _a, _b, _c;
    const prefix3 = (_c = __prefix != null ? __prefix : (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
    name = `--${prefix3}-${name}`;
    if (isObject(value)) {
      value = Object.entries(value).reduce((prev22, [key, value2]) => {
        prev22[key] = tokenToCSSVar(token2, value2)(theme);
        return prev22;
      }, {});
    } else if (isArray(value)) {
      value = value.map((value2) => tokenToCSSVar(token2, value2)(theme));
    } else {
      value = tokenToCSSVar(token2, value)(theme);
    }
    prev2[name] = value;
    return prev2;
  }, {}),
  token: (token2) => (value, theme) => tokenToCSSVar(token2, value)(theme),
  styles: (prefix3) => (value, theme, _css, prev2 = {}) => {
    const resolvedCSS = {};
    const style = getMemoizedObject(
      theme,
      prefix3 ? `styles.${prefix3}.${value}` : `styles.${value}`,
      {}
    );
    for (const prop in style) {
      const done = prop in prev2 && prev2[prop] != null;
      if (!done) resolvedCSS[prop] = style[prop];
    }
    return resolvedCSS;
  },
  px: (value) => {
    if (value == null) return value;
    const { isUnitless } = analyzeCSSValue(value);
    return isUnitless || isNumber(value) ? `${value}px` : value;
  },
  deg: (value) => {
    if (isCSSVar(value) || value == null) return value;
    const isUnitless = typeof value === "string" && !value.endsWith("deg");
    return isUnitless || isNumber(value) ? `${value}deg` : value;
  },
  fraction: (value) => {
    if (isNumber(value) && value <= 1) value = `${value * 100}%`;
    return value;
  },
  isTruncated: (value) => {
    if (value === true) {
      return {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      };
    }
  },
  bgClip: (value) => {
    if (value === "text") {
      return { color: "transparent", backgroundClip: "text" };
    } else {
      return { backgroundClip: value };
    }
  },
  function: (func2) => (value) => {
    return `${func2}(${value})`;
  },
  content: (value) => {
    if (isObject(value)) {
      return { content: "''", ...value };
    } else {
      return value;
    }
  },
  grid,
  colorMix,
  gradient,
  animation,
  transform,
  calc: generateCalc,
  filter: generateFilter,
  media: generateAtRule("media"),
  container: generateAtRule("container"),
  supports: generateAtRule("supports")
};
var forwardRef22 = (component) => {
  return React6.forwardRef(component);
};
var createQuery = (min2, max2, identifier2 = "@media screen") => {
  const query = [identifier2];
  if (min2) query.push("and", `(min-width: ${min2}px)`);
  if (max2) query.push("and", `(max-width: ${max2}px)`);
  return query.length > 1 ? query.join(" ").replace(/^@container(\s+\w*)?\s+and/, `@container$1`) : void 0;
};
var createQueries = (breakpoints2, options) => {
  const { direction, identifier: identifier2 } = options;
  const isDown = direction !== "up";
  return Object.entries(breakpoints2).map(([breakpoint, width], i, entry) => {
    var _a;
    const [, relatedWidth] = (_a = entry[i + 1]) != null ? _a : [];
    let minW = isDown ? relatedWidth : width;
    let maxW = isDown ? width : relatedWidth;
    if (breakpoint === "base") {
      if (isDown) {
        maxW = void 0;
      } else {
        minW = void 0;
      }
    }
    if (isDown) {
      if (minW) minW += 1;
    } else {
      if (maxW) maxW -= 1;
    }
    const maxWQuery = createQuery(void 0, maxW, identifier2);
    const minWQuery = createQuery(minW, void 0, identifier2);
    const minMaxQuery = createQuery(minW, maxW, identifier2);
    const query = isDown ? maxWQuery : minWQuery;
    return {
      breakpoint,
      minW,
      maxW,
      query,
      maxWQuery,
      minWQuery,
      minMaxQuery
    };
  });
};
var transformBreakpoints = (breakpoints2, options) => {
  return Object.fromEntries(
    Object.entries(breakpoints2).map(([name, value]) => [name, getPx(value)]).sort((a, b) => {
      if (options.direction !== "up") {
        return b[1] - a[1];
      } else {
        return a[1] - b[1];
      }
    })
  );
};
var analyzeBreakpoints = (breakpoints2, options = { direction: "down" }) => {
  if (!breakpoints2) return;
  breakpoints2.base = options.direction !== "up" ? "9999px" : "0px";
  breakpoints2 = transformBreakpoints(breakpoints2, options);
  const keys2 = keysFormObject(breakpoints2);
  const queries2 = createQueries(breakpoints2, options);
  const isResponsive = (obj) => {
    const providedKeys = Object.keys(obj);
    return providedKeys.length > 0 && providedKeys.every((key) => keys2.includes(key));
  };
  return {
    keys: keys2,
    isResponsive,
    queries: queries2
  };
};
var getMinMaxQuery = (queries2, direction, pickKey = []) => {
  const omitQueries = queries2.filter(
    ({ breakpoint }) => breakpoint !== "base" && pickKey.includes(breakpoint)
  );
  const minQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = a.minW) != null ? _a : 0) - ((_b = b.minW) != null ? _b : 0);
  })[0];
  const maxQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = b.maxW) != null ? _a : 0) - ((_b = a.maxW) != null ? _b : 0);
  })[0];
  if (direction !== "up") {
    return { minQuery, maxQuery };
  } else {
    return { minQuery, maxQuery };
  }
};
var standardStyles = {
  accentColor: {
    properties: "accentColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  all: true,
  animation: {
    properties: "animation",
    token: "animations",
    transform: pipe(transforms.token("animations"), transforms.animation)
  },
  animationComposition: true,
  animationDelay: true,
  animationDirection: true,
  animationDuration: {
    properties: "animationDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  animationFillMode: true,
  animationIterationCount: true,
  animationName: true,
  animationPlayState: true,
  animationRange: true,
  animationRangeEnd: true,
  animationRangeStart: true,
  animationTimeline: true,
  animationTimingFunction: {
    properties: "animationTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  appearance: true,
  aspectRatio: true,
  backfaceVisibility: {
    properties: "backfaceVisibility",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  background: {
    properties: "background",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  backgroundAttachment: true,
  backgroundBlendMode: true,
  backgroundClip: {
    properties: "backgroundClip",
    transform: transforms.bgClip
  },
  backgroundColor: {
    properties: "backgroundColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  backgroundImage: {
    properties: "backgroundImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  backgroundOrigin: true,
  backgroundPosition: true,
  backgroundPositionX: true,
  backgroundPositionY: true,
  backgroundRepeat: true,
  backgroundSize: true,
  blockSize: {
    properties: "blockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  border: {
    properties: "border",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlock: {
    properties: "borderBlock",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockColor: {
    properties: "borderBlockColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockEnd: {
    properties: "borderBlockEnd",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockEndColor: {
    properties: "borderBlockEndColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockEndStyle: true,
  borderBlockEndWidth: {
    properties: "borderBlockEndWidth",
    transform: transforms.px
  },
  borderBlockStart: {
    properties: "borderBlockStart",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockStartColor: {
    properties: "borderBlockStartColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockStartStyle: true,
  borderBlockStartWidth: {
    properties: "borderBlockStartWidth",
    transform: transforms.px
  },
  borderBlockStyle: true,
  borderBlockWidth: {
    properties: "borderBlockWidth",
    transform: transforms.px
  },
  borderBottom: {
    properties: "borderBottom",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBottomColor: {
    properties: "borderBottomColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBottomLeftRadius: {
    properties: "borderBottomLeftRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomRightRadius: {
    properties: "borderBottomRightRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomStyle: true,
  borderBottomWidth: {
    properties: "borderBottomWidth",
    transform: transforms.px
  },
  borderCollapse: true,
  borderColor: {
    properties: "borderColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderEndEndRadius: {
    properties: "borderEndEndRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderEndStartRadius: {
    properties: "borderEndStartRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderImage: {
    properties: "borderImage",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderImageOutset: true,
  borderImageRepeat: true,
  borderImageSlice: true,
  borderImageSource: {
    properties: "borderImageSource",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  borderImageWidth: {
    properties: "borderImageWidth",
    transform: transforms.px
  },
  borderInline: {
    properties: "borderInline",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineColor: {
    properties: "borderInlineColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineEnd: {
    properties: "borderInlineEnd",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineEndColor: {
    properties: "borderInlineEndColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineEndStyle: true,
  borderInlineEndWidth: {
    properties: "borderInlineEndWidth",
    transform: transforms.px
  },
  borderInlineStart: {
    properties: "borderInlineStart",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineStartColor: {
    properties: "borderInlineStartColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineStartStyle: true,
  borderInlineStartWidth: {
    properties: "borderInlineStartWidth",
    transform: transforms.px
  },
  borderInlineStyle: true,
  borderInlineWidth: {
    properties: "borderInlineWidth",
    transform: transforms.px
  },
  borderLeft: {
    properties: "borderLeft",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderLeftColor: {
    properties: "borderLeftColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderLeftStyle: true,
  borderLeftWidth: { properties: "borderLeftWidth", transform: transforms.px },
  borderRadius: {
    properties: "borderRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderRight: {
    properties: "borderRight",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderRightColor: {
    properties: "borderRightColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderRightStyle: true,
  borderRightWidth: {
    properties: "borderRightWidth",
    transform: transforms.px
  },
  borderSpacing: true,
  borderStartEndRadius: {
    properties: "borderStartEndRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderStartStartRadius: {
    properties: "borderStartStartRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderStyle: true,
  borderTop: {
    properties: "borderTop",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderTopColor: {
    properties: "borderTopColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderTopLeftRadius: {
    properties: "borderTopLeftRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderTopRightRadius: {
    properties: "borderTopRightRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderTopStyle: true,
  borderTopWidth: { properties: "borderTopWidth", transform: transforms.px },
  borderWidth: { properties: "borderWidth", transform: transforms.px },
  bottom: {
    properties: "bottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  boxAlign: true,
  boxDecorationBreak: true,
  boxDirection: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxLines: true,
  boxOrdinalGroup: true,
  boxOrient: true,
  boxPack: true,
  boxShadow: {
    properties: "boxShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  boxSizing: true,
  breakAfter: true,
  breakBefore: true,
  breakInside: true,
  captionSide: true,
  caretColor: {
    properties: "caretColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  clear: true,
  clip: true,
  clipPath: true,
  clipRule: true,
  color: {
    properties: "color",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  colorInterpolation: true,
  columnCount: true,
  columnFill: true,
  columnGap: {
    properties: "columnGap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  columnRule: { properties: "columnRule", transform: transforms.px },
  columnRuleColor: {
    properties: "columnRuleColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  columnRuleStyle: true,
  columnRuleWidth: { properties: "columnRuleWidth", transform: transforms.px },
  columnSpan: true,
  columnWidth: {
    properties: "columnWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  columns: true,
  contain: true,
  containIntrinsicBlockSize: true,
  containIntrinsicHeight: true,
  containIntrinsicInlineSize: true,
  containIntrinsicSize: true,
  containIntrinsicWidth: {
    properties: "containIntrinsicWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  container: true,
  containerName: true,
  containerType: true,
  content: true,
  contentVisibility: true,
  counterIncrement: true,
  counterReset: true,
  counterSet: true,
  cursor: true,
  direction: true,
  display: true,
  emptyCells: true,
  fill: {
    properties: "fill",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  fillOpacity: true,
  fillRule: true,
  flex: true,
  flexBasis: {
    properties: "flexBasis",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  flexDirection: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexWrap: true,
  float: true,
  font: true,
  fontFamily: {
    properties: "fontFamily",
    token: "fonts",
    transform: transforms.token("fonts")
  },
  fontFeatureSettings: true,
  fontKerning: true,
  fontLanguageOverride: true,
  fontOpticalSizing: true,
  fontPalette: true,
  fontSize: {
    properties: "fontSize",
    token: "fontSizes",
    transform: pipe(
      transforms.token("fontSizes"),
      transforms.px,
      transforms.calc("fontSizes")
    )
  },
  fontSizeAdjust: true,
  fontSmooth: true,
  fontStretch: true,
  fontStyle: true,
  fontSynthesis: true,
  fontSynthesisPosition: true,
  fontSynthesisSmallCaps: true,
  fontSynthesisStyle: true,
  fontSynthesisWeight: true,
  fontVariant: true,
  fontVariantAlternates: true,
  fontVariantCaps: true,
  fontVariantEastAsian: true,
  fontVariantEmoji: true,
  fontVariantLigatures: true,
  fontVariantNumeric: true,
  fontVariantPosition: true,
  fontVariationSettings: true,
  fontWeight: {
    properties: "fontWeight",
    token: "fontWeights",
    transform: transforms.token("fontWeights")
  },
  forcedColorAdjust: true,
  gap: {
    properties: "gap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  grid: true,
  gridArea: true,
  gridAutoColumns: {
    properties: "gridAutoColumns",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridAutoFlow: true,
  gridAutoRows: {
    properties: "gridAutoRows",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  gridTemplate: true,
  gridTemplateAreas: true,
  gridTemplateColumns: {
    properties: "gridTemplateColumns",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridTemplateRows: {
    properties: "gridTemplateRows",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  hangingPunctuation: true,
  height: {
    properties: "height",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  hyphenateCharacter: true,
  hyphenateLimitChars: true,
  hyphens: true,
  imageOrientation: true,
  imageRendering: true,
  imageResolution: true,
  initialLetter: true,
  inlineSize: {
    properties: "inlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  inset: {
    properties: "inset",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlock: {
    properties: "insetBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlockEnd: {
    properties: "insetBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlockStart: {
    properties: "insetBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInline: {
    properties: "insetInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInlineEnd: {
    properties: "insetInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInlineStart: {
    properties: "insetInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  isolation: true,
  justifyContent: true,
  justifyItems: true,
  justifySelf: true,
  left: {
    properties: "left",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  letterSpacing: {
    properties: "letterSpacing",
    token: "letterSpacings",
    transform: transforms.token("letterSpacings")
  },
  lineBreak: true,
  lineHeight: {
    properties: "lineHeight",
    token: "lineHeights",
    transform: transforms.token("lineHeights")
  },
  lineHeightStep: true,
  listStyle: true,
  listStyleImage: {
    properties: "listStyleImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  listStylePosition: true,
  listStyleType: true,
  margin: {
    properties: "margin",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlock: {
    properties: "marginBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlockEnd: {
    properties: "marginBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlockStart: {
    properties: "marginBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBottom: {
    properties: "marginBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInline: {
    properties: "marginInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInlineEnd: {
    properties: "marginInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInlineStart: {
    properties: "marginInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginLeft: {
    properties: "marginLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginRight: {
    properties: "marginRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginTop: {
    properties: "marginTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginTrim: true,
  marker: true,
  markerEnd: true,
  markerMid: true,
  markerStart: true,
  mask: true,
  maskBorder: true,
  maskBorderMode: true,
  maskBorderOutset: true,
  maskBorderRepeat: true,
  maskBorderSlice: true,
  maskBorderSource: true,
  maskBorderWidth: { properties: "maskBorderWidth", transform: transforms.px },
  maskClip: true,
  maskComposite: true,
  maskImage: {
    properties: "maskImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  maskMode: true,
  maskOrigin: true,
  maskPosition: true,
  maskRepeat: true,
  maskSize: true,
  maskType: true,
  masonryAutoFlow: true,
  mathDepth: true,
  mathShift: true,
  mathStyle: true,
  maxBlockSize: {
    properties: "maxBlockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxHeight: {
    properties: "maxHeight",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxInlineSize: {
    properties: "maxInlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxWidth: {
    properties: "maxWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minBlockSize: {
    properties: "minBlockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minHeight: {
    properties: "minHeight",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minInlineSize: {
    properties: "minInlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minWidth: {
    properties: "minWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  mixBlendMode: true,
  objectFit: true,
  objectPosition: true,
  offset: true,
  offsetAnchor: true,
  offsetDistance: true,
  offsetPath: true,
  offsetPosition: true,
  offsetRotate: true,
  opacity: true,
  order: true,
  orphans: true,
  outline: true,
  outlineColor: {
    properties: "outlineColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  outlineOffset: true,
  outlineStyle: true,
  outlineWidth: { properties: "outlineWidth", transform: transforms.px },
  overflow: true,
  overflowAnchor: true,
  overflowBlock: true,
  overflowClipMargin: true,
  overflowInline: true,
  overflowWrap: true,
  overflowX: true,
  overflowY: true,
  overlay: true,
  overscrollBehavior: true,
  overscrollBehaviorBlock: true,
  overscrollBehaviorInline: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  padding: {
    properties: "padding",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlock: {
    properties: "paddingBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlockEnd: {
    properties: "paddingBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlockStart: {
    properties: "paddingBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBottom: {
    properties: "paddingBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInline: {
    properties: "paddingInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInlineEnd: {
    properties: "paddingInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInlineStart: {
    properties: "paddingInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingLeft: {
    properties: "paddingLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingRight: {
    properties: "paddingRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingTop: {
    properties: "paddingTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  page: true,
  pageBreakAfter: true,
  pageBreakBefore: true,
  pageBreakInside: true,
  paintOrder: true,
  perspective: true,
  perspectiveOrigin: true,
  placeContent: true,
  placeItems: true,
  placeSelf: true,
  pointerEvents: true,
  position: true,
  printColorAdjust: true,
  quotes: true,
  resize: true,
  right: {
    properties: "right",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  rowGap: {
    properties: "rowGap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  rubyAlign: true,
  rubyPosition: true,
  scrollBehavior: true,
  scrollMargin: {
    properties: "scrollMargin",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginBlock: true,
  scrollMarginBlockEnd: true,
  scrollMarginBlockStart: true,
  scrollMarginBottom: {
    properties: "scrollMarginBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginInline: true,
  scrollMarginInlineEnd: true,
  scrollMarginInlineStart: true,
  scrollMarginLeft: {
    properties: "scrollMarginLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginRight: {
    properties: "scrollMarginRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginTop: {
    properties: "scrollMarginTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPadding: {
    properties: "scrollPadding",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingBlock: true,
  scrollPaddingBlockEnd: true,
  scrollPaddingBlockStart: true,
  scrollPaddingBottom: {
    properties: "scrollPaddingBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingInline: true,
  scrollPaddingInlineEnd: true,
  scrollPaddingInlineStart: true,
  scrollPaddingLeft: {
    properties: "scrollPaddingLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingRight: {
    properties: "scrollPaddingRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingTop: {
    properties: "scrollPaddingTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollTimeline: true,
  scrollTimelineAxis: true,
  scrollTimelineName: true,
  scrollbarColor: {
    properties: "scrollbarColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  scrollbarGutter: true,
  scrollbarWidth: { properties: "scrollbarWidth", transform: transforms.px },
  shapeImageThreshold: true,
  shapeMargin: true,
  shapeOutside: true,
  shapeRendering: true,
  stopColor: true,
  stopOpacity: true,
  stroke: {
    properties: "stroke",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  tabSize: true,
  tableLayout: true,
  textAlign: true,
  textAlignLast: true,
  textAnchor: true,
  textCombineUpright: true,
  textDecoration: true,
  textDecorationColor: {
    properties: "textDecorationColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  textDecorationLine: true,
  textDecorationSkip: true,
  textDecorationSkipInk: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textEmphasis: true,
  textEmphasisColor: {
    properties: "textEmphasisColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  textEmphasisPosition: true,
  textEmphasisStyle: true,
  textIndent: true,
  textJustify: true,
  textOrientation: true,
  textOverflow: true,
  textRendering: true,
  textShadow: {
    properties: "textShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  textSizeAdjust: true,
  textTransform: true,
  textUnderlineOffset: true,
  textUnderlinePosition: true,
  textWrap: true,
  timelineScope: true,
  top: {
    properties: "top",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  touchAction: true,
  transform: { properties: "transform", transform: transforms.transform },
  transformBox: true,
  transformOrigin: true,
  transformStyle: true,
  transitionBehavior: true,
  transitionDelay: true,
  transitionDuration: {
    properties: "transitionDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  transitionProperty: {
    properties: "transitionProperty",
    token: "transitions.property",
    transform: transforms.token("transitions.property")
  },
  transitionTimingFunction: {
    properties: "transitionTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  translate: true,
  unicodeBidi: true,
  userSelect: true,
  vectorEffect: true,
  verticalAlign: true,
  viewTimeline: true,
  viewTimelineAxis: true,
  viewTimelineInset: true,
  viewTimelineName: true,
  viewTransitionName: true,
  visibility: true,
  whiteSpace: true,
  whiteSpaceCollapse: true,
  widows: true,
  width: {
    properties: "width",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  willChange: true,
  wordBreak: true,
  wordSpacing: true,
  writingMode: true,
  zIndex: {
    properties: "zIndex",
    token: "zIndices",
    transform: transforms.token("zIndices")
  },
  zoom: true,
  alignmentBaseline: true,
  azimuth: true,
  baselineShift: true,
  dominantBaseline: true,
  floodColor: {
    properties: "floodColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  floodOpacity: true,
  glyphOrientationVertical: true,
  lightingColor: {
    properties: "lightingColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeLinecap: true,
  strokeLinejoin: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: { properties: "strokeWidth", transform: transforms.px },
  marginX: {
    properties: ["marginInlineStart", "marginInlineEnd"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginY: {
    properties: ["marginTop", "marginBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingX: {
    properties: ["paddingInlineStart", "paddingInlineEnd"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingY: {
    properties: ["paddingTop", "paddingBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginX: {
    properties: ["scrollMarginLeft", "scrollMarginRight"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginY: {
    properties: ["scrollMarginTop", "scrollMarginBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingX: {
    properties: ["scrollPaddingLeft", "scrollPaddingRight"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingY: {
    properties: ["scrollPaddingTop", "scrollPaddingBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetX: {
    properties: ["left", "right"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetY: {
    properties: ["top", "bottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  borderY: {
    properties: ["borderTop", "borderBottom"],
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderX: {
    properties: ["borderLeft", "borderRight"],
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderTopRadius: {
    properties: ["borderTopLeftRadius", "borderTopRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomRadius: {
    properties: ["borderBottomLeftRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderRightRadius: {
    properties: ["borderTopRightRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderLeftRadius: {
    properties: ["borderTopLeftRadius", "borderBottomLeftRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderInlineStartRadius: {
    properties: ["borderStartStartRadius", "borderStartEndRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderInlineEndRadius: {
    properties: ["borderEndStartRadius", "borderEndEndRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  boxSize: {
    properties: ["width", "height"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minBoxSize: {
    properties: ["minWidth", "minHeight"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxBoxSize: {
    properties: ["maxWidth", "maxHeight"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  translateX: {
    properties: "--ui-translate-x",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  translateY: {
    properties: "--ui-translate-y",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scale: { properties: ["--ui-scale-x", "--ui-scale-y"] },
  scaleX: { properties: "--ui-scale-x" },
  scaleY: { properties: "--ui-scale-y" },
  rotate: { properties: "--ui-rotate", transform: transforms.deg },
  skewX: { properties: "--ui-skew-x", transform: transforms.deg },
  skewY: { properties: "--ui-skew-y", transform: transforms.deg },
  filter: { transform: transforms.filter() },
  blur: {
    properties: "--ui-blur",
    token: "blurs",
    transform: pipe(transforms.token("blurs"), transforms.function("blur"))
  },
  brightness: {
    properties: "--ui-brightness",
    transform: transforms.function("brightness")
  },
  contrast: {
    properties: "--ui-contrast",
    transform: transforms.function("contrast")
  },
  dropShadow: {
    properties: "--ui-drop-shadow",
    token: "shadows",
    transform: pipe(
      transforms.token("shadows"),
      transforms.function("drop-shadow")
    )
  },
  grayscale: {
    properties: "--ui-grayscale",
    transform: transforms.function("grayscale")
  },
  hueRotate: {
    properties: "--ui-hue-rotate",
    transform: pipe(transforms.deg, transforms.function("hue-rotate"))
  },
  invert: {
    properties: "--ui-invert",
    transform: transforms.function("invert")
  },
  saturate: {
    properties: "--ui-saturate",
    transform: transforms.function("saturate")
  },
  sepia: { properties: "--ui-sepia", transform: transforms.function("sepia") },
  backdropFilter: { transform: transforms.filter("backdrop") },
  backdropBlur: {
    properties: "--ui-backdrop-blur",
    token: "blurs",
    transform: pipe(transforms.token("blurs"), transforms.function("blur"))
  },
  backdropBrightness: {
    properties: "--ui-backdrop-brightness",
    transform: transforms.function("brightness")
  },
  backdropContrast: {
    properties: "--ui-backdrop-contrast",
    transform: transforms.function("contrast")
  },
  backdropDropShadow: {
    properties: "--ui-backdrop-drop-shadow",
    token: "shadows",
    transform: pipe(
      transforms.token("shadows"),
      transforms.function("drop-shadow")
    )
  },
  backdropGrayscale: {
    properties: "--ui-backdrop-grayscale",
    transform: transforms.function("grayscale")
  },
  backdropHueRotate: {
    properties: "--ui-backdrop-hue-rotate",
    transform: pipe(transforms.deg, transforms.function("hue-rotate"))
  },
  backdropInvert: {
    properties: "--ui-backdrop-invert",
    transform: transforms.function("invert")
  },
  backdropSaturate: {
    properties: "--ui-backdrop-saturate",
    transform: transforms.function("saturate")
  },
  backdropSepia: {
    properties: "--ui-backdrop-sepia",
    transform: transforms.function("sepia")
  },
  colorMode: { properties: "colorScheme" }
};
var shorthandStyles = {
  accent: standardStyles.accentColor,
  bg: standardStyles.background,
  bgAttachment: { properties: "backgroundAttachment" },
  bgBlendMode: { properties: "backgroundBlendMode" },
  bgClip: standardStyles.backgroundClip,
  bgColor: standardStyles.backgroundColor,
  bgImage: standardStyles.backgroundImage,
  bgImg: standardStyles.backgroundImage,
  bgGradient: standardStyles.backgroundImage,
  bgOrigin: { properties: "backgroundOrigin" },
  bgPosition: { properties: "backgroundPosition" },
  bgPositionX: { properties: "backgroundPositionX" },
  bgPosX: { properties: "backgroundPositionX" },
  bgPositionY: { properties: "backgroundPositionY" },
  bgPosY: { properties: "backgroundPositionY" },
  bgRepeat: { properties: "backgroundRepeat" },
  bgSize: { properties: "backgroundSize" },
  roundedBottomLeft: standardStyles.borderBottomLeftRadius,
  roundedBottomRight: standardStyles.borderBottomRightRadius,
  borderBottomEndRadius: standardStyles.borderEndEndRadius,
  roundedBottomEnd: standardStyles.borderEndEndRadius,
  borderBottomStartRadius: standardStyles.borderEndStartRadius,
  roundedBottomStart: standardStyles.borderEndStartRadius,
  borderEnd: standardStyles.borderInlineEnd,
  borderEndColor: standardStyles.borderInlineEndColor,
  borderEndStyle: { properties: "borderInlineEndStyle" },
  borderEndWidth: standardStyles.borderInlineEndWidth,
  borderStart: standardStyles.borderInlineStart,
  borderStartColor: standardStyles.borderInlineStartColor,
  borderStartStyle: { properties: "borderInlineStartStyle" },
  borderStartWidth: standardStyles.borderInlineStartWidth,
  rounded: standardStyles.borderRadius,
  borderTopEndRadius: standardStyles.borderStartEndRadius,
  roundedTopEnd: standardStyles.borderStartEndRadius,
  borderTopStartRadius: standardStyles.borderStartStartRadius,
  roundedTopStart: standardStyles.borderStartStartRadius,
  roundedTopLeft: standardStyles.borderTopLeftRadius,
  roundedTopRight: standardStyles.borderTopRightRadius,
  shadow: standardStyles.boxShadow,
  caret: standardStyles.caretColor,
  textColor: standardStyles.color,
  gx: standardStyles.columnGap,
  gapX: standardStyles.columnGap,
  flexDir: { properties: "flexDirection" },
  text: standardStyles.fontSize,
  g: standardStyles.gap,
  h: standardStyles.height,
  insetEnd: standardStyles.insetInlineEnd,
  insetStart: standardStyles.insetInlineStart,
  tracking: standardStyles.letterSpacing,
  leading: standardStyles.lineHeight,
  listStyleImg: standardStyles.listStyleImage,
  listStylePos: { properties: "listStylePosition" },
  m: standardStyles.margin,
  mb: standardStyles.marginBottom,
  me: standardStyles.marginInlineEnd,
  marginEnd: standardStyles.marginInlineEnd,
  ms: standardStyles.marginInlineStart,
  marginStart: standardStyles.marginInlineStart,
  ml: standardStyles.marginLeft,
  mr: standardStyles.marginRight,
  mt: standardStyles.marginTop,
  maxH: standardStyles.maxHeight,
  maxW: standardStyles.maxWidth,
  minH: standardStyles.minHeight,
  minW: standardStyles.minWidth,
  blendMode: { properties: "mixBlendMode" },
  overscroll: { properties: "overscrollBehavior" },
  overscrollX: { properties: "overscrollBehaviorX" },
  overscrollY: { properties: "overscrollBehaviorY" },
  p: standardStyles.padding,
  pb: standardStyles.paddingBottom,
  pe: standardStyles.paddingInlineEnd,
  paddingEnd: standardStyles.paddingInlineEnd,
  ps: standardStyles.paddingInlineStart,
  paddingStart: standardStyles.paddingInlineStart,
  pl: standardStyles.paddingLeft,
  pr: standardStyles.paddingRight,
  pt: standardStyles.paddingTop,
  pos: { properties: "position" },
  gy: standardStyles.rowGap,
  gapY: standardStyles.rowGap,
  textDecor: { properties: "textDecoration" },
  w: standardStyles.width,
  z: standardStyles.zIndex,
  mx: standardStyles.marginX,
  my: standardStyles.marginY,
  px: standardStyles.paddingX,
  py: standardStyles.paddingY,
  roundedTop: standardStyles.borderTopRadius,
  roundedBottom: standardStyles.borderBottomRadius,
  roundedRight: standardStyles.borderRightRadius,
  roundedLeft: standardStyles.borderLeftRadius,
  borderStartRadius: standardStyles.borderInlineStartRadius,
  roundedStart: standardStyles.borderInlineStartRadius,
  borderEndRadius: standardStyles.borderInlineEndRadius,
  roundedEnd: standardStyles.borderInlineEndRadius
};
var pseudoStyles = {
  "&::before": { properties: "&::before", transform: transforms.content },
  "&::after": { properties: "&::after", transform: transforms.content }
};
var uiStyles = {
  lineClamp: {
    properties: "--ui-line-clamp",
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--ui-line-clamp)"
    }
  },
  isTruncated: { transform: transforms.isTruncated },
  layerStyle: {
    isProcessResult: true,
    transform: transforms.styles("layerStyles")
  },
  textStyle: {
    isProcessResult: true,
    transform: transforms.styles("textStyles")
  },
  apply: { isProcessResult: true, transform: transforms.styles() },
  var: { isProcessSkip: true, transform: transforms.var }
};
var atRuleStyles = {
  _media: { isProcessSkip: true, transform: transforms.media },
  _container: { isProcessSkip: true, transform: transforms.container },
  _supports: { isProcessSkip: true, transform: transforms.supports }
};
var styles = {
  ...standardStyles,
  ...shorthandStyles,
  ...pseudoStyles,
  ...uiStyles,
  ...atRuleStyles
};
var processSkipProperties = [
  "var",
  "_media",
  "_container",
  "_supports"
];
var styleProperties = Object.keys(styles);
var layoutStyleProperties = [
  "width",
  "inlineSize",
  "height",
  "backfaceVisibility",
  "blockSize",
  "boxSize",
  "minWidth",
  "minInlineSize",
  "minHeight",
  "minBlockSize",
  "maxWidth",
  "maxInlineSize",
  "maxHeight",
  "maxBlockSize",
  "overflow",
  "overflowX",
  "overflowY",
  "overscrollBehavior",
  "overscroll",
  "overscrollX",
  "textDecor",
  "overscrollBehaviorY",
  "overscrollY",
  "display",
  "aspectRatio",
  "verticalAlign",
  "boxSizing",
  "boxDecorationBreak",
  "float",
  "objectFit",
  "objectPosition",
  "visibility",
  "isolation",
  "w",
  "h",
  "minW",
  "maxW",
  "minH",
  "maxH",
  "position",
  "pos",
  "zIndex",
  "inset",
  "insetX",
  "insetInline",
  "insetY",
  "insetBlock",
  "top",
  "insetBlockStart",
  "bottom",
  "insetBlockEnd",
  "left",
  "insetInlineStart",
  "right",
  "insetInlineEnd",
  "insetStart",
  "insetEnd",
  "margin",
  "marginTop",
  "marginBlockStart",
  "marginRight",
  "marginInlineEnd",
  "marginBottom",
  "marginBlockEnd",
  "marginLeft",
  "marginInlineStart",
  "marginX",
  "marginInline",
  "marginY",
  "marginBlock",
  "padding",
  "paddingTop",
  "paddingBlockStart",
  "paddingRight",
  "paddingBottom",
  "paddingBlockEnd",
  "paddingLeft",
  "paddingInlineStart",
  "paddingInlineEnd",
  "paddingX",
  "paddingInline",
  "paddingY",
  "paddingBlock",
  "m",
  "mt",
  "mr",
  "me",
  "marginEnd",
  "mb",
  "ml",
  "ms",
  "marginStart",
  "mx",
  "my",
  "p",
  "pt",
  "py",
  "px",
  "pb",
  "pl",
  "ps",
  "paddingStart",
  "pr",
  "pe",
  "paddingEnd",
  "alignItems",
  "alignContent",
  "justifyItems",
  "justifyContent",
  "flexWrap",
  "flexDirection",
  "flexDir",
  "flex",
  "flexFlow",
  "flexGrow",
  "flexShrink",
  "flexBasis",
  "justifySelf",
  "alignSelf",
  "order",
  "placeItems",
  "placeContent",
  "placeSelf",
  "gap",
  "rowGap",
  "columnGap",
  "grid",
  "gridColumn",
  "gridRow",
  "gridAutoFlow",
  "gridAutoColumns",
  "gridColumnStart",
  "gridColumnEnd",
  "gridRowStart",
  "gridRowEnd",
  "gridAutoRows",
  "gridTemplate",
  "gridTemplateColumns",
  "gridTemplateRows",
  "gridTemplateAreas",
  "gridArea"
];
var isProcessSkip = (key) => processSkipProperties.includes(key);
var expandColorMode = (key, value) => ({
  [key]: value[0],
  [pseudos._dark]: {
    [key]: value[1]
  }
});
var expandResponsive = (key, value, queries2) => queries2.reduce((prev2, { breakpoint, query }) => {
  const breakpointValue = value[breakpoint];
  if (query) {
    if (breakpointValue) prev2[query] = { [key]: breakpointValue };
  } else {
    prev2[key] = value[breakpoint];
  }
  return prev2;
}, {});
var expandCSS = (css22, isNested) => (theme) => {
  if (!theme.__breakpoints) return css22;
  const { isResponsive, queries: queries2 } = theme.__breakpoints;
  let computedCSS = {};
  for (let [key, value] of Object.entries(css22)) {
    value = runIfFunc(value, theme);
    if (value == null) continue;
    if (isArray(value) && !(isProcessSkip(key) && !isNested)) {
      computedCSS = merge(computedCSS, expandColorMode(key, value));
      continue;
    }
    if (isObject(value) && isResponsive(value) && !(isProcessSkip(key) && !isNested)) {
      computedCSS = merge(computedCSS, expandResponsive(key, value, queries2));
      continue;
    }
    computedCSS[key] = value;
  }
  return computedCSS;
};
var parseVar = (value, theme) => {
  var _a, _b, _c;
  if (isArray(value) || isObject(value)) {
    return value;
  } else if (isString(value)) {
    const prefix3 = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
    return value.replace(/\$([^,)/\s]+)/g, (_, value2) => {
      if (isObject(theme.__cssMap) && value2 in theme.__cssMap) {
        return theme.__cssMap[value2].ref;
      } else {
        return `var(--${prefix3}-${value2})`;
      }
    });
  } else {
    return value;
  }
};
var getCSS = ({
  theme,
  styles: styles2 = {},
  pseudos: pseudos2 = {},
  disableStyleProp
}) => {
  const createCSS = (cssOrFunc, isNested = false) => {
    var _a, _b, _c, _d, _e;
    const cssObject = runIfFunc(cssOrFunc, theme);
    const computedCSS = expandCSS(cssObject, isNested)(theme);
    let resolvedCSS = {};
    for (let [prop, value] of Object.entries(computedCSS)) {
      if (disableStyleProp == null ? void 0 : disableStyleProp(prop)) continue;
      value = runIfFunc(value, theme);
      value = parseVar(value, theme);
      if (value == null) continue;
      if (prop in pseudos2) prop = pseudos2[prop];
      let style = styles2[prop];
      if (style === true) style = { properties: prop };
      if (isObject(value) && !(style == null ? void 0 : style.isProcessSkip)) {
        value = (_b = (_a = style == null ? void 0 : style.transform) == null ? void 0 : _a.call(style, value, theme, css3, resolvedCSS)) != null ? _b : value;
        resolvedCSS[prop] = (_c = resolvedCSS[prop]) != null ? _c : {};
        resolvedCSS[prop] = merge(resolvedCSS[prop], createCSS(value, true));
        continue;
      }
      value = (_e = (_d = style == null ? void 0 : style.transform) == null ? void 0 : _d.call(style, value, theme, css3, resolvedCSS)) != null ? _e : value;
      if ((style == null ? void 0 : style.isProcessResult) || (style == null ? void 0 : style.isProcessSkip))
        value = createCSS(value, true);
      if (!isNested && (style == null ? void 0 : style.static)) {
        const staticStyles = runIfFunc(style.static, theme);
        resolvedCSS = merge(resolvedCSS, staticStyles);
      }
      const properties = runIfFunc(style == null ? void 0 : style.properties, theme);
      if (properties) {
        if (isArray(properties)) {
          for (const property of properties) {
            resolvedCSS[property] = value;
          }
          continue;
        } else if (isObject(value)) {
          resolvedCSS = merge(resolvedCSS, value);
          continue;
        } else {
          resolvedCSS[properties] = value;
          continue;
        }
      }
      if (isObject(value)) {
        resolvedCSS = merge(resolvedCSS, value);
        continue;
      }
      resolvedCSS[prop] = value;
    }
    return resolvedCSS;
  };
  return createCSS;
};
var css3 = (cssOrFunc) => (theme, disableStyleProp) => getCSS({
  theme,
  styles,
  pseudos,
  disableStyleProp
})(cssOrFunc);
var getVar = (token2) => (theme) => {
  var _a, _b, _c;
  const prefix3 = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
  return `var(--${prefix3}-${token2})`;
};
var createVar = (token2, prefix3) => {
  const variable = `--${[prefix3, escape(token2, "-")].filter(Boolean).join("-")}`;
  const reference2 = `var(${variable})`;
  return { variable, reference: reference2 };
};
var tokenToVar = (token2, prefix3) => {
  token2 = token2.replace(/\./g, "-");
  return createVar(token2, prefix3);
};
var createVars = (tokens2, prefix3 = DEFAULT_VAR_PREFIX) => ({
  baseTokens,
  cssMap = {},
  cssVars = {}
} = {}) => {
  for (let [token2, { isSemantic, value }] of Object.entries(tokens2)) {
    const fetchParent = (value2 = "") => {
      var _a;
      const [parent] = token2.split(".");
      const relatedToken = [parent, value2].join(".");
      const tokenValue = (_a = tokens2[relatedToken]) != null ? _a : baseTokens == null ? void 0 : baseTokens[relatedToken];
      if (!tokenValue) return [, value2];
      const { variable: variable2, reference: reference22 } = tokenToVar(relatedToken, prefix3);
      return [variable2, reference22];
    };
    const { variable, reference: reference2 } = tokenToVar(token2, prefix3);
    let resolvedLightValue;
    let resolvedDarkValue;
    const theme = { __cssMap: cssMap };
    if (token2.startsWith("animations.")) {
      if (isArray(value)) {
        resolvedLightValue = value.map((value2) => animation(value2, theme, css3)).join(",");
      } else {
        resolvedLightValue = animation(value, theme, css3);
      }
    } else {
      let [lightValue, darkValue] = isArray(value) ? [...value] : [value];
      if (token2.startsWith("gradients.")) {
        const [lightParentVar, lightParentRef] = fetchParent(lightValue);
        const [darkParentVar, darkParentRef] = fetchParent(darkValue);
        if (lightParentVar) {
          resolvedLightValue = lightParentRef;
        } else {
          resolvedLightValue = gradient(
            fetchParent(lightValue)[1],
            theme,
            css3
          );
        }
        if (darkParentVar) {
          resolvedDarkValue = darkParentRef;
        } else {
          resolvedDarkValue = gradient(darkValue, theme, css3);
        }
      } else {
        resolvedLightValue = lightValue;
        resolvedDarkValue = darkValue;
      }
    }
    if (!isSemantic) {
      if (token2.startsWith("spaces") && !isUndefined(resolvedLightValue)) {
        const keys2 = token2.split(".");
        const [firstKey, ...restKeys] = keys2;
        const negativeToken = `${firstKey}.-${restKeys.join(".")}`;
        const negativeValue = calc.negate(resolvedLightValue);
        const negativeReference = calc.negate(reference2);
        cssMap[negativeToken] = {
          value: negativeValue,
          var: variable,
          ref: negativeReference
        };
      }
      cssVars[variable] = resolvedLightValue;
      if (resolvedDarkValue)
        cssVars = merge(cssVars, {
          [pseudos._dark]: { [variable]: resolvedDarkValue }
        });
      cssMap[token2] = {
        value: resolvedLightValue,
        var: variable,
        ref: reference2
      };
      continue;
    }
    const [parentVar, parentRef] = fetchParent(resolvedLightValue);
    cssVars = merge(cssVars, { [variable]: parentRef });
    if (resolvedDarkValue) {
      const [, parentRef2] = fetchParent(resolvedDarkValue);
      cssVars = merge(cssVars, { [pseudos._dark]: { [variable]: parentRef2 } });
    }
    cssMap[token2] = {
      value: parentVar != null ? parentVar : resolvedLightValue,
      var: variable,
      ref: reference2
    };
  }
  return { cssMap, cssVars };
};
var useCSS = (cssObject = {}) => {
  const theme = (0, import_react9.useContext)(ThemeContext);
  return (0, import_react9.useMemo)(() => getCSS2(cssObject)(theme), [cssObject, theme]);
};
var getCSS2 = (cssObject = {}) => (theme) => css2(css3(cssObject)(theme));
var primaryTokens = [
  "blurs",
  "borders",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "spaces",
  "zIndices"
];
var secondaryTokens = ["gradients"];
var transformTheme = (theme, config2) => {
  var _a;
  theme = omitTheme(theme);
  const { breakpoints: breakpoints2, themeSchemes } = theme != null ? theme : {};
  const prefix3 = (_a = config2 == null ? void 0 : config2.var) == null ? void 0 : _a.prefix;
  const primaryTokens2 = createTokens(theme);
  const secondaryTokens2 = createTokens(theme, "secondary");
  const animationTokens = createTokens(theme, "animation");
  let { cssMap, cssVars } = mergeVars(
    createVars(primaryTokens2, prefix3),
    createVars(secondaryTokens2, prefix3),
    createVars(animationTokens, prefix3)
  )();
  if (themeSchemes) {
    for (const [themeScheme, nestedTheme] of Object.entries(
      themeSchemes
    )) {
      const nestedPrimaryTokens = createTokens(nestedTheme);
      const nestedSecondaryTokens = createTokens(nestedTheme, "secondary");
      const nestedAnimationTokens = createTokens(nestedTheme, "animation");
      let { cssVars: nestedCSSVars } = mergeVars(
        createVars(nestedPrimaryTokens, prefix3),
        createVars(nestedSecondaryTokens, prefix3),
        createVars(nestedAnimationTokens, prefix3)
      )({ ...primaryTokens2, ...secondaryTokens2, ...animationTokens });
      cssVars = {
        ...cssVars,
        [`[data-theme=${themeScheme}] &:not([data-theme]), &[data-theme=${themeScheme}]`]: nestedCSSVars
      };
    }
  }
  const defaultCSSVars = {};
  Object.assign(theme, {
    __config: config2,
    __cssVars: { ...defaultCSSVars, ...cssVars },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(breakpoints2, config2 == null ? void 0 : config2.breakpoint)
  });
  return theme;
};
var createTokens = (theme, target = "primary") => {
  var _a;
  let defaultTokens = [];
  let semanticTokens = [];
  let omitKeys = [];
  switch (target) {
    case "primary":
      defaultTokens = [...primaryTokens, "transitions"];
      semanticTokens = [...primaryTokens, "transitions", "colorSchemes"];
      break;
    case "secondary":
      defaultTokens = [...secondaryTokens];
      semanticTokens = [...secondaryTokens];
      break;
    case "animation":
      defaultTokens = ["animations"];
      semanticTokens = ["animations"];
      omitKeys = ["keyframes"];
      break;
    default:
      break;
  }
  const defaultTokenMap = pickObject(theme, defaultTokens);
  const semanticTokenMap = pickObject((_a = theme.semantics) != null ? _a : {}, semanticTokens);
  const defaultTokenEntries = Object.entries(
    flattenObject(defaultTokenMap, Infinity, omitKeys)
  ).map(([token2, value]) => {
    const enhancedToken = { isSemantic: false, value };
    return [token2, enhancedToken];
  });
  const semanticTokenEntries = Object.entries(
    flattenObject(semanticTokenMap, Infinity, omitKeys)
  ).reduce(
    (prev2, [token2, value]) => {
      if (token2.startsWith("colorSchemes.")) {
        const [, semanticToken, tone] = token2.split(".");
        if (tone) {
          const enhancedToken = { isSemantic: false, value };
          prev2.push([`colors.${semanticToken}.${tone}`, enhancedToken]);
        } else {
          TONES.forEach((tone2) => {
            const enhancedToken = {
              isSemantic: true,
              value: isArray(value) ? [`${value[0]}.${tone2}`, `${value[1]}.${tone2}`] : `${value}.${tone2}`
            };
            prev2.push([`colors.${semanticToken}.${tone2}`, enhancedToken]);
          });
        }
      } else {
        const enhancedToken = { isSemantic: true, value };
        prev2.push([token2, enhancedToken]);
      }
      return prev2;
    },
    []
  );
  return objectFromEntries([
    ...defaultTokenEntries,
    ...semanticTokenEntries
  ]);
};
var mergeVars = (...funcs) => (baseTokens) => {
  let resolvedCSSMap = {};
  let resolvedCSSVars = {};
  for (const func2 of funcs) {
    const { cssMap, cssVars } = func2({
      baseTokens,
      cssMap: resolvedCSSMap,
      cssVars: resolvedCSSVars
    });
    resolvedCSSMap = { ...resolvedCSSMap, ...cssMap };
    resolvedCSSVars = { ...resolvedCSSVars, ...cssVars };
  }
  return { cssMap: resolvedCSSMap, cssVars: resolvedCSSVars };
};
var omitTheme = (theme) => omitObject(theme, ["__cssMap", "__cssVar", "__breakpoints"]);
var omitThemeProps = (props2, keys2 = []) => omitObject(props2, ["size", "variant", "colorScheme", ...keys2]);
var mergeStyle = (target, ...sources) => ({ omit = [], pick = [] } = {}) => sources.reduce(
  (prev2, source) => recursiveMergeStyle(filterStyle(prev2)({ omit, pick }), source),
  target
);
var mergeMultiStyle = (target, ...sources) => ({ omit = [], pick = [] } = {}) => sources.reduce(
  (prev2, source) => recursiveMergeStyle(
    filterStyle(prev2)({ omit, pick, isMulti: true }),
    source
  ),
  target
);
var recursiveMergeStyle = (target, source) => {
  let result = Object.assign({}, target);
  if (isObject(source) && isObject(target)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (target.hasOwnProperty(sourceKey)) {
        if (!isFunction(targetValue) && !isFunction(sourceValue)) {
          result[sourceKey] = recursiveMergeStyle(
            targetValue,
            sourceValue
          );
        } else {
          result[sourceKey] = (props2) => recursiveMergeStyle(
            runIfFunc(targetValue, props2),
            runIfFunc(sourceValue, props2)
          );
        }
      } else {
        Object.assign(result, { [sourceKey]: sourceValue });
      }
    }
  } else {
    result = source;
  }
  return result;
};
var filterStyle = (target) => ({ omit, pick, isMulti = false }) => {
  if (!isObject(target)) return target;
  if (omit.length)
    target = internalFilterStyle(target, omit, isMulti)(omitObject);
  if (pick.length)
    target = internalFilterStyle(target, pick, isMulti)(pickObject);
  return target;
};
var internalFilterStyle = (target, keys2, isMulti, refs = []) => (func2) => {
  if (!isObject(target)) return target;
  let result = Object.assign({}, target);
  result = func2(result, keys2);
  Object.entries(result != null ? result : {}).forEach(([nestedKey, value]) => {
    const newKeys = keys2.filter((key) => key !== nestedKey);
    const newRefs = [...refs, nestedKey];
    if (!onValidFilterStyleKey(newRefs, isMulti)) return;
    if (isFunction(value)) {
      result[nestedKey] = (props2) => internalFilterStyle(value(props2), newKeys, isMulti, newRefs)(func2);
    } else {
      if (func2 === omitObject || Object.keys(value).some((key) => newKeys.includes(key))) {
        result[nestedKey] = internalFilterStyle(
          value,
          newKeys,
          isMulti,
          newRefs
        )(func2);
      } else {
        result[nestedKey] = merge(
          result[nestedKey],
          internalFilterStyle(value, newKeys, isMulti, newRefs)(func2)
        );
      }
    }
  });
  return result;
};
var onValidFilterStyleKey = (keys2, isMulti) => {
  const rootKey = keys2[0];
  switch (rootKey) {
    case "baseStyle":
      return keys2.length < (isMulti ? 2 : 1);
    case "variants":
    case "sizes":
      return keys2.length < (isMulti ? 3 : 2);
    default:
      return false;
  }
};
var pickStyle = (target, targetKey, withProps = true) => {
  const result = {};
  Object.entries(target).forEach(([key, value]) => {
    switch (key) {
      case "baseStyle":
        if (isFunction(value)) {
          result[key] = (props2) => value(props2)[targetKey];
        } else {
          result[key] = value[targetKey];
        }
        break;
      case "variants":
      case "sizes":
        result[key] = Object.entries(
          value
        ).reduce((prev2, [key2, value2]) => {
          if (isFunction(value2)) {
            prev2[key2] = (props2) => value2(props2)[targetKey];
          } else {
            prev2[key2] = value2[targetKey];
          }
          return prev2;
        }, {});
        break;
      case "defaultProps":
        if (withProps) result[key] = value;
        break;
      default:
        break;
    }
  });
  return result;
};
var COLOR_MODE_STORAGE_KEY = "ui-color-mode";
var COLOR_MODE_MAP = /* @__PURE__ */ new Set(["dark", "light", "system"]);
var normalizeColorMode = (initialColorMode) => {
  let value = initialColorMode;
  if (!COLOR_MODE_MAP.has(value)) value = "light";
  return value;
};
var getColorModeScript = ({
  initialColorMode = "light",
  type = "localStorage",
  storageKey = COLOR_MODE_STORAGE_KEY
} = {}) => {
  const init = normalizeColorMode(initialColorMode);
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="ui-light",n="ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.mode=e,e},h="${init}",r="${storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
  const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="ui-light",d="ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.mode=r,r},m="${init}",e="${storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
  const fn2 = isCookie ? cookieScript : localStorageScript;
  return `!${fn2}`.trim();
};
var ColorModeScript = ({ nonce: nonce2, ...rest }) => {
  const html = getColorModeScript(rest);
  return (0, import_jsx_runtime.jsx)(
    "script",
    {
      id: "ui-color-mode-script",
      nonce: nonce2,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
};
var hasSupport = !!(globalThis == null ? void 0 : globalThis.document);
var createLocalStorage = (defaultStorageKey) => ({
  ssr: false,
  type: "localStorage",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (!hasSupport) return initColorMode;
    try {
      const colorMode = localStorage.getItem(storageKey);
      return colorMode || initColorMode;
    } catch {
      return initColorMode;
    }
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, colorMode);
    } catch {
    }
  }
});
var parseCookie = (cookie, key) => {
  const match2 = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match2 == null ? void 0 : match2[2];
};
var createCookieStorage = (defaultStorageKey, cookie) => ({
  ssr: !!cookie,
  type: "cookie",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (cookie) return parseCookie(cookie, storageKey) || initColorMode;
    if (!hasSupport) return initColorMode;
    return parseCookie(document.cookie, storageKey) || initColorMode;
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${colorMode}; max-age=31536000; path=/`;
  }
});
var createColorModeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage(
        COLOR_MODE_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage(COLOR_MODE_STORAGE_KEY);
  }
};
var colorModeManager = {
  localStorage: createLocalStorage(COLOR_MODE_STORAGE_KEY),
  cookieStorage: createCookieStorage(COLOR_MODE_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage(COLOR_MODE_STORAGE_KEY, cookie),
  createLocalStorage,
  createCookieStorage
};
var preventTransition = (environment2) => {
  const { getWindow: getWindow2, getDocument } = environment2;
  const win = getWindow2();
  const doc = getDocument();
  if (!doc) return;
  const css22 = doc.createElement("style");
  const node3 = doc.createTextNode(
    `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
  );
  css22.appendChild(node3);
  doc.head.appendChild(css22);
  return () => {
    const forceReflow = () => win == null ? void 0 : win.getComputedStyle(doc.body);
    forceReflow();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css22);
      });
    });
  };
};
var classNames = {
  light: "ui-light",
  dark: "ui-dark"
};
var queries = {
  light: "(prefers-color-scheme: light)",
  dark: "(prefers-color-scheme: dark)"
};
var getColorModeUtils = ({
  isPreventTransition = true,
  environment: environment2
}) => {
  const { getWindow: getWindow2, getDocument } = environment2;
  const setDataset = (colorMode) => {
    const doc = getDocument();
    const cleanup = isPreventTransition ? preventTransition(environment2) : void 0;
    if (!doc) return;
    doc.documentElement.dataset.mode = colorMode;
    doc.documentElement.style.colorScheme = colorMode;
    cleanup == null ? void 0 : cleanup();
  };
  const setClassName = (isDark2) => {
    const doc = getDocument();
    if (!doc) return;
    doc.body.classList.add(isDark2 ? classNames.dark : classNames.light);
    doc.body.classList.remove(isDark2 ? classNames.light : classNames.dark);
  };
  const query = () => {
    const win = getWindow2();
    if (!win) return;
    return win.matchMedia(queries.dark);
  };
  const getSystemColorMode = (fallback) => {
    var _a;
    const mql = query();
    const dark = (_a = mql == null ? void 0 : mql.matches) != null ? _a : fallback === "dark";
    return dark ? "dark" : "light";
  };
  const addListener = (func2) => {
    const mql = query();
    const listener = (e) => {
      func2(e.matches ? "dark" : "light");
    };
    if (typeof (mql == null ? void 0 : mql.addListener) === "function") {
      mql.addListener(listener);
    } else {
      mql == null ? void 0 : mql.addEventListener("change", listener);
    }
    return () => {
      if (typeof (mql == null ? void 0 : mql.removeListener) === "function") {
        mql.removeListener(listener);
      } else {
        mql == null ? void 0 : mql.removeEventListener("change", listener);
      }
    };
  };
  return {
    setDataset,
    setClassName,
    query,
    getSystemColorMode,
    addListener
  };
};
var environment = {
  getDocument: () => document,
  getWindow: () => window
};
var EnvironmentContext = (0, import_react13.createContext)(environment);
var EnvironmentProvider = ({
  children,
  environment: environment2,
  disabled
}) => {
  const ref = (0, import_react13.useRef)(null);
  const context = (0, import_react13.useMemo)(() => {
    if (environment2) return environment2;
    return {
      getDocument: () => {
        var _a, _b;
        return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
      },
      getWindow: () => {
        var _a, _b;
        return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument.defaultView) != null ? _b : window;
      }
    };
  }, [environment2]);
  const enabled2 = !disabled || !environment2;
  return (0, import_jsx_runtime2.jsxs)(EnvironmentContext.Provider, { value: context, children: [
    children,
    enabled2 ? (0, import_jsx_runtime2.jsx)("span", { id: "__ui_dev", hidden: true, ref }) : null
  ] });
};
EnvironmentProvider.displayName = "EnvironmentProvider";
var useEnvironment = ({ isDefer } = {}) => {
  const [, forceUpdate] = (0, import_react13.useReducer)((c) => c + 1, 0);
  useSafeLayoutEffect(() => {
    if (!isDefer) return;
    forceUpdate();
  }, [isDefer]);
  return (0, import_react13.useContext)(EnvironmentContext);
};
var { localStorage: localStorage2 } = colorModeManager;
var getColorMode = (manager, fallback) => (storageKey) => manager.type === "cookie" && manager.ssr ? manager.get(fallback)(storageKey) : fallback;
var ColorModeContext = (0, import_react12.createContext)({});
var ColorModeProvider = ({
  colorMode: defaultColorMode,
  colorModeManager: colorModeManager2 = localStorage2,
  storageKey,
  config: { initialColorMode = "light", disableTransitionOnChange = true } = {},
  children
}) => {
  const environment2 = useEnvironment();
  const [colorMode, setColorMode] = (0, import_react12.useState)(
    () => getColorMode(colorModeManager2, initialColorMode)(storageKey)
  );
  const [systemColorMode, setSystemColorMode] = (0, import_react12.useState)(
    void 0
  );
  const defaultResolvedColorMode = initialColorMode === "dark" ? "dark" : "light";
  const resolvedColorMode = colorMode === "system" ? systemColorMode ? systemColorMode : defaultResolvedColorMode : colorMode;
  const { getSystemColorMode, setClassName, setDataset, addListener } = (0, import_react12.useMemo)(
    () => getColorModeUtils({
      isPreventTransition: disableTransitionOnChange,
      environment: environment2
    }),
    [disableTransitionOnChange, environment2]
  );
  const changeColorMode = (0, import_react12.useCallback)(
    (colorMode2) => {
      const resolved = colorMode2 === "system" ? getSystemColorMode() : colorMode2;
      setColorMode(colorMode2);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager2.set(colorMode2)(storageKey);
    },
    [
      colorModeManager2,
      getSystemColorMode,
      setClassName,
      setDataset,
      storageKey
    ]
  );
  const changeSystemColorMode = (0, import_react12.useCallback)(
    (systemColorMode2) => {
      setSystemColorMode(systemColorMode2);
      if (colorMode !== "system") return;
      setClassName(systemColorMode2 === "dark");
      setDataset(systemColorMode2);
    },
    [colorMode, setClassName, setDataset]
  );
  const toggleColorMode = (0, import_react12.useCallback)(() => {
    changeColorMode(resolvedColorMode === "dark" ? "light" : "dark");
  }, [changeColorMode, resolvedColorMode]);
  useSafeLayoutEffect(() => {
    setSystemColorMode(getSystemColorMode());
  }, [initialColorMode, addListener, changeColorMode]);
  (0, import_react12.useEffect)(() => {
    const managerValue = colorModeManager2.get()(storageKey);
    if (managerValue) changeColorMode(managerValue);
  }, [changeColorMode, colorModeManager2, storageKey]);
  (0, import_react12.useEffect)(() => {
    return addListener(changeSystemColorMode);
  }, [addListener, changeSystemColorMode]);
  const context = (0, import_react12.useMemo)(
    () => ({
      colorMode: defaultColorMode != null ? defaultColorMode : resolvedColorMode,
      internalColorMode: colorMode,
      changeColorMode: defaultColorMode ? noop : changeColorMode,
      toggleColorMode: defaultColorMode ? noop : toggleColorMode,
      forced: defaultColorMode !== void 0
    }),
    [
      defaultColorMode,
      resolvedColorMode,
      colorMode,
      changeColorMode,
      toggleColorMode
    ]
  );
  return (0, import_jsx_runtime3.jsx)(ColorModeContext.Provider, { value: context, children });
};
var useColorMode = () => {
  const context = (0, import_react12.useContext)(ColorModeContext);
  return context != null ? context : { colorMode: "light", internalColorMode: "light", forced: false };
};
var useColorModeValue = (light, dark) => {
  const { colorMode } = useColorMode();
  return getColorModeValue(light, dark)(colorMode);
};
var getColorModeValue = (light, dark) => (colorMode) => {
  return colorMode === "light" ? light : dark;
};
var THEME_SCHEME_STORAGE_KEY = "ui-theme-scheme";
var getThemeSchemeScript = ({
  initialThemeScheme: init = "base",
  type = "localStorage",
  storageKey = THEME_SCHEME_STORAGE_KEY
} = {}) => {
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},h='${init}',r='${storageKey}',t=document.cookie.match(new RegExp('(^| )'.concat(r,'=([^;]+)'))),c=t?t[2]:null;c?a(c):(document.cookie=''.concat(r,'=').concat(a(h),'; max-age=31536000; path=/'))}catch(a){}})();`;
  const localStorageScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},m='${init}',e='${storageKey}',t=localStorage.getItem(e);t?a(t):localStorage.setItem(e, a(m))}catch(a){}})();`;
  const fn2 = isCookie ? cookieScript : localStorageScript;
  return `!${fn2}`.trim();
};
var ThemeSchemeScript = ({
  nonce: nonce2,
  ...rest
}) => {
  const html = getThemeSchemeScript(rest);
  return (0, import_jsx_runtime4.jsx)(
    "script",
    {
      id: "ui-theme-script",
      nonce: nonce2,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
};
var hasSupport2 = !!(globalThis == null ? void 0 : globalThis.document);
var createLocalStorage2 = (defaultStorageKey) => ({
  ssr: false,
  type: "localStorage",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (!hasSupport2) return initThemeScheme;
    try {
      const themeScheme = localStorage.getItem(storageKey);
      return themeScheme || initThemeScheme;
    } catch {
      return initThemeScheme;
    }
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, String(themeScheme));
    } catch {
    }
  }
});
var parseCookie2 = (cookie, key) => {
  const match2 = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match2 == null ? void 0 : match2[2];
};
var createCookieStorage2 = (defaultStorageKey, cookie) => ({
  ssr: !!cookie,
  type: "cookie",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (cookie) return parseCookie2(cookie, storageKey) || initThemeScheme;
    if (!hasSupport2) return initThemeScheme;
    return parseCookie2(document.cookie, storageKey) || initThemeScheme;
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${themeScheme}; max-age=31536000; path=/`;
  }
});
var createThemeSchemeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage2(
        THEME_SCHEME_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage2(THEME_SCHEME_STORAGE_KEY);
  }
};
var themeSchemeManager = {
  localStorage: createLocalStorage2(THEME_SCHEME_STORAGE_KEY),
  cookieStorage: createCookieStorage2(THEME_SCHEME_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage2(THEME_SCHEME_STORAGE_KEY, cookie),
  createLocalStorage: createLocalStorage2,
  createCookieStorage: createCookieStorage2
};
var { localStorage: localStorage3 } = themeSchemeManager;
var ThemeProvider3 = ({
  theme: initialTheme = {},
  config: config2,
  themeSchemeManager: themeSchemeManager2 = localStorage3,
  storageKey,
  children
}) => {
  const environment2 = useEnvironment();
  const [themeScheme, setThemeScheme] = (0, import_react11.useState)(
    themeSchemeManager2.get(config2 == null ? void 0 : config2.initialThemeScheme)(storageKey)
  );
  const changeThemeScheme = (0, import_react11.useCallback)(
    (themeScheme2) => {
      const { getDocument } = environment2;
      const doc = getDocument();
      const cleanup = (config2 == null ? void 0 : config2.disableTransitionOnChange) ? preventTransition(environment2) : void 0;
      if (doc) doc.documentElement.dataset.theme = themeScheme2;
      cleanup == null ? void 0 : cleanup();
      setThemeScheme(themeScheme2);
      themeSchemeManager2.set(themeScheme2)(storageKey);
    },
    [config2, environment2, themeSchemeManager2, storageKey]
  );
  const theme = (0, import_react11.useMemo)(
    () => transformTheme(initialTheme, config2),
    [initialTheme, config2]
  );
  (0, import_react11.useEffect)(() => {
    const managerValue = themeSchemeManager2.get()(storageKey);
    if (managerValue) changeThemeScheme(managerValue);
  }, [changeThemeScheme, themeSchemeManager2, storageKey]);
  return (0, import_jsx_runtime5.jsxs)(ThemeProvider, { theme: { themeScheme, changeThemeScheme, ...theme }, children: [
    (0, import_jsx_runtime5.jsx)(CSSVars, {}),
    children
  ] });
};
var CSSVars = () => {
  return (0, import_jsx_runtime5.jsx)(
    Global,
    {
      styles: ({ __cssVars }) => {
        return { ":host, :root, [data-mode]": __cssVars };
      }
    }
  );
};
var ResetStyle = () => {
  const { colorMode } = useColorMode();
  return (0, import_jsx_runtime5.jsx)(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        let style = getMemoizedObject(theme, "styles.resetStyle", {});
        const computedStyle = runIfFunc(style, {
          theme,
          colorMode,
          themeScheme
        });
        if (!computedStyle) return void 0;
        return css3(computedStyle)(theme);
      }
    }
  );
};
var GlobalStyle = () => {
  const { colorMode } = useColorMode();
  return (0, import_jsx_runtime5.jsx)(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        let style = getMemoizedObject(theme, "styles.globalStyle", {});
        const computedStyle = runIfFunc(style, {
          theme,
          colorMode,
          themeScheme
        });
        if (!computedStyle) return void 0;
        return css3(computedStyle)(theme);
      }
    }
  );
};
var useTheme2 = () => {
  const { themeScheme, changeThemeScheme, ...internalTheme } = (0, import_react11.useContext)(
    ThemeContext
  );
  const theme = (0, import_react11.useMemo)(() => {
    var _a;
    if (isUndefined(themeScheme) || themeScheme === "base") return internalTheme;
    const nestedTheme = (_a = internalTheme.themeSchemes) == null ? void 0 : _a[themeScheme];
    if (!nestedTheme) return internalTheme;
    return merge(internalTheme, nestedTheme);
  }, [themeScheme, internalTheme]);
  const value = (0, import_react11.useMemo)(
    () => ({ themeScheme, changeThemeScheme, theme, internalTheme }),
    [themeScheme, changeThemeScheme, theme, internalTheme]
  );
  return value;
};
var getColorModeStyles = (value, modifierStyles, props2) => ({ isMulti = false }) => {
  const [lightValue, darkValue] = value;
  const lightStyles = getStyles(
    modifierStyles[lightValue],
    props2
  )({ isMulti, query: pseudos._light });
  const darkStyles = getStyles(
    modifierStyles[darkValue],
    props2
  )({ isMulti, query: pseudos._dark });
  return [lightStyles, darkStyles];
};
var getResponsiveStyles = (value, modifierStyles, props2) => ({ isMulti = false }) => {
  var _a, _b, _c;
  const providedKeys = keysFormObject(value);
  if (providedKeys.length === 1 && "base" in value) {
    return getStyles(
      modifierStyles[value.base],
      props2
    )({ isMulti });
  } else {
    const { queries: queries2 = [] } = (_a = props2.theme.__breakpoints) != null ? _a : {};
    const { direction = "down", identifier: identifier2 } = (_c = (_b = props2.theme.__config) == null ? void 0 : _b.breakpoint) != null ? _c : {};
    const isDown = direction !== "up";
    const finalQuery = queries2.filter(
      ({ breakpoint }) => breakpoint !== "base" && providedKeys.includes(breakpoint)
    ).sort(
      (a, b) => {
        var _a2, _b2, _c2, _d;
        return isDown ? ((_a2 = a.maxW) != null ? _a2 : 0) - ((_b2 = b.maxW) != null ? _b2 : 0) : ((_c2 = b.minW) != null ? _c2 : 0) - ((_d = a.minW) != null ? _d : 0);
      }
    )[0];
    let hasBaseStyles = false;
    return queries2.reduce(
      (prev2, { breakpoint, minW, maxW, maxWQuery, minWQuery }, index) => {
        var _a2;
        const modifier = value[breakpoint];
        const isFinal = breakpoint === finalQuery.breakpoint;
        if (breakpoint === "base") return prev2;
        if (!modifier) return prev2;
        if (!hasBaseStyles) {
          const baseModifier = value.base;
          const prevQuery = queries2[index - 1];
          const query2 = prevQuery == null ? void 0 : prevQuery[isDown ? "minWQuery" : "maxWQuery"];
          const baseStyles = getStyles(
            baseModifier ? modifierStyles[baseModifier] : {},
            props2
          )({ isMulti, query: query2 });
          prev2 = merge(prev2, baseStyles);
          hasBaseStyles = true;
        }
        let query = isDown ? maxWQuery : minWQuery;
        if (!isFinal) {
          let nextIndex = index + 1;
          let nextQuery;
          while (nextIndex < queries2.length) {
            const query2 = (_a2 = queries2[nextIndex]) != null ? _a2 : {};
            if (value[query2.breakpoint]) {
              const targetIndex = nextIndex - 1;
              nextQuery = queries2[targetIndex];
              break;
            }
            nextIndex += 1;
          }
          minW = isDown ? nextQuery == null ? void 0 : nextQuery.minW : minW;
          maxW = isDown ? maxW : nextQuery == null ? void 0 : nextQuery.maxW;
          query = createQuery(minW, maxW, identifier2);
        }
        const queryStyles = getStyles(
          modifierStyles[modifier],
          props2
        )({ isMulti, query });
        prev2 = merge(prev2, queryStyles);
        return prev2;
      },
      {}
    );
  }
};
var getModifierStyles = (value, modifierStyles, props2) => ({ isMulti = false }) => {
  let styles2 = {};
  if (!value) return styles2;
  if (isArray(value)) {
    const [lightStyles, darkStyles] = getColorModeStyles(
      value,
      modifierStyles,
      props2
    )({ isMulti });
    styles2 = merge(lightStyles, darkStyles);
  } else if (isObject(value)) {
    styles2 = getResponsiveStyles(
      value,
      modifierStyles,
      props2
    )({ isMulti });
  } else {
    styles2 = getStyles(modifierStyles[value], props2)({ isMulti });
  }
  return styles2;
};
var getStyles = (stylesOrFunc, props2) => ({ isMulti = false, query }) => {
  let styles2 = runIfFunc(stylesOrFunc, props2);
  if (isMulti) {
    for (const [key, styleOrFunc] of Object.entries(
      styles2 != null ? styles2 : {}
    )) {
      const style = runIfFunc(styleOrFunc, props2);
      if (query) {
        styles2 = merge(styles2, { [key]: { [query]: style } });
      } else {
        styles2 = merge(styles2, { [key]: style });
      }
    }
  } else if (query) {
    return { [query]: styles2 };
  }
  return styles2;
};
var mergeProps = (props2, defaultProps, overrideProps) => {
  if (defaultProps) props2 = merge(defaultProps, props2);
  if (overrideProps) props2 = runIfFunc(overrideProps, props2);
  return props2;
};
var setStyles = (name, props2, { isMulti, isProcessSkip: isProcessSkip2, styles: styles2 = {} } = {}) => {
  const { theme, themeScheme } = useTheme2();
  const { colorMode } = useColorMode();
  const propsRef = (0, import_react7.useRef)({});
  const stylesRef = (0, import_react7.useRef)(isProcessSkip2 ? styles2 : {});
  if (!isProcessSkip2) {
    const componentStyle = getMemoizedObject(
      theme,
      `components.${name}`
    );
    props2 = filterUndefined(props2);
    if (componentStyle) {
      const { defaultProps, overrideProps, baseStyle, variants: variants6, sizes: sizes2 } = componentStyle;
      props2 = mergeProps(props2, defaultProps, overrideProps);
      const { variant, size } = props2;
      const resolvedProps = omitObject(props2, ["children"]);
      let styles3 = {};
      if (baseStyle) {
        styles3 = getStyles(baseStyle, {
          theme,
          colorMode,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
      }
      if (sizes2) {
        const sizeStyles = getModifierStyles(size, sizes2, {
          theme,
          colorMode,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
        styles3 = merge(styles3, sizeStyles);
      }
      if (variants6) {
        const variantStyles = getModifierStyles(variant, variants6, {
          theme,
          colorMode,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
        styles3 = merge(styles3, variantStyles);
      }
      const isStylesEqual = (0, import_react_fast_compare.default)(stylesRef.current, styles3);
      if (!isStylesEqual) stylesRef.current = styles3;
    }
  }
  const isPropsEqual = (0, import_react_fast_compare.default)(propsRef.current, props2);
  if (!isPropsEqual) propsRef.current = props2;
  return [stylesRef.current, propsRef.current];
};
var useComponentStyle = (name, props2, options) => setStyles(name, props2, options);
var useMultiComponentStyle = (name, props2, options) => {
  return setStyles(name, props2, { isMulti: true, ...options });
};
var UIProps = /* @__PURE__ */ new Set([
  ...styleProperties,
  ...pseudosProperties,
  "as",
  "__css",
  "css",
  "sx",
  "focusBorderColor",
  "errorBorderColor"
]);
var shouldForwardProp = (disableStyleProp) => (prop) => {
  var _a;
  return ((_a = disableStyleProp == null ? void 0 : disableStyleProp(prop)) != null ? _a : false) || !UIProps.has(prop);
};
var emotionStyled = interopDefault(newStyled);
var styleProps = { ...styles, ...pseudos };
var toCSSObject = ({ baseStyle, disableStyleProp }) => (props2) => {
  const { theme, css: customCSS, __css, sx, ...rest } = props2;
  const propsCSS = filterObject(
    rest,
    (prop) => prop in styleProps
  );
  const baseCSS = runIfFunc(baseStyle, props2);
  const computedCSS = css3(
    assignAfter({}, __css, baseCSS, filterUndefined(propsCSS), sx)
  )(theme, disableStyleProp);
  return customCSS ? [computedCSS, customCSS] : computedCSS;
};
var styled = (element, { baseStyle, disableStyleProp, ...styledOptions } = {}) => {
  if (!styledOptions.shouldForwardProp)
    styledOptions.shouldForwardProp = shouldForwardProp(disableStyleProp);
  const CSSObject = toCSSObject({ baseStyle, disableStyleProp });
  const Component3 = emotionStyled(
    element,
    styledOptions
  )(CSSObject);
  const UIComponent = (0, import_react14.forwardRef)((props2, ref) => {
    const { colorMode, forced } = useColorMode();
    return (0, import_react14.createElement)(Component3, {
      ref,
      "data-mode": forced ? colorMode : void 0,
      ...props2
    });
  });
  UIComponent.displayName = "UIComponent";
  return UIComponent;
};
var factory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    apply: (_target, _thisArg, [el, options]) => {
      return styled(el, options);
    },
    get: (_target, el) => {
      if (!cache2.has(el)) cache2.set(el, styled(el));
      return cache2.get(el);
    }
  });
};
var ui = factory();

// node_modules/@yamada-ui/use-token/dist/index.mjs
var useToken = (name, path) => {
  const { theme } = useTheme2();
  const { colorMode } = useColorMode();
  return getToken(name, path)(theme, colorMode);
};
var getToken = (name, path) => (theme, colorMode) => {
  var _a, _b, _c;
  if (name === "layerStyles") name = "styles.layerStyles";
  if (name === "textStyles") name = "styles.textStyles";
  if (name === "transitionProperty") name = "transitions.property";
  if (name === "transitionDuration") name = "transitions.duration";
  if (name === "transitionEasing") name = "transitions.easing";
  let value = getMemoizedObject(theme, `${name}.${path}`);
  if (!isUndefined(value)) {
    if (isArray(value)) {
      const [lightValue, darkValue] = value;
      return colorMode === "light" ? lightValue : darkValue;
    } else {
      return value;
    }
  } else {
    value = getMemoizedObject(theme, `semantics.${name}.${path}`);
    if (isArray(value)) {
      value = [
        (_a = getMemoizedObject(theme, `${name}.${value[0]}`)) != null ? _a : value[0],
        (_b = getMemoizedObject(theme, `${name}.${value[1]}`)) != null ? _b : value[1]
      ];
    } else {
      value = (_c = getMemoizedObject(theme, `${name}.${value}`)) != null ? _c : value;
    }
    if (isArray(value)) {
      const [lightValue, darkValue] = value;
      value = colorMode === "light" ? lightValue : darkValue;
      if (isArray(value)) {
        const [lightValue2, darkValue2] = value;
        return colorMode === "light" ? lightValue2 : darkValue2;
      } else {
        return value;
      }
    } else {
      return value;
    }
  }
};

// node_modules/@yamada-ui/icon/dist/chunk-JXMDJEWM.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var Icon = forwardRef22((props2, ref) => {
  const [styles2, { size, ...mergedProps }] = useComponentStyle("Icon", props2);
  let {
    className,
    as: element,
    fontSize,
    viewBox,
    __css,
    ...rest
  } = omitThemeProps(mergedProps);
  fontSize != null ? fontSize : fontSize = size;
  const boxSize = replaceObject(
    fontSize,
    (value) => !isUnit(value) ? useToken("fontSizes", value) : value
  );
  const css4 = {
    ...styles2,
    ...__css,
    boxSize
  };
  if (element && typeof element !== "string")
    return (0, import_jsx_runtime6.jsx)(
      ui.svg,
      {
        as: element,
        className: cx("ui-icon", className),
        __css: css4,
        ...rest
      }
    );
  return (0, import_jsx_runtime6.jsx)(
    ui.svg,
    {
      ref,
      verticalAlign: "middle",
      viewBox,
      className: cx("ui-icon", className),
      __css: css4,
      ...rest
    }
  );
});
var CheckIcon = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Icon, { viewBox: "0 0 24 24", ...props2, children: (0, import_jsx_runtime6.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
};
var InfoIcon = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Icon, { viewBox: "0 0 24 24", ...props2, children: (0, import_jsx_runtime6.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
};
var WarningIcon = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Icon, { viewBox: "0 0 24 24", ...props2, children: (0, import_jsx_runtime6.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
};
var CloseIcon = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Icon, { focusable: "false", "aria-hidden": true, viewBox: "0 0 24 24", ...props2, children: (0, import_jsx_runtime6.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
};
var ChevronIcon = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Icon, { focusable: "false", "aria-hidden": true, viewBox: "0 0 24 24", ...props2, children: (0, import_jsx_runtime6.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
    }
  ) });
};

// node_modules/@yamada-ui/loading/dist/chunk-ENUKQWPP.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var Puff = forwardRef22(
  ({ color: color2, duration = "1.8s", ...rest }, ref) => {
    return (0, import_jsx_runtime7.jsx)(Icon, { ref, viewBox: "0 0 44 44", stroke: color2, ...rest, children: (0, import_jsx_runtime7.jsxs)("g", { fill: "none", fillRule: "evenodd", strokeWidth: "2", children: [
      (0, import_jsx_runtime7.jsxs)("circle", { cx: "22", cy: "22", r: "1", children: [
        (0, import_jsx_runtime7.jsx)(
          "animate",
          {
            attributeName: "r",
            begin: "0s",
            dur: duration,
            values: "1; 20",
            calcMode: "spline",
            keyTimes: "0; 1",
            keySplines: "0.165, 0.84, 0.44, 1",
            repeatCount: "indefinite"
          }
        ),
        (0, import_jsx_runtime7.jsx)(
          "animate",
          {
            attributeName: "stroke-opacity",
            begin: "0s",
            dur: duration,
            values: "1; 0",
            calcMode: "spline",
            keyTimes: "0; 1",
            keySplines: "0.3, 0.61, 0.355, 1",
            repeatCount: "indefinite"
          }
        )
      ] }),
      (0, import_jsx_runtime7.jsxs)("circle", { cx: "22", cy: "22", r: "1", children: [
        (0, import_jsx_runtime7.jsx)(
          "animate",
          {
            attributeName: "r",
            begin: "-0.9s",
            dur: duration,
            values: "1; 20",
            calcMode: "spline",
            keyTimes: "0; 1",
            keySplines: "0.165, 0.84, 0.44, 1",
            repeatCount: "indefinite"
          }
        ),
        (0, import_jsx_runtime7.jsx)(
          "animate",
          {
            attributeName: "stroke-opacity",
            begin: "-0.9s",
            dur: duration,
            values: "1; 0",
            calcMode: "spline",
            keyTimes: "0; 1",
            keySplines: "0.3, 0.61, 0.355, 1",
            repeatCount: "indefinite"
          }
        )
      ] })
    ] }) });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-4JKPWQSY.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var Rings = forwardRef22(
  ({ color: color2, duration = "3s", ...rest }, ref) => {
    const dur = typeof duration === "string" ? parseFloat(duration) : duration;
    return (0, import_jsx_runtime8.jsx)(Icon, { ref, viewBox: "0 0 45 45", stroke: color2, ...rest, children: (0, import_jsx_runtime8.jsxs)(
      "g",
      {
        fill: "none",
        fillRule: "evenodd",
        transform: "translate(1 1)",
        strokeWidth: "2",
        children: [
          (0, import_jsx_runtime8.jsxs)("circle", { cx: "22", cy: "22", r: "6", strokeOpacity: "0", children: [
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "r",
                begin: "1.5s",
                dur: `${dur}s`,
                values: "6;22",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "stroke-opacity",
                begin: "1.5s",
                dur: `${dur}s`,
                values: "1;0",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "stroke-width",
                begin: "1.5s",
                dur: `${dur}s`,
                values: "2;0",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            )
          ] }),
          (0, import_jsx_runtime8.jsxs)("circle", { cx: "22", cy: "22", r: "6", strokeOpacity: "0", children: [
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "r",
                begin: "3s",
                dur: `${dur}s`,
                values: "6;22",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "stroke-opacity",
                begin: "3s",
                dur: `${dur}s`,
                values: "1;0",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              "animate",
              {
                attributeName: "stroke-width",
                begin: "3s",
                dur: `${dur}s`,
                values: "2;0",
                calcMode: "linear",
                repeatCount: "indefinite"
              }
            )
          ] }),
          (0, import_jsx_runtime8.jsx)("circle", { cx: "22", cy: "22", r: "8", children: (0, import_jsx_runtime8.jsx)(
            "animate",
            {
              attributeName: "r",
              begin: "0s",
              dur: `${dur / 2}s`,
              values: "6;1;2;3;4;5;6",
              calcMode: "linear",
              repeatCount: "indefinite"
            }
          ) })
        ]
      }
    ) });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-EYRZLOPC.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var Audio = forwardRef22(
  ({ color: color2, duration = "1.4s", ...rest }, ref) => {
    const dur = typeof duration === "string" ? parseFloat(duration) : duration;
    return (0, import_jsx_runtime9.jsx)(Icon, { ref, viewBox: "0 0 55 80", fill: color2, ...rest, children: (0, import_jsx_runtime9.jsxs)("g", { transform: "matrix(1 0 0 -1 0 80)", children: [
      (0, import_jsx_runtime9.jsx)("rect", { width: "10", height: "20", rx: "3", children: (0, import_jsx_runtime9.jsx)(
        "animate",
        {
          attributeName: "height",
          begin: "0s",
          dur: `${dur * 3}s`,
          values: "20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime9.jsx)("rect", { x: "15", width: "10", height: "80", rx: "3", children: (0, import_jsx_runtime9.jsx)(
        "animate",
        {
          attributeName: "height",
          begin: "0s",
          dur: `${dur * 1.4}s`,
          values: "80;55;33;5;75;23;73;33;12;14;60;80",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime9.jsx)("rect", { x: "30", width: "10", height: "50", rx: "3", children: (0, import_jsx_runtime9.jsx)(
        "animate",
        {
          attributeName: "height",
          begin: "0s",
          dur: `${dur}s`,
          values: "50;34;78;23;56;23;34;76;80;54;21;50",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime9.jsx)("rect", { x: "45", width: "10", height: "30", rx: "3", children: (0, import_jsx_runtime9.jsx)(
        "animate",
        {
          attributeName: "height",
          begin: "0s",
          dur: `${dur * 1.4}s`,
          values: "30;45;13;80;56;72;45;76;34;23;67;30",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) })
    ] }) });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-TP5LE3DK.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var Circles = forwardRef22(
  ({ color: color2, duration = "3s", ...rest }, ref) => {
    return (0, import_jsx_runtime10.jsx)(Icon, { ref, viewBox: "0 0 58 58", stroke: color2, ...rest, children: (0, import_jsx_runtime10.jsx)("g", { fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime10.jsxs)("g", { transform: "translate(2 1)", stroke: color2, strokeWidth: "1.5", children: [
      (0, import_jsx_runtime10.jsx)("circle", { cx: "42.601", cy: "11.462", r: "5", fillOpacity: "1", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "1;0;0;0;0;0;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "49.063", cy: "27.063", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;1;0;0;0;0;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "42.601", cy: "42.663", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;1;0;0;0;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "27", cy: "49.125", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;0;1;0;0;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "11.399", cy: "42.663", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;0;0;1;0;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "4.938", cy: "27.063", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;0;0;0;1;0;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "11.399", cy: "11.462", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;0;0;0;0;1;0",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime10.jsx)("circle", { cx: "27", cy: "5", r: "5", fillOpacity: "0", fill: color2, children: (0, import_jsx_runtime10.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "0;0;0;0;0;0;0;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) })
    ] }) }) });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-TIRPNXA7.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var Dots = forwardRef22(
  ({ color: color2, duration = "1s", ...rest }, ref) => {
    return (0, import_jsx_runtime11.jsxs)(Icon, { ref, viewBox: "0 0 120 30", fill: color2, ...rest, children: [
      (0, import_jsx_runtime11.jsxs)("circle", { cx: "15", cy: "15", r: "15", children: [
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "r",
            from: "15",
            to: "15",
            begin: "0s",
            dur: duration,
            values: "15;9;15",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "fill-opacity",
            from: "1",
            to: "1",
            begin: "0s",
            dur: duration,
            values: "1;.5;1",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        )
      ] }),
      (0, import_jsx_runtime11.jsxs)("circle", { cx: "60", cy: "15", r: "9", fillOpacity: "0.3", children: [
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "r",
            from: "9",
            to: "9",
            begin: "0s",
            dur: duration,
            values: "9;15;9",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "fill-opacity",
            from: "0.5",
            to: "0.5",
            begin: "0s",
            dur: duration,
            values: ".5;1;.5",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        )
      ] }),
      (0, import_jsx_runtime11.jsxs)("circle", { cx: "105", cy: "15", r: "15", children: [
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "r",
            from: "15",
            to: "15",
            begin: "0s",
            dur: duration,
            values: "15;9;15",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "animate",
          {
            attributeName: "fill-opacity",
            from: "1",
            to: "1",
            begin: "0s",
            dur: duration,
            values: "1;.5;1",
            calcMode: "linear",
            repeatCount: "indefinite"
          }
        )
      ] })
    ] });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-TIONMRJE.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var Grid = forwardRef22(
  ({ color: color2, duration = "1s", ...rest }, ref) => {
    return (0, import_jsx_runtime12.jsxs)(Icon, { ref, viewBox: "0 0 105 105", fill: color2, ...rest, children: [
      (0, import_jsx_runtime12.jsx)("circle", { cx: "12.5", cy: "12.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "0s",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "12.5", cy: "52.5", r: "12.5", fillOpacity: ".5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "100ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "52.5", cy: "12.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "300ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "52.5", cy: "52.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "600ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "92.5", cy: "12.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "800ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "92.5", cy: "52.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "400ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "12.5", cy: "92.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "700ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "52.5", cy: "92.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "500ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) }),
      (0, import_jsx_runtime12.jsx)("circle", { cx: "92.5", cy: "92.5", r: "12.5", children: (0, import_jsx_runtime12.jsx)(
        "animate",
        {
          attributeName: "fill-opacity",
          begin: "200ms",
          dur: duration,
          values: "1;.2;1",
          calcMode: "linear",
          repeatCount: "indefinite"
        }
      ) })
    ] });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-MNPPARYC.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var Oval = forwardRef22(
  ({ color: color2, secondaryColor, duration = "1s", ...rest }, ref) => {
    return (0, import_jsx_runtime13.jsx)(Icon, { ref, viewBox: "0 0 38 38", stroke: color2, ...rest, children: (0, import_jsx_runtime13.jsx)("g", { fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime13.jsxs)("g", { transform: "translate(1 1)", strokeWidth: "2", children: [
      (0, import_jsx_runtime13.jsx)(
        "circle",
        {
          ...secondaryColor ? { stroke: secondaryColor } : { strokeOpacity: ".5" },
          cx: "18",
          cy: "18",
          r: "18"
        }
      ),
      (0, import_jsx_runtime13.jsx)("path", { d: "M36 18c0-9.94-8.06-18-18-18", children: (0, import_jsx_runtime13.jsx)(
        "animateTransform",
        {
          attributeName: "transform",
          type: "rotate",
          from: "0 18 18",
          to: "360 18 18",
          dur: duration,
          repeatCount: "indefinite"
        }
      ) })
    ] }) }) });
  }
);

// node_modules/@yamada-ui/loading/dist/chunk-2TR7W6MO.mjs
var import_react15 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var Loading = forwardRef22((props2, ref) => {
  const [
    { color: color2, ...styles2 },
    { variant = "oval", size = "1em", ...mergedProps }
  ] = useComponentStyle("Loading", props2);
  const {
    className,
    color: colorProp,
    secondaryColor,
    dur,
    duration,
    ...rest
  } = omitThemeProps(mergedProps);
  const computedProps = (0, import_react15.useMemo)(
    () => ({
      className: cx("ui-loading", className),
      size,
      var: [
        {
          name: "color",
          token: "colors",
          value: colorProp != null ? colorProp : color2
        },
        {
          name: "secondary-color",
          token: "colors",
          value: secondaryColor
        }
      ],
      color: "$color",
      ...secondaryColor ? { secondaryColor: "$secondary-color" } : {},
      duration: duration != null ? duration : dur,
      __css: { ...styles2 },
      ...rest
    }),
    [
      className,
      size,
      colorProp,
      color2,
      secondaryColor,
      duration,
      dur,
      styles2,
      rest
    ]
  );
  switch (variant) {
    case "grid":
      return (0, import_jsx_runtime14.jsx)(Grid, { ref, ...computedProps });
    case "audio":
      return (0, import_jsx_runtime14.jsx)(Audio, { ref, ...computedProps });
    case "dots":
      return (0, import_jsx_runtime14.jsx)(Dots, { ref, ...computedProps });
    case "puff":
      return (0, import_jsx_runtime14.jsx)(Puff, { ref, ...computedProps });
    case "rings":
      return (0, import_jsx_runtime14.jsx)(Rings, { ref, ...computedProps });
    case "circles":
      return (0, import_jsx_runtime14.jsx)(Circles, { ref, ...computedProps });
    default:
      return (0, import_jsx_runtime14.jsx)(Oval, { ref, ...computedProps });
  }
});

// node_modules/@yamada-ui/motion/dist/chunk-ZSIGLH6W.mjs
var React7 = __toESM(require_react(), 1);
var motionForwardRef = (component) => {
  return React7.forwardRef(component);
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/index.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react16 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react16.createContext)({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react17 = __toESM(require_react(), 1);
var MotionContext = (0, import_react17.createContext)({});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react18 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react18.createContext)(null);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser3 = typeof window !== "undefined";

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser3 ? import_react19.useLayoutEffect : import_react19.useEffect;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react20 = __toESM(require_react(), 1);
var LazyContext = (0, import_react20.createContext)({ strict: false });

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId";
var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs
var MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/render-step.mjs
function createRenderStep(runNextFrame2) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame2();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      nextFrame.clear();
      thisFrame.forEach(triggerCallback);
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/batcher.mjs
var stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame2 = false;
  let useDefaultElapsed2 = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame2 = true;
  const steps3 = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { read: read2, resolveKeyframes, update, preRender, render, postRender } = steps3;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame2 = false;
    state.delta = useDefaultElapsed2 ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    read2.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame2 && allowKeepAlive) {
      useDefaultElapsed2 = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame2 = true;
    useDefaultElapsed2 = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps3[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame2)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps3[stepsOrder[i]].cancel(process2);
    }
  };
  return { schedule, cancel, state, steps: steps3 };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/microtask.mjs
var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject2(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react21 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react21.createContext)({});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var scheduleHandoffComplete = false;
function useVisualElement(Component3, visualState, props2, createVisualElement2, ProjectionNodeConstructor) {
  var _a;
  const { visualElement: parent } = (0, import_react22.useContext)(MotionContext);
  const lazyContext = (0, import_react22.useContext)(LazyContext);
  const presenceContext = (0, import_react22.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react22.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react22.useRef)();
  createVisualElement2 = createVisualElement2 || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement2) {
    visualElementRef.current = createVisualElement2(Component3, {
      visualState,
      parent,
      props: props2,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = (0, import_react22.useContext)(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props2, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  (0, import_react22.useInsertionEffect)(() => {
    visualElement && visualElement.update(props2, presenceContext);
  });
  const optimisedAppearId = props2[optimizedAppearDataAttribute];
  const wantsHandoff = (0, import_react22.useRef)(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete && ((_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react22.useEffect)(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    wantsHandoff.current = false;
    if (!scheduleHandoffComplete) {
      scheduleHandoffComplete = true;
      queueMicrotask(completeHandoff);
    }
  });
  return visualElement;
}
function completeHandoff() {
  window.MotionHandoffIsComplete = true;
}
function createProjectionNode(visualElement, props2, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props2;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props2["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject2(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react23 = __toESM(require_react(), 1);
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react23.useCallback)(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject2(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
var variantProps = ["initial", ...variantPriorityOrder];

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props2) {
  return isAnimationControls(props2.animate) || variantProps.some((name) => isVariantLabel(props2[name]));
}
function isVariantNode(props2) {
  return Boolean(isControllingVariants(props2) || props2.variants);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props2, context) {
  if (isControllingVariants(props2)) {
    const { initial, animate: animate2 } = props2;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props2.inherit !== false ? context : {};
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props2) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props2, (0, import_react24.useContext)(MotionContext));
  return (0, import_react24.useMemo)(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
var featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props2) => featureProps[key].some((name) => !!props2[name])
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react25 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react25.createContext)({});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/noop.mjs
var noop2 = (any2) => any2;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/errors.mjs
var warning = noop2;
var invariant = noop2;
if (true) {
  warning = (check, message) => {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = (check, message) => {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement: createVisualElement2, useRender, useVisualState: useVisualState2, Component: Component3 }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props2, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...(0, import_react26.useContext)(MotionConfigContext),
      ...props2,
      layoutId: useLayoutId(props2)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props2);
    const visualState = useVisualState2(props2, isStatic);
    if (!isStatic && isBrowser3) {
      useStrictMode(configAndProps, preloadedFeatures2);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement2, layoutProjection.ProjectionNode);
    }
    return (0, import_jsx_runtime15.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime15.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props2, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  const ForwardRefComponent = (0, import_react26.forwardRef)(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component3;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react26.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures2) {
  const isStrict = (0, import_react26.useContext)(LazyContext).strict;
  if (preloadedFeatures2 && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
  }
}
function getProjectionFunctionality(props2) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props2)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props2)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
function createMotionProxy(createConfig) {
  function custom(Component3, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component3, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component3) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component3 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component3.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component3) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component3)
  ) {
    return true;
  }
  return false;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react29 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react27 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = new Set(transformPropOrder);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = (value) => Boolean(value && value.getVelocity);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/clamp.mjs
var clamp = (min2, max2, v) => {
  if (v > max2)
    return max2;
  if (v < min2)
    return min2;
  return v;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
};
var scale = {
  ...number,
  default: 1
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/utils.mjs
var sanitize = (v) => Math.round(v * 1e5) / 1e5;
var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function isString2(v) {
  return typeof v === "string";
}
function isNullish(v) {
  return v == null;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v) => isString2(v) && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int = {
  ...number,
  transform: Math.round
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  backgroundPositionX: px,
  backgroundPositionY: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform3, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform3[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform3, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
var checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
var isCSSVariableName = checkStringStartsWith("--");
var startsAsVariableToken = checkStringStartsWith("var(--");
var isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props2) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props2)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return (0, import_react27.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props2, visualState) {
  const styleProp = props2.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props2);
  Object.assign(style, useInitialMotionValues(props2, visualState));
  return style;
}
function useHTMLProps(props2, visualState) {
  const htmlProps = {};
  const style = useStyle(props2, visualState);
  if (props2.drag && props2.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props2.drag === true ? "none" : `pan-${props2.drag === "x" ? "y" : "x"}`;
  }
  if (props2.tabIndex === void 0 && (props2.onTap || props2.onTapStart || props2.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp((init_emotion_is_prop_valid_esm(), __toCommonJS(emotion_is_prop_valid_esm_exports)).default);
} catch (_a) {
}
function filterProps(props2, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props2) {
    if (key === "values" && typeof props2.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props2["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props2[key];
    }
  }
  return filteredProps;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react28 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset2, size) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props2, visualState, _isStatic, Component3) {
  const visualProps = (0, import_react28.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component3), props2.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props2.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props2.style, props2);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component3, props2, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props2, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props2, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react29.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props2;
    const renderedChildren = (0, import_react29.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react29.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
  var _a;
  const { style } = props2;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props2) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  if (visualElement && style && typeof style.willChange === "string") {
    visualElement.applyWillChange = false;
  }
  return newValues;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props2, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps(props2, prevProps, visualElement);
  for (const key in props2) {
    if (isMotionValue(props2[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props2[key];
    }
  }
  return newValues;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react31 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props2, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props2.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props2.variants && props2.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props2.custom, current, velocity);
  }
  return definition;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react30 = __toESM(require_react(), 1);
function useConstant(init) {
  const ref = (0, import_react30.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = (v) => {
  return Array.isArray(v);
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = (v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = (v) => {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs
var acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-will-change/get-will-change-name.mjs
function getWillChangeName(name) {
  if (transformProps.has(name)) {
    return "transform";
  } else if (acceleratedValues.has(name)) {
    return camelToDash(name);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/array.mjs
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
function moveItem([...arr], fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item] = arr.splice(fromIndex, 1);
    arr.splice(endIndex, 0, item);
  }
  return arr;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState({ applyWillChange = false, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props2, context, presenceContext, isStatic) {
  const state = {
    latestValues: makeLatestValues(props2, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props2, instance, state);
  }
  return state;
}
var makeUseVisualState = (config2) => (props2, isStatic) => {
  const context = (0, import_react31.useContext)(MotionContext);
  const presenceContext = (0, import_react31.useContext)(PresenceContext);
  const make = () => makeState(config2, props2, context, presenceContext, isStatic);
  return isStatic ? make() : useConstant(make);
};
function addWillChange(willChange, name) {
  const memberName = getWillChangeName(name);
  if (memberName) {
    addUniqueItem(willChange, memberName);
  }
}
function forEachDefinition(props2, definition, callback) {
  const list = Array.isArray(definition) ? definition : [definition];
  for (let i = 0; i < list.length; i++) {
    const resolved = resolveVariantFromProps(props2, list[i]);
    if (resolved) {
      const { transitionEnd, transition, ...target } = resolved;
      callback(target, transitionEnd);
    }
  }
}
function makeLatestValues(props2, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {
  var _a;
  const values = {};
  const willChange = [];
  const applyWillChange = shouldApplyWillChange && ((_a = props2.style) === null || _a === void 0 ? void 0 : _a.willChange) === void 0;
  const motionValues = scrapeMotionValues(props2, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate2 } = props2;
  const isControllingVariants$1 = isControllingVariants(props2);
  const isVariantNode$1 = isVariantNode(props2);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props2.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    forEachDefinition(props2, variantToSet, (target, transitionEnd) => {
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd) {
        values[key] = transitionEnd[key];
      }
    });
  }
  if (applyWillChange) {
    if (animate2 && initial !== false && !isAnimationControls(animate2)) {
      forEachDefinition(props2, animate2, (target) => {
        for (const key in target) {
          addWillChange(willChange, key);
        }
      });
    }
    if (willChange.length) {
      values.willChange = willChange.join(",");
    }
  }
  return values;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/frame.mjs
var { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop2, true);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props2, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props2.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    applyWillChange: true,
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component3, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement2) {
  const baseConfig = isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement: createVisualElement2,
    Component: Component3
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/events/add-dom-event.mjs
function addDomEvent2(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs
var isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/events/event-info.mjs
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[`${pointType}X`],
      y: event[`${pointType}Y`]
    }
  };
}
var addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
function addPointerEvent2(target, eventName, handler, options) {
  return addDomEvent2(target, eventName, addPointerInfo(handler), options);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/pipe.mjs
var combineFunctions2 = (a, b) => (v) => b(a(v));
var pipe2 = (...transformers) => transformers.reduce(combineFunctions2);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/Feature.mjs
var Feature = class {
  constructor(node3) {
    this.isMounted = false;
    this.node = node3;
  }
  update() {
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/hover.mjs
function addHoverEvent(node3, isActive) {
  const eventName = isActive ? "pointerenter" : "pointerleave";
  const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
  const handleEvent = (event, info) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    const props2 = node3.getProps();
    if (node3.animationState && props2.whileHover) {
      node3.animationState.setActive("whileHover", isActive);
    }
    const callback = props2[callbackName];
    if (callback) {
      frame.postRender(() => callback(event, info));
    }
  };
  return addPointerEvent2(node3.current, eventName, handleEvent, {
    passive: !node3.getProps()[callbackName]
  });
}
var HoverGesture = class extends Feature {
  mount() {
    this.unmount = pipe2(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/focus.mjs
var FocusGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible2 = false;
    try {
      isFocusVisible2 = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible2 = true;
    }
    if (!isFocusVisible2 || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe2(addDomEvent2(this.node.current, "focus", () => this.onFocus()), addDomEvent2(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/press.mjs
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
var PressGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop2;
    this.removeEndListeners = noop2;
    this.removeAccessibleListeners = noop2;
    this.startPointerPress = (startEvent, startInfo) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const props2 = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
        const handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
        if (handler) {
          frame.update(() => handler(endEvent, endInfo));
        }
      };
      const removePointerUpListener = addPointerEvent2(window, "pointerup", endPointerPress, {
        passive: !(props2.onTap || props2["onPointerUp"])
      });
      const removePointerCancelListener = addPointerEvent2(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
        passive: !(props2.onTapCancel || props2["onPointerCancel"])
      });
      this.removeEndListeners = pipe2(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.postRender(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent2(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent2(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent2(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe2(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.postRender(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props2 = this.node.getProps();
    if (props2.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.postRender(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props2 = this.node.getProps();
    const removePointerListener = addPointerEvent2(props2.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(props2.onTapStart || props2["onPointerStart"])
    });
    const removeFocusListener = addDomEvent2(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe2(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
var fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
var thresholdNames = {
  some: 0,
  all: 1
};
var InViewFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport: viewport2 = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport2;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props: props2, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props2, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport2[name] !== prevViewport[name];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev2[i] !== next2[i])
      return false;
  }
  return true;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
function resolveVariant(visualElement, definition, custom) {
  const props2 = visualElement.getProps();
  return resolveVariantFromProps(props2, definition, custom !== void 0 ? custom : props2.custom, visualElement);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/time-conversion.mjs
var secondsToMilliseconds = (seconds) => seconds * 1e3;
var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
var criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
var keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
var ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
var getDefaultTransition = (valueKey, { keyframes: keyframes6 }) => {
  if (keyframes6.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes6[1]) : underDampedSpring;
  }
  return ease;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: false
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
var isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes6, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes6.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/sync-time.mjs
var now;
function clearTime() {
  now = void 0;
}
var time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/is-none.mjs
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
var splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
var isNumOrPxType = (v) => v === number || v === px;
var getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
var getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform3 }) => {
  if (transform3 === "none" || !transform3)
    return 0;
  const matrix3d = transform3.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform3.match(/^matrix\((.+)\)$/u);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top2 }) => parseFloat(top2),
  left: (_bbox, { left: left2 }) => parseFloat(left2),
  bottom: ({ y }, { top: top2 }) => parseFloat(top2) + (y.max - y.min),
  right: ({ x }, { left: left2 }) => parseFloat(left2) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = (v) => (type) => type.test(v);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: (v) => v === "auto",
  parse: (v) => v
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs
var toResolve = /* @__PURE__ */ new Set();
var isScheduled = false;
var anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a;
          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete());
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
var KeyframeResolver = class {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.isComplete = false;
    this.isAsync = false;
    this.needsMeasurement = false;
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null) {
        if (i === 0) {
          const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
        }
      }
    }
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete)
      this.scheduleResolve();
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/color/utils.mjs
var isColorString = (type, testProp) => (v) => {
  return Boolean(isString2(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
};
var splitColor = (aName, bName, cName) => (v) => {
  if (!isString2(v))
    return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
var clampRgbUnit = (v) => clamp(0, 255, v);
var rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
};
var rgba2 = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/color/hex.mjs
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r2 = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r2 = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r2 += r2;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba2.transform
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
var hsla2 = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/color/index.mjs
var color = {
  test: (v) => rgba2.test(v) || hex.test(v) || hsla2.test(v),
  parse: (v) => {
    if (rgba2.test(v)) {
      return rgba2.parse(v);
    } else if (hsla2.test(v)) {
      return hsla2.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return isString2(v) ? v : v.hasOwnProperty("red") ? rgba2.transform(v) : hsla2.transform(v);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/complex/index.mjs
function test(v) {
  var _a, _b;
  return isNaN(v) && isString2(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
var NUMBER_TOKEN = "number";
var COLOR_TOKEN = "color";
var VAR_TOKEN = "var";
var VAR_FUNCTION_TOKEN = "var(";
var SPLIT_TOKEN = "${}";
var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
var filter2 = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter2,
  WebkitFilter: filter2
};
var getDefaultValueType = (key) => defaultValueTypes[key];

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter2)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs
var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
    }
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs
var DOMKeyframesResolver = class extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.owner, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element.current)
      return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a;
    const { element, name, unresolvedKeyframes } = this;
    if (!element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/memo.mjs
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs
function hasKeyframesChanged(keyframes6) {
  const current = keyframes6[0];
  if (keyframes6.length === 1)
    return true;
  for (let i = 0; i < keyframes6.length; i++) {
    if (keyframes6[i] !== current)
      return true;
  }
}
function canAnimate(keyframes6, name, type, velocity) {
  const originKeyframe = keyframes6[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes6[keyframes6.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes6) || type === "spring" && velocity;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs
var BaseAnimation = class {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes6, finalKeyframe) {
    this.hasAttemptedResolve = true;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator } = this.options;
    if (!isGenerator && !canAnimate(keyframes6, name, type, velocity)) {
      if (instantAnimationState.current || !delay2) {
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes6, this.options, finalKeyframe));
        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
        this.resolveFinishedPromise();
        return;
      } else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes6, finalKeyframe);
    if (resolvedAnimation === false)
      return;
    this._resolved = {
      keyframes: keyframes6,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes6, restDelta, restSpeed, ...options }) {
  const origin = keyframes6[0];
  const target = keyframes6[keyframes6.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0;
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
function inertia({ keyframes: keyframes6, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes6[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
  const nearestBoundary = (v) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop2;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/ease.mjs
var easeIn = cubicBezier(0.42, 0, 1, 1);
var easeOut = cubicBezier(0, 0, 0.58, 1);
var easeInOut = cubicBezier(0.42, 0, 0.58, 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
var isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/circ.mjs
var circIn = (p) => 1 - Math.sin(Math.acos(p));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circIn);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/back.mjs
var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
var backIn = reverseEasing(backOut);
var backInOut = mirrorEasing(backIn);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/anticipate.mjs
var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/utils/map.mjs
var easingLookup = {
  linear: noop2,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
var easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/progress.mjs
var progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/number.mjs
var mixNumber = (from2, to, progress2) => {
  return from2 + (to - from2) * progress2;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/immediate.mjs
function mixImmediate(a, b) {
  return (p) => p > 0 ? b : a;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/color.mjs
var mixLinearColor = (from2, to, v) => {
  const fromExpo = from2 * from2;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
var colorTypes = [hex, rgba2, hsla2];
var getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla2) {
    model = hslaToRgba(model);
  }
  return model;
}
var mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from2, to);
  }
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba2.transform(blended);
  };
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/visibility.mjs
var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p) => p <= 0 ? origin : target;
  } else {
    return (p) => p >= 1 ? target : origin;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/complex.mjs
function mixNumber2(a, b) {
  return (p) => mixNumber(a, b, p);
}
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber2;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
function mixObject(a, b) {
  const output = { ...a, ...b };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  var _a;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe2(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin, target);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/mix/index.mjs
function mix2(from2, to, p) {
  if (typeof from2 === "number" && typeof to === "number" && typeof p === "number") {
    return mixNumber(from2, to, p);
  }
  const mixer = getMixer(from2);
  return mixer(from2, to);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/interpolate.mjs
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix2;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop2 : ease2;
      mixer = pipe2(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && input[0] === input[1])
    return () => output[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset2.push(mixNumber(min2, 1, offsetProgress));
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/offsets/default.mjs
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/offsets/time.mjs
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes5({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t) => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs
var maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs
var frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs
var generators = {
  decay: inertia,
  inertia,
  tween: keyframes5,
  keyframes: keyframes5,
  spring
};
var percentToProgress = (percent2) => percent2 / 100;
var MainThreadAnimation = class extends BaseAnimation {
  constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {
    super(options);
    this.holdTime = null;
    this.startTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, keyframes: keyframes6 } = this.options;
    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    if (name && motionValue2 && motionValue2.owner) {
      this.resolver = motionValue2.owner.resolveKeyframes(keyframes6, onResolved, name, motionValue2);
    } else {
      this.resolver = new KeyframeResolver$1(keyframes6, onResolved, name, motionValue2);
    }
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = generators[type] || keyframes5;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes5 && typeof keyframes$1[0] !== "number") {
      if (true) {
        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
      }
      mapPercentToKeyframes = pipe2(percentToProgress, mix2(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes7 } = this.options;
      return { done: true, value: keyframes7[keyframes7.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes6, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes6[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes6, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now2 = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime || this.state === "finished") {
      this.startTime = now2;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time2) {
    this.startTime = 0;
    return this.tick(time2, true);
  }
};
function animateValue(options) {
  return new MainThreadAnimation(options);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs
var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && easing in supportedWaapiEasing || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
var supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasingWithDefault(easing) {
  return mapEasingToNativeEasing(easing) || supportedWaapiEasing.easeOut;
}
function mapEasingToNativeEasing(easing) {
  if (!easing) {
    return void 0;
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map(mapEasingToNativeEasingWithDefault);
  } else {
    return supportedWaapiEasing[easing];
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
function animateStyle(element, valueName, keyframes6, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes6 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs
var supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
var sampleDelta = 10;
var maxDuration2 = 2e4;
function requiresPregeneratedKeyframes(options) {
  return options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes6, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes6,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes6[0] };
  const pregeneratedKeyframes = [];
  let t = 0;
  while (!state.done && t < maxDuration2) {
    state = sampleAnimation.sample(t);
    pregeneratedKeyframes.push(state.value);
    t += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t - sampleDelta,
    ease: "linear"
  };
}
var AcceleratedAnimation = class extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, keyframes: keyframes6 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes6, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes6, finalKeyframe) {
    var _a;
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name } = this.options;
    if (!((_a = motionValue2.owner) === null || _a === void 0 ? void 0 : _a.current)) {
      return false;
    }
    if (requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, ...options } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes6, options);
      keyframes6 = pregeneratedAnimation.keyframes;
      if (keyframes6.length === 1) {
        keyframes6[1] = keyframes6[0];
      }
      duration = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease2 = pregeneratedAnimation.ease;
      type = "keyframes";
    }
    const animation2 = animateStyle(motionValue2.owner.current, name, keyframes6, { ...this.options, duration, times, ease: ease2 });
    animation2.startTime = time.now();
    if (this.pendingTimeline) {
      animation2.timeline = this.pendingTimeline;
      this.pendingTimeline = void 0;
    } else {
      animation2.onfinish = () => {
        const { onComplete } = this.options;
        motionValue2.set(getFinalKeyframe(keyframes6, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation: animation2,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes6
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation: animation2 } = resolved;
    return millisecondsToSeconds(animation2.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation: animation2 } = resolved;
    animation2.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation: animation2 } = resolved;
    return animation2.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation: animation2 } = resolved;
    animation2.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation: animation2 } = resolved;
    return animation2.playState;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const { resolved } = this;
      if (!resolved)
        return noop2;
      const { animation: animation2 } = resolved;
      animation2.timeline = timeline;
      animation2.onfinish = null;
    }
    return noop2;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation: animation2 } = resolved;
    if (animation2.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation2.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation: animation2 } = resolved;
    animation2.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle")
      return;
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation: animation2, keyframes: keyframes6, duration, type, ease: ease2, times } = resolved;
    if (animation2.playState === "idle" || animation2.playState === "finished") {
      return;
    }
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, ...options } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes6,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: true
      });
      const sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop();
    this.cancel();
  }
  complete() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/observe.mjs
function observeTimeline(update, timeline) {
  let prevProgress;
  const onFrame = () => {
    const { currentTime } = timeline;
    const percentage = currentTime === null ? 0 : currentTime.value;
    const progress2 = percentage / 100;
    if (prevProgress !== progress2) {
      update(progress2);
    }
    prevProgress = progress2;
  };
  frame.update(onFrame, true);
  return () => cancelFrame(onFrame);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/supports.mjs
var supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs
var GroupPlaybackControls = class {
  constructor(animations3) {
    this.stop = () => this.runAll("stop");
    this.animations = animations3.filter(Boolean);
  }
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline) {
    const cancelAll = this.animations.map((animation2) => {
      if (supportsScrollTimeline() && animation2.attachTimeline) {
        animation2.attachTimeline(timeline);
      } else {
        animation2.pause();
        return observeTimeline((progress2) => {
          animation2.time = animation2.duration * progress2;
        }, timeline);
      }
    });
    return () => {
      cancelAll.forEach((cancelTimeline, i) => {
        if (cancelTimeline)
          cancelTimeline();
        this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get duration() {
    let max2 = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max2 = Math.max(max2, this.animations[i].duration);
    }
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
var animateMotionValue = (name, value, target, transition = {}, element, isHandoff, onEnd) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
      onEnd && onEnd();
    },
    onStop: onEnd,
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return new GroupPlaybackControls([]);
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/index.mjs
var MAX_VELOCITY_DELTA = 30;
var isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
var collectMotionValues = {
  current: void 0
};
var MotionValue = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "11.3.24";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (true) {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev2;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
function motionValue(init, options) {
  return new MotionValue(init, options);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
function getOptimisedAppearId(visualElement) {
  return visualElement.getProps()[optimizedAppearDataAttribute];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-will-change/WillChangeMotionValue.mjs
var WillChangeMotionValue = class extends MotionValue {
  constructor() {
    super(...arguments);
    this.output = [];
    this.counts = /* @__PURE__ */ new Map();
  }
  add(name) {
    const styleName = getWillChangeName(name);
    if (!styleName)
      return;
    const prevCount = this.counts.get(styleName) || 0;
    this.counts.set(styleName, prevCount + 1);
    if (prevCount === 0) {
      this.output.push(styleName);
      this.update();
    }
    let hasRemoved = false;
    return () => {
      if (hasRemoved)
        return;
      hasRemoved = true;
      const newCount = this.counts.get(styleName) - 1;
      this.counts.set(styleName, newCount);
      if (newCount === 0) {
        removeItem(this.output, styleName);
        this.update();
      }
    };
  }
  update() {
    this.set(this.output.length ? this.output.join(", ") : "auto");
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
function addValueToWillChange(visualElement, key) {
  var _a;
  if (!visualElement.applyWillChange)
    return;
  let willChange = visualElement.getValue("willChange");
  if (!willChange && !((_a = visualElement.props.style) === null || _a === void 0 ? void 0 : _a.willChange)) {
    willChange = new WillChangeMotionValue("auto");
    visualElement.addValue("willChange", willChange);
  }
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations3 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      elapsed: 0,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const elapsed = window.MotionHandoffAnimation(appearId, key, frame);
        if (elapsed !== null) {
          valueTransition.elapsed = elapsed;
          isHandoff = true;
        }
      }
    }
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition, visualElement, isHandoff, addValueToWillChange(visualElement, key)));
    const animation2 = value.animation;
    if (animation2) {
      animations3.push(animation2);
    }
  }
  if (transitionEnd) {
    Promise.all(animations3).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations3;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations3 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations3.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations3);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation2;
  if (Array.isArray(definition)) {
    const animations3 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation2 = Promise.all(animations3);
  } else if (typeof definition === "string") {
    animation2 = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation2 = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation2.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var reversePriorityOrder = [...variantPriorityOrder].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations3) => Promise.all(animations3.map(({ animation: animation2, options }) => animateVisualElement(visualElement, animation2, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const props2 = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations3 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props2[type] !== void 0 ? props2[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props2[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next2 = resolvedValues[key];
        const prev2 = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
          valueHasChanged = !shallowCompare(next2, prev2);
        } else {
          valueHasChanged = next2 !== prev2;
        }
        if (valueHasChanged) {
          if (next2 !== void 0 && next2 !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next2 !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
        animations3.push(...definitionList.map((animation2) => ({
          animation: animation2,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations3.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations3.length);
    if (isInitialRender && (props2.initial === false || props2.initial === props2.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations3) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations3 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations3;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
var AnimationFeature = class extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node3) {
    super(node3);
    node3.animationState || (node3.animationState = createAnimationState(node3));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    if (isAnimationControls(animate2)) {
      this.unmountControls = animate2.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate2 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    this.node.animationState.reset();
    (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
var id = 0;
var ExitAnimationFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: isPresent2, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent2 === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent2);
    if (onExitComplete && !isPresent2) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/distance.mjs
var distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
var PanSession = class {
  constructor(event, handlers2, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers2;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point2 } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers2;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe2(addPointerEvent2(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent2(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent2(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers2) {
    this.handlers = handlers2;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
};
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
var SCALE_PRECISION = 1e-4;
var SCALE_MIN = 1 - SCALE_PRECISION;
var SCALE_MAX = 1 + SCALE_PRECISION;
var TRANSLATE_PRECISION = 0.01;
var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point2 < min2) {
    point2 = elastic ? mixNumber(min2, point2, elastic.min) : Math.max(point2, min2);
  } else if (max2 !== void 0 && point2 > max2) {
    point2 = elastic ? mixNumber(max2, point2, elastic.max) : Math.min(point2, max2);
  }
  return point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
var createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
var createAxis = () => ({ min: 0, max: 0 });
var createBox = () => ({
  x: createAxis(),
  y: createAxis()
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
  return {
    x: { min: left2, max: right2 },
    y: { min: top2, max: bottom2 }
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top });
  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, boxScale, originPoint);
  }
  return scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
var TREE_SCALE_SNAP_MIN = 0.999999999999;
var TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node3;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node3 = treePath[i];
    delta = node3.projectionDelta;
    const { visualElement } = node3.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node3.options.layoutScroll && node3.scroll && node3 !== node3.root) {
      transformBox(box, {
        x: -node3.scroll.offset.x,
        y: -node3.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node3.latestValues)) {
      transformBox(box, node3.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance3) {
  axis.min = axis.min + distance3;
  axis.max = axis.max + distance3;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform3) {
  transformAxis(box.x, transform3.x, transform3.scaleX, transform3.scale, transform3.originX);
  transformAxis(box.y, transform3.y, transform3.scaleY, transform3.scale, transform3.originY);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/get-context-window.mjs
var getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = class {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      var _a;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      (_a = this.removeWillChange) === null || _a === void 0 ? void 0 : _a.call(this);
      this.removeWillChange = addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis((axis) => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
    });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    var _a;
    (_a = this.removeWillChange) === null || _a === void 0 ? void 0 : _a.call(this);
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject2(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject2(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false, addValueToWillChange(this.visualElement, axis)));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props2 = this.visualElement.getProps();
    const externalMotionValue = props2[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props2.initial ? props2.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject2(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent2(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject2(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent2(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props2 = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props2;
    return {
      ...props2,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/drag/index.mjs
var DragGesture = class extends Feature {
  constructor(node3) {
    super(node3);
    this.removeGroupControls = noop2;
    this.removeListeners = noop2;
    this.controls = new VisualElementDragControls(node3);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop2;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/pan/index.mjs
var asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
var PanGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop2;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent2(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react32 = __toESM(require_react(), 1);
function usePresence() {
  const context = (0, import_react32.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent: isPresent2, onExitComplete, register } = context;
  const id4 = (0, import_react32.useId)();
  (0, import_react32.useEffect)(() => register(id4), []);
  const safeToRemove = (0, import_react32.useCallback)(() => onExitComplete && onExitComplete(id4), [id4, onExitComplete]);
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent((0, import_react32.useContext)(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: (latest, node3) => {
    if (!node3.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node3.target.x);
    const y = pixelsToPercent(latest, node3.target.y);
    return `${x}% ${y}%`;
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template(shadow);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = class extends import_react33.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
function MeasureLayout(props2) {
  const [isPresent2, safeToRemove] = usePresence();
  const layoutGroup = (0, import_react33.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime16.jsx)(MeasureLayoutWithContext, { ...props2, layoutGroup, switchLayoutGroup: (0, import_react33.useContext)(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
}
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
var isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, noop2);
function compress(min2, max2, easing) {
  return (p) => {
    if (p < min2)
      return 0;
    if (p > max2)
      return 1;
    return easing(progress(min2, max2, p));
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  point2 -= translate;
  point2 = scalePoint(point2, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, 1 / boxScale, originPoint);
  }
  return point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms3, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms3[key], transforms3[scaleKey], transforms3[originKey], transforms3.scale, origin, sourceAxis);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms3, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms3, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms3, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node3) {
    addUniqueItem(this.members, node3);
    node3.scheduleRender();
  }
  remove(node3) {
    removeItem(this.members, node3);
    if (node3 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node3 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node3) {
    const indexOfNode = this.members.findIndex((member) => node3 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node3, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node3 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node3;
    node3.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node3.scheduleRender();
      node3.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node3.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node3.snapshot = prevLead.snapshot;
        node3.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node3.root && node3.root.isUpdating) {
        node3.isLayoutDirty = true;
      }
      const { crossfade } = node3.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node3) => {
      const { options, resumingFrom } = node3;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node3) => {
      node3.instance && node3.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/styles/transform.mjs
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform3 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform3 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform3 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform3 = `perspective(${transformPerspective}px) ${transform3}`;
    if (rotate)
      transform3 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform3 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform3 += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform3 += `skewX(${skewX}deg) `;
    if (skewY)
      transform3 += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform3 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform3 || "none";
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = (a, b) => a.depth - b.depth;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = class {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/delay.mjs
function delay(callback, timeout) {
  const start2 = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs
function animateSingleValue(value, keyframes6, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes6, options));
  return motionValue$1.animation;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
var isDebug = typeof window !== "undefined" && window.MotionDebug !== void 0;
var transformAxes = ["", "X", "Y", "Z"];
var hiddenVisibility = { visibility: "hidden" };
var animationTarget = 1e3;
var id2 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function isOptimisedTransformAnimationInTree(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return false;
  const { visualElement } = projectionNode.options;
  if (!visualElement) {
    return false;
  } else if (window.MotionHasOptimisedTransformAnimation(getOptimisedAppearId(visualElement))) {
    return true;
  } else if (projectionNode.parent && !projectionNode.parent.hasCheckedOptimisedAppear) {
    return isOptimisedTransformAnimationInTree(projectionNode.parent);
  } else {
    return false;
  }
}
function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (isDebug) {
          metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (isDebug) {
          window.MotionDebug.record(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionHandoffCancelAll && isOptimisedTransformAnimationInTree(this)) {
        window.MotionHandoffCancelAll();
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node3 = this.path[i];
        node3.shouldResetTransform = true;
        node3.updateScroll("snapshot");
        if (node3.options.layoutRoot) {
          node3.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node3 = this.path[i];
          node3.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll: scroll2 } = this.root;
        if (scroll2) {
          translateAxis(box.x, scroll2.offset.x);
          translateAxis(box.y, scroll2.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node3 = this.path[i];
        const { scroll: scroll2, options } = node3;
        if (node3 !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node3 = this.path[i];
        if (!transformOnly && node3.options.layoutScroll && node3.scroll && node3 !== node3.root) {
          transformBox(withTransforms, {
            x: -node3.scroll.offset.x,
            y: -node3.scroll.offset.y
          });
        }
        if (!hasTransform(node3.latestValues))
          continue;
        transformBox(withTransforms, node3.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node3 = this.path[i];
        if (!node3.instance)
          continue;
        if (!hasTransform(node3.latestValues))
          continue;
        hasScale(node3.latestValues) && node3.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node3.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node3.latestValues, node3.snapshot ? node3.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (isDebug) {
        metrics.resolvedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (isDebug) {
        metrics.recalculatedProjection++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll2 = true) {
      var _a;
      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
      if (notifyAll2) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node3) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node3);
      const config2 = node3.options.initialPromotionConfig;
      node3.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node3) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a, _b;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles2 = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles2.transform = transformTemplate(valuesToRender, styles2.transform);
      }
      const { x, y } = this.projectionDelta;
      styles2.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles2[applyTo[i]] = corrected;
          }
        } else {
          styles2[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node3) => {
        var _a;
        return (_a = node3.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node3) {
  node3.updateLayout();
}
function notifyLayoutUpdate(node3) {
  var _a;
  const snapshot = ((_a = node3.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node3.snapshot;
  if (node3.isLead() && node3.layout && snapshot && node3.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node3.layout;
    const { animationType } = node3.options;
    const isShared = snapshot.source !== node3.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node3.relativeTarget && !node3.currentAnimation) {
          node3.isProjectionDirty = true;
          node3.relativeTarget[axis].max = node3.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node3.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node3.resumeFrom) {
      const relativeParent = node3.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node3.relativeTarget = relativeLayout;
            node3.relativeTargetOrigin = relativeSnapshot;
            node3.relativeParent = relativeParent;
          }
        }
      }
    }
    node3.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node3.isLead()) {
    const { onExitComplete } = node3.options;
    onExitComplete && onExitComplete();
  }
  node3.options.transition = void 0;
}
function propagateDirtyNodes(node3) {
  if (isDebug) {
    metrics.totalNodes++;
  }
  if (!node3.parent)
    return;
  if (!node3.isProjecting()) {
    node3.isProjectionDirty = node3.parent.isProjectionDirty;
  }
  node3.isSharedProjectionDirty || (node3.isSharedProjectionDirty = Boolean(node3.isProjectionDirty || node3.parent.isProjectionDirty || node3.parent.isSharedProjectionDirty));
  node3.isTransformDirty || (node3.isTransformDirty = node3.parent.isTransformDirty);
}
function cleanDirtyNodes(node3) {
  node3.isProjectionDirty = node3.isSharedProjectionDirty = node3.isTransformDirty = false;
}
function clearSnapshot(node3) {
  node3.clearSnapshot();
}
function clearMeasurements(node3) {
  node3.clearMeasurements();
}
function clearIsLayoutDirty(node3) {
  node3.isLayoutDirty = false;
}
function resetTransformStyle(node3) {
  const { visualElement } = node3.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node3.resetTransform();
}
function finishAnimation(node3) {
  node3.finishAnimation();
  node3.targetDelta = node3.relativeTarget = node3.target = void 0;
  node3.isProjectionDirty = true;
}
function resolveTargetDelta(node3) {
  node3.resolveTargetDelta();
}
function calcProjection(node3) {
  node3.calcProjection();
}
function resetSkewAndRotation(node3) {
  node3.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber(delta.translate, 0, p);
  output.scale = mixNumber(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mixNumber(from2.min, to.min, p);
  output.max = mixNumber(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p);
  mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node3) {
  return node3.animationValues && node3.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
var userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2);
var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop2;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node3) {
  var _a;
  return node3 !== node3.root && ((_a = node3.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode2({
  attachResizeListener: (ref, notify2) => addDomEvent2(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode2({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var import_react34 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
var prefersReducedMotion = { current: null };
var hasReducedMotionListener = { current: false };

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser3)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next2, prev2) {
  for (const key in next2) {
    const nextValue = next2[key];
    const prevValue = prev2[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (true) {
        warnOnce(nextValue.version === "11.3.24", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.3.24 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev2) {
    if (next2[key] === void 0)
      element.removeValue(key);
  }
  return next2;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/store.mjs
var visualElementStore = /* @__PURE__ */ new WeakMap();

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = [...dimensionValueTypes, color, complex];
var findValueType = (v) => valueTypes.find(testValueType(v));

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/VisualElement.mjs
var propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
var numVariantProps = variantProps.length;
var VisualElement = class {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props: props2, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.applyWillChange = false;
    this.resolveKeyframes = (keyframes6, onComplete, name, value) => {
      return new this.KeyframeResolver(keyframes6, onComplete, name, value, this);
    };
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      this.isRenderScheduled = false;
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.isRenderScheduled = false;
    this.scheduleRender = () => {
      if (!this.isRenderScheduled) {
        this.isRenderScheduled = true;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props2.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props2;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props2);
    this.isVariantNode = isVariantNode(props2);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props2, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (true) {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    }
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props2, presenceContext) {
    if (props2.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props2;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props2[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props2, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = this.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone2(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
var DOMVisualElement = class extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props2, key) {
    return props2.style ? props2.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var HTMLVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.applyWillChange = true;
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle2(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props2) {
    buildHTMLStyles(renderState, latestValues, props2.transformTemplate);
  }
  scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props2, prevProps, visualElement);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
var SVGVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props2, key) {
    return props2[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
    return scrapeMotionValuesFromProps2(props2, prevProps, visualElement);
  }
  build(renderState, latestValues, props2) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props2.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = (Component3, options) => {
  return isSVGComponent(Component3) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component3 !== import_react34.Fragment
  });
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/features/layout.mjs
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/motion.mjs
var preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
var motion = createMotionProxy((Component3, config2) => createDomMotionConfig(Component3, config2, preloadedFeatures, createDomVisualElement));
function createDomMotionComponent(key) {
  return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, preloadedFeatures, createDomVisualElement));
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs
var m = createMotionProxy(createDomMotionConfig);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var React9 = __toESM(require_react(), 1);
var import_react36 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var React8 = __toESM(require_react(), 1);
var import_react35 = __toESM(require_react(), 1);
var PopChildMeasure = class extends React8.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function PopChild({ children, isPresent: isPresent2 }) {
  const id4 = (0, import_react35.useId)();
  const ref = (0, import_react35.useRef)(null);
  const size = (0, import_react35.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const { nonce: nonce2 } = (0, import_react35.useContext)(MotionConfigContext);
  (0, import_react35.useInsertionEffect)(() => {
    const { width, height, top: top2, left: left2 } = size.current;
    if (isPresent2 || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id4;
    const style = document.createElement("style");
    if (nonce2)
      style.nonce = nonce2;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id4}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top2}px !important;
            left: ${left2}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent2]);
  return (0, import_jsx_runtime17.jsx)(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size, children: React8.cloneElement(children, { ref }) });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode: mode2 }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id4 = (0, import_react36.useId)();
  const context = (0, import_react36.useMemo)(
    () => ({
      id: id4,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random()] : [isPresent2]
  );
  (0, import_react36.useMemo)(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent2]);
  React9.useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2]);
  if (mode2 === "popLayout") {
    children = (0, import_jsx_runtime18.jsx)(PopChild, { isPresent: isPresent2, children });
  }
  return (0, import_jsx_runtime18.jsx)(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs
var import_react37 = __toESM(require_react(), 1);
var getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  import_react37.Children.forEach(children, (child) => {
    if ((0, import_react37.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode: mode2 = "sync" }) => {
  invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
  const presentChildren = (0, import_react38.useMemo)(() => onlyElements(children), [children]);
  const presentKeys = presentChildren.map(getChildKey);
  const isInitialRender = (0, import_react38.useRef)(true);
  const pendingPresentChildren = (0, import_react38.useRef)(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = (0, import_react38.useState)(presentChildren);
  const [renderedChildren, setRenderedChildren] = (0, import_react38.useState)(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode2 === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return;
  }
  if (mode2 === "wait" && renderedChildren.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  const { forceRender } = (0, import_react38.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime19.jsx)(import_jsx_runtime19.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent2 = presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = () => {
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender === null || forceRender === void 0 ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        onExitComplete && onExitComplete();
      }
    };
    return (0, import_jsx_runtime19.jsx)(PresenceChild, { isPresent: isPresent2, initial: !isInitialRender.current || initial ? void 0 : false, custom: isPresent2 ? void 0 : custom, presenceAffectsLayout, mode: mode2, onExitComplete: isPresent2 ? void 0 : onExit, children: child }, key);
  }) });
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react39 = __toESM(require_react(), 1);
function MotionConfig({ children, isValidProp, ...config2 }) {
  isValidProp && loadExternalIsValidProp(isValidProp);
  config2 = { ...(0, import_react39.useContext)(MotionConfigContext), ...config2 };
  config2.isStatic = useConstant(() => config2.isStatic);
  const context = (0, import_react39.useMemo)(() => config2, [JSON.stringify(config2.transition), config2.transformPagePoint, config2.reducedMotion]);
  return (0, import_jsx_runtime20.jsx)(MotionConfigContext.Provider, { value: context, children });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
function LazyMotion({ children, features, strict = false }) {
  const [, setIsLoaded] = (0, import_react40.useState)(!isLazyBundle(features));
  const loadedRenderer = (0, import_react40.useRef)(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures);
  }
  (0, import_react40.useEffect)(() => {
    if (isLazyBundle(features)) {
      features().then(({ renderer, ...loadedFeatures }) => {
        loadFeatures(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(true);
      });
    }
  }, []);
  return (0, import_jsx_runtime21.jsx)(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children });
}
function isLazyBundle(features) {
  return typeof features === "function";
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs
var import_react41 = __toESM(require_react(), 1);
var DeprecatedLayoutGroupContext = (0, import_react41.createContext)(null);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-force-update.mjs
var import_react43 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react42 = __toESM(require_react(), 1);
function useIsMounted2() {
  const isMounted = (0, import_react42.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-force-update.mjs
function useForceUpdate() {
  const isMounted = useIsMounted2();
  const [forcedRenderCount, setForcedRenderCount] = (0, import_react43.useState)(0);
  const forceRender = (0, import_react43.useCallback)(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = (0, import_react43.useCallback)(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/node/group.mjs
var notify = (node3) => !node3.isLayoutDirty && node3.willUpdate(false);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new WeakMap();
  const dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node3) => {
      nodes.add(node3);
      subscriptions.set(node3, node3.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node3) => {
      nodes.delete(node3);
      const unsubscribe = subscriptions.get(node3);
      if (unsubscribe) {
        unsubscribe();
        subscriptions.delete(node3);
      }
      dirtyAll();
    },
    dirty: dirtyAll
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs
var shouldInheritGroup = (inherit) => inherit === true;
var shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === "id";
var LayoutGroup = ({ children, id: id4, inherit = true }) => {
  const layoutGroupContext = (0, import_react44.useContext)(LayoutGroupContext);
  const deprecatedLayoutGroupContext = (0, import_react44.useContext)(DeprecatedLayoutGroupContext);
  const [forceRender, key] = useForceUpdate();
  const context = (0, import_react44.useRef)(null);
  const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  if (context.current === null) {
    if (shouldInheritId(inherit) && upstreamId) {
      id4 = id4 ? upstreamId + "-" + id4 : upstreamId;
    }
    context.current = {
      id: id4,
      group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()
    };
  }
  const memoizedContext = (0, import_react44.useMemo)(() => ({ ...context.current, forceRender }), [key]);
  return (0, import_jsx_runtime22.jsx)(LayoutGroupContext.Provider, { value: memoizedContext, children });
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/context/ReorderContext.mjs
var import_react45 = __toESM(require_react(), 1);
var ReorderContext = (0, import_react45.createContext)(null);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs
function checkReorder(order2, value, offset2, velocity) {
  if (!velocity)
    return order2;
  const index = order2.findIndex((item2) => item2.value === value);
  if (index === -1)
    return order2;
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem = order2[index + nextOffset];
  if (!nextItem)
    return order2;
  const item = order2[index];
  const nextLayout = nextItem.layout;
  const nextItemCenter = mixNumber(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset2 > nextItemCenter || nextOffset === -1 && item.layout.min + offset2 < nextItemCenter) {
    return moveItem(order2, index, index + nextOffset);
  }
  return order2;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
function ReorderGroup({ children, as = "ul", axis = "y", onReorder, values, ...props2 }, externalRef) {
  const Component3 = useConstant(() => motion(as));
  const order2 = [];
  const isReordering = (0, import_react46.useRef)(false);
  invariant(Boolean(values), "Reorder.Group must be provided a values prop");
  const context = {
    axis,
    registerItem: (value, layout2) => {
      const idx = order2.findIndex((entry) => value === entry.value);
      if (idx !== -1) {
        order2[idx].layout = layout2[axis];
      } else {
        order2.push({ value, layout: layout2[axis] });
      }
      order2.sort(compareMin);
    },
    updateOrder: (item, offset2, velocity) => {
      if (isReordering.current)
        return;
      const newOrder = checkReorder(order2, item, offset2, velocity);
      if (order2 !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue2).filter((value) => values.indexOf(value) !== -1));
      }
    }
  };
  (0, import_react46.useEffect)(() => {
    isReordering.current = false;
  });
  return (0, import_jsx_runtime23.jsx)(Component3, { ...props2, ref: externalRef, ignoreStrict: true, children: (0, import_jsx_runtime23.jsx)(ReorderContext.Provider, { value: context, children }) });
}
var Group = (0, import_react46.forwardRef)(ReorderGroup);
function getValue2(item) {
  return item.value;
}
function compareMin(a, b) {
  return a.layout.min - b.layout.min;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-motion-value.mjs
var import_react47 = __toESM(require_react(), 1);
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  const { isStatic } = (0, import_react47.useContext)(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = (0, import_react47.useState)(initial);
    (0, import_react47.useEffect)(() => value.on("change", setLatest), []);
  }
  return value;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/transform.mjs
var isCustomValueType = (v) => {
  return v && typeof v === "object" && v.mix;
};
var getMixer2 = (v) => isCustomValueType(v) ? v.mix : void 0;
function transform2(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, {
    mixer: getMixer2(outputRange[0]),
    ...options
  });
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-combine-values.mjs
function useCombineMotionValues(values, combineValues) {
  const value = useMotionValue(combineValues());
  const updateValue = () => value.set(combineValues());
  updateValue();
  useIsomorphicLayoutEffect(() => {
    const scheduleUpdate = () => frame.preRender(updateValue, false, true);
    const subscriptions = values.map((v) => v.on("change", scheduleUpdate));
    return () => {
      subscriptions.forEach((unsubscribe) => unsubscribe());
      cancelFrame(updateValue);
    };
  });
  return value;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-computed.mjs
function useComputed(compute) {
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute);
  collectMotionValues.current = void 0;
  return value;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-transform.mjs
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  if (typeof input === "function") {
    return useComputed(input);
  }
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform2(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
function useListTransform(values, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values, () => {
    latest.length = 0;
    const numValues = values.length;
    for (let i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest);
  });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
function useDefaultMotionValue(value, defaultValue = 0) {
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
function ReorderItem({ children, style = {}, value, as = "li", onDrag, layout: layout2 = true, ...props2 }, externalRef) {
  const Component3 = useConstant(() => motion(as));
  const context = (0, import_react48.useContext)(ReorderContext);
  const point2 = {
    x: useDefaultMotionValue(style.x),
    y: useDefaultMotionValue(style.y)
  };
  const zIndex = useTransform([point2.x, point2.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
  invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  const { axis, registerItem, updateOrder } = context;
  return (0, import_jsx_runtime24.jsx)(Component3, { drag: axis, ...props2, dragSnapToOrigin: true, style: { ...style, x: point2.x, y: point2.y, zIndex }, layout: layout2, onDrag: (event, gesturePoint) => {
    const { velocity } = gesturePoint;
    velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis]);
    onDrag && onDrag(event, gesturePoint);
  }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true, children });
}
var Item = (0, import_react48.forwardRef)(ReorderItem);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/Reorder/index.mjs
var Reorder = {
  Group,
  Item
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/features-min.mjs
var domMin = {
  renderer: createDomVisualElement,
  ...animations
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/features-animation.mjs
var domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/features-max.mjs
var domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-motion-template.mjs
function useMotionTemplate(fragments, ...values) {
  const numFragments = fragments.length;
  function buildValue() {
    let output = ``;
    for (let i = 0; i < numFragments; i++) {
      output += fragments[i];
      const value = values[i];
      if (value) {
        output += isMotionValue(value) ? value.get() : value;
      }
    }
    return output;
  }
  return useCombineMotionValues(values.filter(isMotionValue), buildValue);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-spring.mjs
var import_react49 = __toESM(require_react(), 1);
function toNumber2(v) {
  if (typeof v === "number")
    return v;
  return parseFloat(v);
}
function useSpring(source, config2 = {}) {
  const { isStatic } = (0, import_react49.useContext)(MotionConfigContext);
  const activeSpringAnimation = (0, import_react49.useRef)(null);
  const value = useMotionValue(isMotionValue(source) ? toNumber2(source.get()) : source);
  const latestValue = (0, import_react49.useRef)(value.get());
  const latestSetter = (0, import_react49.useRef)(() => {
  });
  const startAnimation = () => {
    const animation2 = activeSpringAnimation.current;
    if (animation2 && animation2.time === 0) {
      animation2.sample(frameData.delta);
    }
    stopAnimation2();
    activeSpringAnimation.current = animateValue({
      keyframes: [value.get(), latestValue.current],
      velocity: value.getVelocity(),
      type: "spring",
      restDelta: 1e-3,
      restSpeed: 0.01,
      ...config2,
      onUpdate: latestSetter.current
    });
  };
  const stopAnimation2 = () => {
    if (activeSpringAnimation.current) {
      activeSpringAnimation.current.stop();
    }
  };
  (0, import_react49.useInsertionEffect)(() => {
    return value.attach((v, set) => {
      if (isStatic)
        return set(v);
      latestValue.current = v;
      latestSetter.current = set;
      frame.update(startAnimation);
      return value.get();
    }, stopAnimation2);
  }, [JSON.stringify(config2)]);
  useIsomorphicLayoutEffect(() => {
    if (isMotionValue(source)) {
      return source.on("change", (v) => value.set(toNumber2(v)));
    }
  }, [value]);
  return value;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs
var import_react50 = __toESM(require_react(), 1);
function useMotionValueEvent(value, event, callback) {
  (0, import_react50.useInsertionEffect)(() => value.on(event, callback), [value, event, callback]);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-velocity.mjs
function useVelocity(value) {
  const velocity = useMotionValue(value.getVelocity());
  const updateVelocity = () => {
    const latest = value.getVelocity();
    velocity.set(latest);
    if (latest)
      frame.update(updateVelocity);
  };
  useMotionValueEvent(value, "change", () => {
    frame.update(updateVelocity, false, true);
  });
  return velocity;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-scroll.mjs
var import_react51 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs
function resolveElements(elements, scope, selectorCache) {
  var _a;
  if (typeof elements === "string") {
    let root = document;
    if (scope) {
      invariant(Boolean(scope.current), "Scope provided, but no element detected.");
      root = scope.current;
    }
    if (selectorCache) {
      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = root.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/resize/handle-element.mjs
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var observer;
function getElementSize(target, borderBoxSize) {
  if (borderBoxSize) {
    const { inlineSize, blockSize } = borderBoxSize[0];
    return { width: inlineSize, height: blockSize };
  } else if (target instanceof SVGElement && "getBBox" in target) {
    return target.getBBox();
  } else {
    return {
      width: target.offsetWidth,
      height: target.offsetHeight
    };
  }
}
function notifyTarget({ target, contentRect, borderBoxSize }) {
  var _a;
  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {
    handler({
      target,
      contentSize: contentRect,
      get size() {
        return getElementSize(target, borderBoxSize);
      }
    });
  });
}
function notifyAll(entries) {
  entries.forEach(notifyTarget);
}
function createResizeObserver() {
  if (typeof ResizeObserver === "undefined")
    return;
  observer = new ResizeObserver(notifyAll);
}
function resizeElement(target, handler) {
  if (!observer)
    createResizeObserver();
  const elements = resolveElements(target);
  elements.forEach((element) => {
    let elementHandlers = resizeHandlers.get(element);
    if (!elementHandlers) {
      elementHandlers = /* @__PURE__ */ new Set();
      resizeHandlers.set(element, elementHandlers);
    }
    elementHandlers.add(handler);
    observer === null || observer === void 0 ? void 0 : observer.observe(element);
  });
  return () => {
    elements.forEach((element) => {
      const elementHandlers = resizeHandlers.get(element);
      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
      }
    });
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/resize/handle-window.mjs
var windowCallbacks = /* @__PURE__ */ new Set();
var windowResizeHandler;
function createWindowResizeHandler() {
  windowResizeHandler = () => {
    const size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    const info = {
      target: window,
      size,
      contentSize: size
    };
    windowCallbacks.forEach((callback) => callback(info));
  };
  window.addEventListener("resize", windowResizeHandler);
}
function resizeWindow(callback) {
  windowCallbacks.add(callback);
  if (!windowResizeHandler)
    createWindowResizeHandler();
  return () => {
    windowCallbacks.delete(callback);
    if (!windowCallbacks.size && windowResizeHandler) {
      windowResizeHandler = void 0;
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/resize/index.mjs
function resize(a, b) {
  return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs
var maxElapsed2 = 50;
var createAxisInfo = () => ({
  current: 0,
  offset: [],
  progress: 0,
  scrollLength: 0,
  targetOffset: 0,
  targetLength: 0,
  containerLength: 0,
  velocity: 0
});
var createScrollInfo = () => ({
  time: 0,
  x: createAxisInfo(),
  y: createAxisInfo()
});
var keys = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
function updateAxisInfo(element, axisName, info, time2) {
  const axis = info[axisName];
  const { length: length2, position: position2 } = keys[axisName];
  const prev2 = axis.current;
  const prevTime = info.time;
  axis.current = element[`scroll${position2}`];
  axis.scrollLength = element[`scroll${length2}`] - element[`client${length2}`];
  axis.offset.length = 0;
  axis.offset[0] = 0;
  axis.offset[1] = axis.scrollLength;
  axis.progress = progress(0, axis.scrollLength, axis.current);
  const elapsed = time2 - prevTime;
  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond(axis.current - prev2, elapsed);
}
function updateScrollInfo(element, info, time2) {
  updateAxisInfo(element, "x", info, time2);
  updateAxisInfo(element, "y", info, time2);
  info.time = time2;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs
function calcInset(element, container) {
  const inset = { x: 0, y: 0 };
  let current = element;
  while (current && current !== container) {
    if (current instanceof HTMLElement) {
      inset.x += current.offsetLeft;
      inset.y += current.offsetTop;
      current = current.offsetParent;
    } else if (current.tagName === "svg") {
      const svgBoundingBox = current.getBoundingClientRect();
      current = current.parentElement;
      const parentBoundingBox = current.getBoundingClientRect();
      inset.x += svgBoundingBox.left - parentBoundingBox.left;
      inset.y += svgBoundingBox.top - parentBoundingBox.top;
    } else if (current instanceof SVGGraphicsElement) {
      const { x, y } = current.getBBox();
      inset.x += x;
      inset.y += y;
      let svg = null;
      let parent = current.parentNode;
      while (!svg) {
        if (parent.tagName === "svg") {
          svg = parent;
        }
        parent = current.parentNode;
      }
      current = svg;
    } else {
      break;
    }
  }
  return inset;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs
var ScrollOffset = {
  Enter: [
    [0, 1],
    [1, 1]
  ],
  Exit: [
    [0, 0],
    [1, 0]
  ],
  Any: [
    [1, 0],
    [0, 1]
  ],
  All: [
    [0, 0],
    [1, 1]
  ]
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs
var namedEdges = {
  start: 0,
  center: 0.5,
  end: 1
};
function resolveEdge(edge, length2, inset = 0) {
  let delta = 0;
  if (edge in namedEdges) {
    edge = namedEdges[edge];
  }
  if (typeof edge === "string") {
    const asNumber2 = parseFloat(edge);
    if (edge.endsWith("px")) {
      delta = asNumber2;
    } else if (edge.endsWith("%")) {
      edge = asNumber2 / 100;
    } else if (edge.endsWith("vw")) {
      delta = asNumber2 / 100 * document.documentElement.clientWidth;
    } else if (edge.endsWith("vh")) {
      delta = asNumber2 / 100 * document.documentElement.clientHeight;
    } else {
      edge = asNumber2;
    }
  }
  if (typeof edge === "number") {
    delta = length2 * edge;
  }
  return inset + delta;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs
var defaultOffset2 = [0, 0];
function resolveOffset(offset2, containerLength, targetLength, targetInset) {
  let offsetDefinition = Array.isArray(offset2) ? offset2 : defaultOffset2;
  let targetPoint = 0;
  let containerPoint = 0;
  if (typeof offset2 === "number") {
    offsetDefinition = [offset2, offset2];
  } else if (typeof offset2 === "string") {
    offset2 = offset2.trim();
    if (offset2.includes(" ")) {
      offsetDefinition = offset2.split(" ");
    } else {
      offsetDefinition = [offset2, namedEdges[offset2] ? offset2 : `0`];
    }
  }
  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
  containerPoint = resolveEdge(offsetDefinition[1], containerLength);
  return targetPoint - containerPoint;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs
var point = { x: 0, y: 0 };
function getTargetSize(target) {
  return "getBBox" in target && target.tagName !== "svg" ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight };
}
function resolveOffsets(container, info, options) {
  const { offset: offsetDefinition = ScrollOffset.All } = options;
  const { target = container, axis = "y" } = options;
  const lengthLabel = axis === "y" ? "height" : "width";
  const inset = target !== container ? calcInset(target, container) : point;
  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : getTargetSize(target);
  const containerSize = {
    width: container.clientWidth,
    height: container.clientHeight
  };
  info[axis].offset.length = 0;
  let hasChanged = !info[axis].interpolate;
  const numOffsets = offsetDefinition.length;
  for (let i = 0; i < numOffsets; i++) {
    const offset2 = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
    if (!hasChanged && offset2 !== info[axis].interpolatorOffsets[i]) {
      hasChanged = true;
    }
    info[axis].offset[i] = offset2;
  }
  if (hasChanged) {
    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));
    info[axis].interpolatorOffsets = [...info[axis].offset];
  }
  info[axis].progress = info[axis].interpolate(info[axis].current);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs
function measure(container, target = container, info) {
  info.x.targetOffset = 0;
  info.y.targetOffset = 0;
  if (target !== container) {
    let node3 = target;
    while (node3 && node3 !== container) {
      info.x.targetOffset += node3.offsetLeft;
      info.y.targetOffset += node3.offsetTop;
      node3 = node3.offsetParent;
    }
  }
  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
  info.x.containerLength = container.clientWidth;
  info.y.containerLength = container.clientHeight;
  if (true) {
    if (container && target && target !== container) {
      warnOnce(getComputedStyle(container).position !== "static", "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
    }
  }
}
function createOnScrollHandler(element, onScroll2, info, options = {}) {
  return {
    measure: () => measure(element, options.target, info),
    update: (time2) => {
      updateScrollInfo(element, info, time2);
      if (options.offset || options.target) {
        resolveOffsets(element, info, options);
      }
    },
    notify: () => onScroll2(info)
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getEventTarget = (element) => element === document.documentElement ? window : element;
function scrollInfo(onScroll2, { container = document.documentElement, ...options } = {}) {
  let containerHandlers = onScrollHandlers.get(container);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  const info = createScrollInfo();
  const containerHandler = createOnScrollHandler(container, onScroll2, info, options);
  containerHandlers.add(containerHandler);
  if (!scrollListeners.has(container)) {
    const measureAll = () => {
      for (const handler of containerHandlers)
        handler.measure();
    };
    const updateAll = () => {
      for (const handler of containerHandlers) {
        handler.update(frameData.timestamp);
      }
    };
    const notifyAll2 = () => {
      for (const handler of containerHandlers)
        handler.notify();
    };
    const listener2 = () => {
      frame.read(measureAll, false, true);
      frame.read(updateAll, false, true);
      frame.update(notifyAll2, false, true);
    };
    scrollListeners.set(container, listener2);
    const target = getEventTarget(container);
    window.addEventListener("resize", listener2, { passive: true });
    if (container !== document.documentElement) {
      resizeListeners.set(container, resize(container, listener2));
    }
    target.addEventListener("scroll", listener2, { passive: true });
  }
  const listener = scrollListeners.get(container);
  frame.read(listener, false, true);
  return () => {
    var _a;
    cancelFrame(listener);
    const currentHandlers = onScrollHandlers.get(container);
    if (!currentHandlers)
      return;
    currentHandlers.delete(containerHandler);
    if (currentHandlers.size)
      return;
    const scrollListener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (scrollListener) {
      getEventTarget(container).removeEventListener("scroll", scrollListener);
      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();
      window.removeEventListener("resize", scrollListener);
    }
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-scroll.mjs
function refWarning(name, ref) {
  warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
}
var createScrollMotionValues = () => ({
  scrollX: motionValue(0),
  scrollY: motionValue(0),
  scrollXProgress: motionValue(0),
  scrollYProgress: motionValue(0)
});
function useScroll({ container, target, layoutEffect = true, ...options } = {}) {
  const values = useConstant(createScrollMotionValues);
  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : import_react51.useEffect;
  useLifecycleEffect(() => {
    refWarning("target", target);
    refWarning("container", container);
    return scrollInfo(({ x, y }) => {
      values.scrollX.set(x.current);
      values.scrollXProgress.set(x.progress);
      values.scrollY.set(y.current);
      values.scrollYProgress.set(y.progress);
    }, {
      ...options,
      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,
      target: (target === null || target === void 0 ? void 0 : target.current) || void 0
    });
  }, [container, target, JSON.stringify(options.offset)]);
  return values;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/scroll/use-element-scroll.mjs
function useElementScroll(ref) {
  if (true) {
    warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
  }
  return useScroll({ container: ref });
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/scroll/use-viewport-scroll.mjs
function useViewportScroll() {
  if (true) {
    warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");
  }
  return useScroll();
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs
var import_react52 = __toESM(require_react(), 1);
function useAnimationFrame(callback) {
  const initialTimestamp = (0, import_react52.useRef)(0);
  const { isStatic } = (0, import_react52.useContext)(MotionConfigContext);
  (0, import_react52.useEffect)(() => {
    if (isStatic)
      return;
    const provideTimeSinceStart = ({ timestamp, delta }) => {
      if (!initialTimestamp.current)
        initialTimestamp.current = timestamp;
      callback(timestamp - initialTimestamp.current, delta);
    };
    frame.update(provideTimeSinceStart, true);
    return () => cancelFrame(provideTimeSinceStart);
  }, [callback]);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-time.mjs
function useTime() {
  const time2 = useMotionValue(0);
  useAnimationFrame((t) => time2.set(t));
  return time2;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-will-change/index.mjs
function useWillChange() {
  return useConstant(() => new WillChangeMotionValue("auto"));
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs
var import_react53 = __toESM(require_react(), 1);
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = (0, import_react53.useState)(prefersReducedMotion.current);
  if (true) {
    warnOnce(shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
  }
  return shouldReduceMotion;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion-config.mjs
var import_react54 = __toESM(require_react(), 1);
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion();
  const { reducedMotion } = (0, import_react54.useContext)(MotionConfigContext);
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs
function stopAnimation(visualElement) {
  visualElement.values.forEach((value) => value.stop());
}
function setVariants(visualElement, variantLabels) {
  const reversedLabels = [...variantLabels].reverse();
  reversedLabels.forEach((key) => {
    const variant = visualElement.getVariant(key);
    variant && setTarget(visualElement, variant);
    if (visualElement.variantChildren) {
      visualElement.variantChildren.forEach((child) => {
        setVariants(child, variantLabels);
      });
    }
  });
}
function setValues(visualElement, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement, [definition]);
  } else {
    setTarget(visualElement, definition);
  }
}
function animationControls() {
  let hasMounted = false;
  const subscribers = /* @__PURE__ */ new Set();
  const controls = {
    subscribe(visualElement) {
      subscribers.add(visualElement);
      return () => void subscribers.delete(visualElement);
    },
    start(definition, transitionOverride) {
      invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const animations3 = [];
      subscribers.forEach((visualElement) => {
        animations3.push(animateVisualElement(visualElement, definition, {
          transitionOverride
        }));
      });
      return Promise.all(animations3);
    },
    set(definition) {
      invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach((visualElement) => {
        setValues(visualElement, definition);
      });
    },
    stop() {
      subscribers.forEach((visualElement) => {
        stopAnimation(visualElement);
      });
    },
    mount() {
      hasMounted = true;
      return () => {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react55 = __toESM(require_react(), 1);
function useUnmountEffect2(callback) {
  return (0, import_react55.useEffect)(() => () => callback(), []);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs
function isDOMKeyframes(keyframes6) {
  return typeof keyframes6 === "object" && !Array.isArray(keyframes6);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs
function createVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  };
  const node3 = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node3.mount(element);
  visualElementStore.set(element, node3);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/utils/create-generator-easing.mjs
function createGeneratorEasing(options, scale2 = 100) {
  const generator = spring({ keyframes: [0, scale2], ...options });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration * progress2).value / scale2,
    duration: millisecondsToSeconds(duration)
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs
function calcNextTime(current, next2, prev2, labels) {
  var _a;
  if (typeof next2 === "number") {
    return next2;
  } else if (next2.startsWith("-") || next2.startsWith("+")) {
    return Math.max(0, current + parseFloat(next2));
  } else if (next2 === "<") {
    return prev2;
  } else {
    return (_a = labels.get(next2)) !== null && _a !== void 0 ? _a : current;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/wrap.mjs
var wrap2 = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs
function getEasingForSegment(easing, i) {
  return isEasingArray(easing) ? easing[wrap2(0, easing.length, i)] : easing;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i = 0; i < sequence.length; i++) {
    const keyframe = sequence[i];
    if (keyframe.at > startTime && keyframe.at < endTime) {
      removeItem(sequence, keyframe);
      i--;
    }
  }
}
function addKeyframes(sequence, keyframes6, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i = 0; i < keyframes6.length; i++) {
    sequence.push({
      value: keyframes6[i],
      at: mixNumber(startTime, endTime, offset2[i]),
      easing: getEasingForSegment(easing, i)
    });
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs
function compareByTime(a, b) {
  if (a.at === b.at) {
    if (a.value === null)
      return 1;
    if (b.value === null)
      return -1;
    return 0;
  } else {
    return a.at - b.at;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/sequence/create.mjs
var defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = /* @__PURE__ */ new Map();
  const sequences = /* @__PURE__ */ new Map();
  const elementCache = {};
  const timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  for (let i = 0; i < sequence.length; i++) {
    const segment = sequence[i];
    if (typeof segment === "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes6, transition = {}] = segment;
    if (transition.at !== void 0) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
    }
    let maxDuration3 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes);
      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 === "function" ? delay2(elementIndex, numElements) : delay2;
      const numKeyframes = valueKeyframesAsList.length;
      if (numKeyframes <= 2 && type === "spring") {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        if (duration !== void 0) {
          springTransition.duration = secondsToMilliseconds(duration);
        }
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);
        ease2 = springEasing.ease;
        duration = springEasing.duration;
      }
      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
      const startTime = currentTime + calculatedDelay;
      const targetTime = startTime + duration;
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder);
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);
      maxDuration3 = Math.max(calculatedDelay + duration, maxDuration3);
      totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes6, transition, getValueSequence("default", subjectSequence));
    } else {
      const elements = resolveElements(subject, scope, elementCache);
      const numElements = elements.length;
      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
        keyframes6 = keyframes6;
        transition = transition;
        const element = elements[elementIndex];
        const subjectSequence = getSubjectSequence(element, sequences);
        for (const key in keyframes6) {
          resolveValueSequence(keyframes6[key], getValueTransition2(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);
        }
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration3;
  }
  sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      valueSequence.sort(compareByTime);
      const keyframes6 = [];
      const valueOffset = [];
      const valueEasing = [];
      for (let i = 0; i < valueSequence.length; i++) {
        const { at, value, easing } = valueSequence[i];
        keyframes6.push(value);
        valueOffset.push(progress(0, totalDuration, at));
        valueEasing.push(easing || "easeOut");
      }
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes6.unshift(keyframes6[0]);
        valueEasing.unshift(defaultSegmentEasing);
      }
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes6.push(null);
      }
      if (!animationDefinitions.has(element)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {}
        });
      }
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes6;
      definition.transition[key] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  });
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  !sequences.has(subject) && sequences.set(subject, {});
  return sequences.get(subject);
}
function getValueSequence(name, sequences) {
  if (!sequences[name])
    sequences[name] = [];
  return sequences[name];
}
function keyframesAsList(keyframes6) {
  return Array.isArray(keyframes6) ? keyframes6 : [keyframes6];
}
function getValueTransition2(transition, key) {
  return transition[key] ? {
    ...transition,
    ...transition[key]
  } : { ...transition };
}
var isNumber2 = (keyframe) => typeof keyframe === "number";
var isNumberKeyframesArray = (keyframes6) => keyframes6.every(isNumber2);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/animate.mjs
function animateElements(elementOrSelector, keyframes6, options, scope) {
  const elements = resolveElements(elementOrSelector, scope);
  const numElements = elements.length;
  invariant(Boolean(numElements), "No valid element provided.");
  const animations3 = [];
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    if (!visualElementStore.has(element)) {
      createVisualElement(element);
    }
    const visualElement = visualElementStore.get(element);
    const transition = { ...options };
    if (typeof transition.delay === "function") {
      transition.delay = transition.delay(i, numElements);
    }
    animations3.push(...animateTarget(visualElement, { ...keyframes6, transition }, {}));
  }
  return new GroupPlaybackControls(animations3);
}
var isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);
function animateSequence(sequence, options, scope) {
  const animations3 = [];
  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);
  animationDefinitions.forEach(({ keyframes: keyframes6, transition }, subject) => {
    let animation2;
    if (isMotionValue(subject)) {
      animation2 = animateSingleValue(subject, keyframes6.default, transition.default);
    } else {
      animation2 = animateElements(subject, keyframes6, transition);
    }
    animations3.push(animation2);
  });
  return new GroupPlaybackControls(animations3);
}
var createScopedAnimate = (scope) => {
  function scopedAnimate(valueOrElementOrSequence, keyframes6, options) {
    let animation2;
    if (isSequence(valueOrElementOrSequence)) {
      animation2 = animateSequence(valueOrElementOrSequence, keyframes6, scope);
    } else if (isDOMKeyframes(keyframes6)) {
      animation2 = animateElements(valueOrElementOrSequence, keyframes6, options, scope);
    } else {
      animation2 = animateSingleValue(valueOrElementOrSequence, keyframes6, options);
    }
    if (scope) {
      scope.animations.push(animation2);
    }
    return animation2;
  }
  return scopedAnimate;
};
var animate = createScopedAnimate();

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/hooks/use-animate.mjs
function useAnimate() {
  const scope = useConstant(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  }));
  const animate2 = useConstant(() => createScopedAnimate(scope));
  useUnmountEffect2(() => {
    scope.animations.forEach((animation2) => animation2.stop());
  });
  return [scope, animate2];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs
function useAnimationControls() {
  const controls = useConstant(animationControls);
  useIsomorphicLayoutEffect(controls.mount, []);
  return controls;
}
var useAnimation = useAnimationControls;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-cycle.mjs
var import_react56 = __toESM(require_react(), 1);
function useCycle(...items) {
  const index = (0, import_react56.useRef)(0);
  const [item, setItem] = (0, import_react56.useState)(items[index.current]);
  const runCycle = (0, import_react56.useCallback)(
    (next2) => {
      index.current = typeof next2 !== "number" ? wrap2(0, items.length, index.current + 1) : next2;
      setItem(items[index.current]);
    },
    // The array will change on each call, but by putting items.length at
    // the front of this array, we guarantee the dependency comparison will match up
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [items.length, ...items]
  );
  return [item, runCycle];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-in-view.mjs
var import_react57 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/viewport/index.mjs
var thresholds = {
  some: 0,
  all: 1
};
function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
  const elements = resolveElements(elementOrSelector);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = (entries) => {
    entries.forEach((entry) => {
      const onEnd = activeIntersections.get(entry.target);
      if (entry.isIntersecting === Boolean(onEnd))
        return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (typeof newOnEnd === "function") {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer2.unobserve(entry.target);
        }
      } else if (onEnd) {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  };
  const observer2 = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach((element) => observer2.observe(element));
  return () => observer2.disconnect();
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-in-view.mjs
function useInView(ref, { root, margin, amount, once = false } = {}) {
  const [isInView, setInView] = (0, import_react57.useState)(false);
  (0, import_react57.useEffect)(() => {
    if (!ref.current || once && isInView)
      return;
    const onEnter = () => {
      setInView(true);
      return once ? void 0 : () => setInView(false);
    };
    const options = {
      root: root && root.current || void 0,
      margin,
      amount
    };
    return inView(ref.current, onEnter, options);
  }, [root, ref, margin, once, amount]);
  return isInView;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.mjs
var DragControls = class {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    this.componentControls.add(controls);
    return () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
};
var createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/events/use-dom-event.mjs
var import_react58 = __toESM(require_react(), 1);
function useDomEvent(ref, eventName, handler, options) {
  (0, import_react58.useEffect)(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent2(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/is-motion-component.mjs
function isMotionComponent(component) {
  return component !== null && typeof component === "object" && motionComponentSymbol in component;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/motion/utils/unwrap-motion-component.mjs
function unwrapMotionComponent(component) {
  if (isMotionComponent(component)) {
    return component[motionComponentSymbol];
  }
  return void 0;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs
var import_react59 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/use-instant-layout-transition.mjs
function useInstantLayoutTransition() {
  return startTransition;
}
function startTransition(callback) {
  if (!rootProjectionNode.current)
    return;
  rootProjectionNode.current.isUpdating = false;
  rootProjectionNode.current.blockUpdate();
  callback && callback();
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs
function useInstantTransition() {
  const [forceUpdate, forcedRenderCount] = useForceUpdate();
  const startInstantLayoutTransition = useInstantLayoutTransition();
  const unlockOnFrameRef = (0, import_react59.useRef)();
  (0, import_react59.useEffect)(() => {
    frame.postRender(() => frame.postRender(() => {
      if (forcedRenderCount !== unlockOnFrameRef.current)
        return;
      instantAnimationState.current = false;
    }));
  }, [forcedRenderCount]);
  return (callback) => {
    startInstantLayoutTransition(() => {
      instantAnimationState.current = true;
      forceUpdate();
      callback();
      unlockOnFrameRef.current = forcedRenderCount + 1;
    });
  };
}
function disableInstantTransitions() {
  instantAnimationState.current = false;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs
var import_react60 = __toESM(require_react(), 1);
function useResetProjection() {
  const reset = (0, import_react60.useCallback)(() => {
    const root = rootProjectionNode.current;
    if (!root)
      return;
    root.resetTree();
  }, []);
  return reset;
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/store-id.mjs
var appearStoreId = (id4, value) => `${id4}: ${value}`;

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/store.mjs
var appearAnimationStore = /* @__PURE__ */ new Map();
var elementsWithAppearAnimations = /* @__PURE__ */ new Set();

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs
var handoffFrameTime;
function handoffOptimizedAppearAnimation(elementId, valueName, frame3) {
  const optimisedValueName = transformProps.has(valueName) ? "transform" : valueName;
  const storeId = appearStoreId(elementId, optimisedValueName);
  const optimisedAnimation = appearAnimationStore.get(storeId);
  if (!optimisedAnimation) {
    return null;
  }
  const { animation: animation2, startTime } = optimisedAnimation;
  if (startTime === null || window.MotionHandoffIsComplete) {
    appearAnimationStore.delete(storeId);
    frame3.render(() => frame3.render(() => {
      try {
        animation2.cancel();
      } catch (error) {
      }
    }));
    return null;
  } else {
    if (handoffFrameTime === void 0) {
      handoffFrameTime = performance.now();
    }
    return handoffFrameTime - startTime || 0;
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs
var startFrameTime;
var readyAnimation;
function startOptimizedAppearAnimation(element, name, keyframes6, options, onReady) {
  if (window.MotionHandoffIsComplete) {
    window.MotionHandoffAnimation = void 0;
    return;
  }
  const id4 = element.dataset[optimizedAppearDataId];
  if (!id4)
    return;
  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
  const storeId = appearStoreId(id4, name);
  if (!readyAnimation) {
    readyAnimation = animateStyle(
      element,
      name,
      [keyframes6[0], keyframes6[0]],
      /**
       * 10 secs is basically just a super-safe duration to give Chrome
       * long enough to get the animation ready.
       */
      { duration: 1e4, ease: "linear" }
    );
    appearAnimationStore.set(storeId, {
      animation: readyAnimation,
      startTime: null
    });
    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
    window.MotionHandoffCancelAll = () => {
      appearAnimationStore.forEach(({ animation: animation2 }, animationId) => {
        if (animationId.endsWith("transform")) {
          animation2.cancel();
          appearAnimationStore.delete(animationId);
        }
      });
      window.MotionHandoffCancelAll = void 0;
    };
    window.MotionHasOptimisedAnimation = (elementId) => Boolean(elementId && elementsWithAppearAnimations.has(elementId));
    window.MotionHasOptimisedTransformAnimation = (elementId) => Boolean(elementId && appearAnimationStore.has(appearStoreId(elementId, "transform")));
  }
  const startAnimation = () => {
    readyAnimation.cancel();
    const appearAnimation = animateStyle(element, name, keyframes6, options);
    if (startFrameTime === void 0) {
      startFrameTime = performance.now();
    }
    appearAnimation.startTime = startFrameTime;
    appearAnimationStore.set(storeId, {
      animation: appearAnimation,
      startTime: startFrameTime
    });
    if (onReady)
      onReady(appearAnimation);
  };
  elementsWithAppearAnimations.add(id4);
  if (readyAnimation.ready) {
    readyAnimation.ready.then(startAnimation).catch(noop2);
  } else {
    startAnimation();
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/hooks/use-animated-state.mjs
var import_react61 = __toESM(require_react(), 1);
var createObject = () => ({});
var StateVisualElement = class extends VisualElement {
  constructor() {
    super(...arguments);
    this.measureInstanceViewportBox = createBox;
  }
  build() {
  }
  resetTransform() {
  }
  restoreTransform() {
  }
  removeValueFromRenderState() {
  }
  renderInstance() {
  }
  scrapeMotionValuesFromProps() {
    return createObject();
  }
  getBaseTargetFromProps() {
    return void 0;
  }
  readValueFromInstance(_state, key, options) {
    return options.initialState[key] || 0;
  }
  sortInstanceNodePosition() {
    return 0;
  }
};
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});
function useAnimatedState(initialState2) {
  const [animationState, setAnimationState] = (0, import_react61.useState)(initialState2);
  const visualState = useVisualState({}, false);
  const element = useConstant(() => {
    return new StateVisualElement({ props: {}, visualState, presenceContext: null }, { initialState: initialState2 });
  });
  (0, import_react61.useEffect)(() => {
    element.mount({});
    return () => element.unmount();
  }, [element]);
  (0, import_react61.useEffect)(() => {
    element.update({
      onUpdate: (v) => {
        setAnimationState({ ...v });
      }
    }, null);
  }, [setAnimationState, element]);
  const startAnimation = useConstant(() => (animationDefinition) => {
    return animateVisualElement(element, animationDefinition);
  });
  return [animationState, startAnimation];
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/value/use-inverted-scale.mjs
var import_react62 = __toESM(require_react(), 1);
var maxScale = 1e5;
var invertScale = (scale2) => scale2 > 1e-3 ? 1 / scale2 : maxScale;
var hasWarned = false;
function useInvertedScale(scale2) {
  let parentScaleX = useMotionValue(1);
  let parentScaleY = useMotionValue(1);
  const { visualElement } = (0, import_react62.useContext)(MotionContext);
  invariant(!!(scale2 || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale2) {
    parentScaleX = scale2.scaleX || parentScaleX;
    parentScaleY = scale2.scaleY || parentScaleY;
  } else if (visualElement) {
    parentScaleX = visualElement.getValue("scaleX", 1);
    parentScaleY = visualElement.getValue("scaleY", 1);
  }
  const scaleX = useTransform(parentScaleX, invertScale);
  const scaleY = useTransform(parentScaleY, invertScale);
  return { scaleX, scaleY };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var React10 = __toESM(require_react(), 1);
var id3 = 0;
var AnimateSharedLayout = ({ children }) => {
  React10.useEffect(() => {
    invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
  }, []);
  return (0, import_jsx_runtime25.jsx)(LayoutGroup, { id: useConstant(() => `asl-${id3++}`), children });
};

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs
function scrollTimelineFallback({ source, axis = "y" }) {
  const currentTime = { value: 0 };
  const cancel = scrollInfo((info) => {
    currentTime.value = info[axis].progress * 100;
  }, { container: source, axis });
  return { currentTime, cancel };
}
var timelineCache = /* @__PURE__ */ new Map();
function getTimeline({ source = document.documentElement, axis = "y" } = {}) {
  if (!timelineCache.has(source)) {
    timelineCache.set(source, {});
  }
  const elementCache = timelineCache.get(source);
  if (!elementCache[axis]) {
    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({ source, axis }) : scrollTimelineFallback({ source, axis });
  }
  return elementCache[axis];
}
function scroll(onScroll2, options) {
  const timeline = getTimeline(options);
  if (typeof onScroll2 === "function") {
    return observeTimeline(onScroll2, timeline);
  } else {
    return onScroll2.attachTimeline(timeline);
  }
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/animation/utils/stagger.mjs
function getOriginIndex(from2, total) {
  if (from2 === "first") {
    return 0;
  } else {
    const lastIndex = total - 1;
    return from2 === "last" ? lastIndex : lastIndex / 2;
  }
}
function stagger(duration = 0.1, { startDelay = 0, from: from2 = 0, ease: ease2 } = {}) {
  return (i, total) => {
    const fromIndex = typeof from2 === "number" ? from2 : getOriginIndex(from2, total);
    const distance3 = Math.abs(fromIndex - i);
    let delay2 = duration * distance3;
    if (ease2) {
      const maxDelay = total * duration;
      const easingFunction = easingDefinitionToFunction(ease2);
      delay2 = easingFunction(delay2 / maxDelay) * maxDelay;
    }
    return startDelay + delay2;
  };
}

// node_modules/@yamada-ui/motion/node_modules/framer-motion/dist/es/frameloop/index-legacy.mjs
var sync = frame;
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = (process2) => cancelFrame(process2);
  return acc;
}, {});

// node_modules/@yamada-ui/motion/dist/chunk-QUROR2OJ.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var Motion = motionForwardRef(
  ({ as, className, ...rest }, ref) => {
    return (0, import_jsx_runtime26.jsx)(
      ui.div,
      {
        as: motion[as != null ? as : "div"],
        ref,
        className: cx("ui-motion", className),
        ...rest
      }
    );
  }
);
Motion.displayName = "Motion";

// node_modules/@yamada-ui/motion/dist/chunk-WZQCVPKI.mjs
var MOTION_TRANSITION_EASINGS = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
};
var MOTION_TRANSITION_VARIANTS = {
  scale: {
    enter: { scale: 1 },
    exit: { scale: 0.95 }
  },
  fade: {
    enter: { opacity: 1 },
    exit: { opacity: 0 }
  },
  pushLeft: {
    enter: { x: "100%" },
    exit: { x: "-30%" }
  },
  pushRight: {
    enter: { x: "-100%" },
    exit: { x: "30%" }
  },
  pushUp: {
    enter: { y: "100%" },
    exit: { y: "-30%" }
  },
  pushDown: {
    enter: { y: "-100%" },
    exit: { y: "30%" }
  },
  slideLeft: {
    position: { left: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "-100%", y: 0 }
  },
  slideRight: {
    position: { right: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "100%", y: 0 }
  },
  slideUp: {
    position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "-100%" }
  },
  slideDown: {
    position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "100%" }
  }
};
var MOTION_TRANSITION_DEFAULTS = {
  enter: {
    duration: 0.25,
    ease: MOTION_TRANSITION_EASINGS.easeOut
  },
  exit: {
    duration: 0.2,
    ease: MOTION_TRANSITION_EASINGS.easeIn
  }
};
var transitionEnter = (transition) => (delay2, duration) => ({
  ...transition != null ? transition : MOTION_TRANSITION_DEFAULTS.enter,
  ...duration ? { duration: isNumber(duration) ? duration : duration == null ? void 0 : duration.enter } : {},
  delay: isNumber(delay2) ? delay2 : delay2 == null ? void 0 : delay2.enter
});
var transitionExit = (transition) => (delay2, duration) => ({
  ...transition != null ? transition : MOTION_TRANSITION_DEFAULTS.exit,
  ...duration ? { duration: isNumber(duration) ? duration : duration == null ? void 0 : duration.exit } : {},
  delay: isNumber(delay2) ? delay2 : delay2 == null ? void 0 : delay2.exit
});

// node_modules/@yamada-ui/portal/dist/chunk-FTCDIP3W.mjs
var [PortalProvider, usePortal] = createContext2({
  strict: false,
  name: "PortalContext"
});

// node_modules/@yamada-ui/portal/dist/chunk-EGXH2H6C.mjs
var import_react63 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var ContainerPortal = ({
  children,
  containerRef,
  appendToParentPortal
}) => {
  const parent = containerRef.current;
  const host = parent != null ? parent : typeof window !== "undefined" ? document.body : void 0;
  const portal = (0, import_react63.useMemo)(() => {
    if (!parent) return;
    const { ownerDocument } = parent;
    const node3 = ownerDocument.createElement("div");
    if (node3) node3.className = "ui-portal";
    return node3;
  }, [parent]);
  const [, forceUpdate] = (0, import_react63.useState)({});
  useSafeLayoutEffect(() => forceUpdate({}), []);
  useSafeLayoutEffect(() => {
    if (!portal || !host) return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  return host && portal ? (0, import_react_dom.createPortal)(
    (0, import_jsx_runtime27.jsx)(PortalProvider, { value: appendToParentPortal ? portal : null, children }),
    portal
  ) : null;
};

// node_modules/@yamada-ui/portal/dist/chunk-MV3EMJCQ.mjs
var import_react64 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var DefaultPortal = ({ appendToParentPortal, children }) => {
  const [node3, setNode] = (0, import_react64.useState)(null);
  const el = (0, import_react64.useRef)(null);
  const [, forceUpdate] = (0, import_react64.useState)({});
  (0, import_react64.useEffect)(() => forceUpdate({}), []);
  const parent = usePortal();
  useSafeLayoutEffect(() => {
    if (!node3) return;
    const { ownerDocument } = node3;
    const host = appendToParentPortal ? parent != null ? parent : ownerDocument.body : ownerDocument.body;
    if (!host) return;
    el.current = ownerDocument.createElement("div");
    el.current.className = "ui-portal";
    host.appendChild(el.current);
    forceUpdate({});
    const portalNode = el.current;
    return () => {
      if (host.contains(portalNode)) host.removeChild(portalNode);
    };
  }, [node3]);
  return el.current ? (0, import_react_dom2.createPortal)(
    (0, import_jsx_runtime28.jsx)(PortalProvider, { value: el.current, children }),
    el.current
  ) : (0, import_jsx_runtime28.jsx)("span", { ref: (el2) => el2 ? setNode(el2) : void 0 });
};

// node_modules/@yamada-ui/portal/dist/chunk-GRPOVBKN.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var Portal = ({
  containerRef,
  appendToParentPortal = true,
  isDisabled: isDisabled2,
  children
}) => {
  if (isDisabled2) return children;
  return containerRef ? (0, import_jsx_runtime29.jsx)(
    ContainerPortal,
    {
      containerRef,
      ...{ appendToParentPortal, children }
    }
  ) : (0, import_jsx_runtime29.jsx)(DefaultPortal, { ...{ appendToParentPortal, children } });
};
Portal.className = "ui-portal";
Portal.selector = ".ui-portal";

// node_modules/@yamada-ui/use-timeout/dist/index.mjs
var import_react65 = __toESM(require_react(), 1);
var useTimeout = (callback, delay2) => {
  const func2 = useCallbackRef(callback);
  (0, import_react65.useEffect)(() => {
    if (delay2 == null) return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(func2, delay2);
    return () => {
      if (timeoutId) window.clearTimeout(timeoutId);
    };
  }, [delay2, func2]);
};

// node_modules/@yamada-ui/loading/dist/chunk-ONPENPM5.mjs
var import_react69 = __toESM(require_react(), 1);

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React19 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React15 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef2(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react66 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react66.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React11 = __toESM(require_react());
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React11.useLayoutEffect : React11.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs2(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef2(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef2(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef2(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React12 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react67 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter3) {
          pendingQueue = pendingQueue.filter(filter3);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  return innerCreateMedium(defaults, middleware2);
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React13 = __toESM(require_react());
var import_react68 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React14 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar2 = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar2) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar2.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React14.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React15.forwardRef(function(props2, parentRef) {
  var ref = React15.useRef(null);
  var _a = React15.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props2.forwardProps, children = props2.children, className = props2.className, removeScrollBar = props2.removeScrollBar, enabled2 = props2.enabled, shards = props2.shards, sideCar2 = props2.sideCar, noIsolation = props2.noIsolation, inert = props2.inert, allowPinchZoom = props2.allowPinchZoom, _b = props2.as, Container3 = _b === void 0 ? "div" : _b, gapMode = props2.gapMode, rest = __rest(props2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar2;
  var containerRef = useMergeRefs2([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React15.createElement(
    React15.Fragment,
    null,
    enabled2 && React15.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React15.cloneElement(React15.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React15.createElement(Container3, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React18 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React17 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React16 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce2 = getNonce();
  if (nonce2) {
    tag.setAttribute("nonce", nonce2);
  }
  return tag;
}
function injectStyles(tag, css4) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css4;
  } else {
    tag.appendChild(document.createTextNode(css4));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter4 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter4 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter4++;
    },
    remove: function() {
      counter4--;
      if (!counter4 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet2 = stylesheetSingleton();
  return function(styles2, isDynamic) {
    React16.useEffect(function() {
      sheet2.add(styles2);
      return function() {
        sheet2.remove();
      };
    }, [styles2 && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a) {
    var styles2 = _a.styles, dynamic = _a.dynamic;
    useStyle2(styles2, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left2), parse2(top2), parse2(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles2 = function(_a, allowRelative, gapMode, important) {
  var left2 = _a.left, top2 = _a.top, right2 = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter4 = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter4) ? counter4 : 0;
};
var useLockAttribute = function() {
  React17.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React17.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React17.createElement(Style, { styles: getStyles2(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node3) {
  return node3.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node3, overflow) {
  if (!(node3 instanceof Element)) {
    return false;
  }
  var styles2 = window.getComputedStyle(node3);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node3) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node3) {
  return elementCanBeScrolled(node3, "overflowY");
};
var elementCouldBeHScrolled = function(node3) {
  return elementCanBeScrolled(node3, "overflowX");
};
var locationCouldBeScrolled = function(axis, node3) {
  var ownerDocument = node3.ownerDocument;
  var current = node3;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node3) {
  return axis === "v" ? elementCouldBeVScrolled(node3) : elementCouldBeHScrolled(node3);
};
var getScrollVariables = function(axis, node3) {
  return axis === "v" ? getVScrollVariables(node3) : getHScrollVariables(node3);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id4) {
  return "\n  .block-interactivity-".concat(id4, " {pointer-events: none;}\n  .allow-interactivity-").concat(id4, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props2) {
  var shouldPreventQueue = React18.useRef([]);
  var touchStartRef = React18.useRef([0, 0]);
  var activeAxis = React18.useRef();
  var id4 = React18.useState(idCounter++)[0];
  var Style2 = React18.useState(styleSingleton)[0];
  var lastProps = React18.useRef(props2);
  React18.useEffect(function() {
    lastProps.current = props2;
  }, [props2]);
  React18.useEffect(function() {
    if (props2.inert) {
      document.body.classList.add("block-interactivity-".concat(id4));
      var allow_1 = __spreadArray([props2.lockRef.current], (props2.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id4));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id4));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id4));
        });
      };
    }
    return;
  }, [props2.inert, props2.lockRef.current, props2.shards]);
  var shouldCancelEvent = React18.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React18.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node3) {
        return node3.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React18.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React18.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React18.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  var scrollTouchMove = React18.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  React18.useEffect(function() {
    lockStack.push(Style2);
    props2.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props2.removeScrollBar, inert = props2.inert;
  return React18.createElement(
    React18.Fragment,
    null,
    inert ? React18.createElement(Style2, { styles: generateStyle(id4) }) : null,
    removeScrollBar ? React18.createElement(RemoveScrollBar, { gapMode: props2.gapMode }) : null
  );
}
function getOutermostShadowParent(node3) {
  var shadowParent = null;
  while (node3 !== null) {
    if (node3 instanceof ShadowRoot) {
      shadowParent = node3.host;
      node3 = node3.host;
    }
    node3 = node3.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React19.forwardRef(function(props2, ref) {
  return React19.createElement(RemoveScroll, __assign({}, props2, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@yamada-ui/loading/dist/chunk-ONPENPM5.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var LoadingContext = (0, import_react69.createContext)({});
var createLoadingRefs = () => ({
  isLoading: (0, import_react69.createRef)(),
  start: (0, import_react69.createRef)(),
  finish: (0, import_react69.createRef)(),
  update: (0, import_react69.createRef)(),
  force: (0, import_react69.createRef)()
});
var createLoadingFunc = (refs) => ({
  isLoading: () => {
    var _a, _b, _c;
    return (_c = (_b = (_a = refs.current.isLoading).current) == null ? void 0 : _b.call(_a)) != null ? _c : false;
  },
  start: (props2) => {
    var _a, _b;
    return (_b = (_a = refs.current.start).current) == null ? void 0 : _b.call(_a, props2);
  },
  finish: () => {
    var _a, _b;
    return (_b = (_a = refs.current.finish).current) == null ? void 0 : _b.call(_a);
  },
  update: (props2) => {
    var _a, _b;
    return (_b = (_a = refs.current.update).current) == null ? void 0 : _b.call(_a, props2);
  },
  force: (state) => {
    var _a, _b;
    return (_b = (_a = refs.current.force).current) == null ? void 0 : _b.call(_a, state);
  }
});
var incrementCount = (prev2) => prev2 + 1;
var decrementCount = (prev2) => prev2 === 0 ? prev2 : prev2 - 1;
var LoadingProvider = ({
  screen,
  page,
  background,
  custom,
  children
}) => {
  var _a, _b, _c, _d, _e;
  const screenRefs = (0, import_react69.useRef)(createLoadingRefs());
  const pageRefs = (0, import_react69.useRef)(createLoadingRefs());
  const backgroundRefs = (0, import_react69.useRef)(createLoadingRefs());
  const customRefs = (0, import_react69.useRef)(createLoadingRefs());
  const screenLoadingFunc = createLoadingFunc(screenRefs);
  const pageLoadingFunc = createLoadingFunc(pageRefs);
  const backgroundLoadingFunc = createLoadingFunc(backgroundRefs);
  const customLoadingFunc = createLoadingFunc(customRefs);
  const value = {
    screen: screenLoadingFunc,
    page: pageLoadingFunc,
    background: backgroundLoadingFunc,
    custom: customLoadingFunc
  };
  return (0, import_jsx_runtime30.jsxs)(LoadingContext.Provider, { value, children: [
    children,
    (0, import_jsx_runtime30.jsx)(
      Controller,
      {
        controlRefs: screenRefs,
        ...screen,
        component: (_a = screen == null ? void 0 : screen.component) != null ? _a : (props2) => (0, import_jsx_runtime30.jsx)(ScreenComponent, { ...props2 })
      }
    ),
    (0, import_jsx_runtime30.jsx)(
      Controller,
      {
        controlRefs: pageRefs,
        ...page,
        component: (_b = page == null ? void 0 : page.component) != null ? _b : (props2) => (0, import_jsx_runtime30.jsx)(PageComponent, { ...props2 })
      }
    ),
    (0, import_jsx_runtime30.jsx)(
      Controller,
      {
        controlRefs: backgroundRefs,
        ...background,
        blockScrollOnMount: (_c = background == null ? void 0 : background.blockScrollOnMount) != null ? _c : false,
        component: (_d = background == null ? void 0 : background.component) != null ? _d : (props2) => (0, import_jsx_runtime30.jsx)(BackgroundComponent, { ...props2 })
      }
    ),
    (0, import_jsx_runtime30.jsx)(
      Controller,
      {
        controlRefs: customRefs,
        blockScrollOnMount: (_e = background == null ? void 0 : background.blockScrollOnMount) != null ? _e : false,
        ...custom,
        component: custom == null ? void 0 : custom.component
      }
    )
  ] });
};
var Controller = ({
  controlRefs,
  appendToParentPortal,
  containerRef,
  allowPinchZoom = false,
  blockScrollOnMount = true,
  initialState: initialState2,
  duration: durationProps = null,
  icon,
  text,
  component
}) => {
  const isLoadingRef = (0, import_react69.useRef)(false);
  const [{ loadingCount, message, duration }, setState] = (0, import_react69.useState)({
    loadingCount: initialState2 ? 1 : 0,
    message: void 0,
    duration: durationProps
  });
  const { isLoading, start: start2, finish, update, force } = (0, import_react69.useMemo)(
    () => ({
      isLoading: () => isLoadingRef.current,
      start: ({ message: message2, duration: duration2 = durationProps } = {}) => {
        isLoadingRef.current = true;
        setState(({ loadingCount: loadingCount2 }) => ({
          loadingCount: incrementCount(loadingCount2),
          message: message2,
          duration: duration2
        }));
      },
      update: (next2) => setState((prev2) => ({ ...prev2, ...next2 })),
      finish: () => {
        isLoadingRef.current = false;
        setState(({ loadingCount: loadingCount2 }) => ({
          loadingCount: decrementCount(loadingCount2),
          message: void 0,
          duration: durationProps
        }));
      },
      force: ({ loadingCount: loadingCount2 = 0, message: message2, duration: duration2 = durationProps }) => {
        isLoadingRef.current = !!loadingCount2;
        setState({
          loadingCount: loadingCount2,
          message: message2,
          duration: duration2
        });
      }
    }),
    [durationProps]
  );
  assignRef(controlRefs.current.isLoading, isLoading);
  assignRef(controlRefs.current.start, start2);
  assignRef(controlRefs.current.finish, finish);
  assignRef(controlRefs.current.update, update);
  assignRef(controlRefs.current.force, force);
  const props2 = {
    initialState: initialState2,
    icon,
    text,
    message,
    duration,
    onFinish: finish
  };
  useUpdateEffect(() => {
    if (initialState2 || isNumber(durationProps))
      setState({
        loadingCount: initialState2 ? 1 : 0,
        message: void 0,
        duration: durationProps
      });
  }, [initialState2, durationProps]);
  return (0, import_jsx_runtime30.jsx)(AnimatePresence, { initial: false, children: loadingCount ? (0, import_jsx_runtime30.jsx)(
    Portal,
    {
      appendToParentPortal,
      containerRef,
      children: (0, import_jsx_runtime30.jsx)(
        Combination_default,
        {
          allowPinchZoom,
          enabled: blockScrollOnMount,
          forwardProps: true,
          children: (0, import_jsx_runtime30.jsx)(import_react69.Fragment, { children: (0, import_jsx_runtime30.jsx)(Render, { component, ...props2 }) })
        }
      )
    }
  ) : null });
};
var Render = ({ component, ...props2 }) => {
  if (typeof component === "function") {
    return component(props2);
  } else {
    return (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, {});
  }
};
var Message = ({ message, ...rest }) => {
  return message ? isValidElement2(message) ? message : (0, import_jsx_runtime30.jsx)(ui.p, { ...rest, children: message }) : null;
};
var getVariants = (type = "fade") => ({
  initial: {
    opacity: 0,
    scale: type === "scaleFade" ? 0.95 : void 0
  },
  animate: {
    opacity: 1,
    scale: type === "scaleFade" ? 1 : void 0,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: type === "scaleFade" ? 0.95 : void 0,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 1, 1]
    }
  }
});
var getOverlayStyle = (type = "fill") => ({
  position: "fixed",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  zIndex: "fallback(beerus, 9999)",
  bg: type === "fill" ? ["fallback(white, #fbfbfb)", "fallback(black, #141414)"] : "fallback(blackAlpha.600, rgba(0, 0, 0, 0.48))",
  w: "100vw",
  h: "100dvh",
  p: "fallback(4, 1rem)",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
var getMotionProps = (initialState2, type = "fade") => ({
  initial: initialState2 ? false : "initial",
  animate: "animate",
  exit: "exit",
  variants: getVariants(type)
});
var ScreenComponent = (0, import_react69.memo)(
  ({
    initialState: initialState2,
    icon,
    text,
    message,
    duration,
    onFinish
  }) => {
    const css4 = {
      maxW: "24rem",
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      gap: "fallback(2, 0.5rem)"
    };
    useTimeout(onFinish, duration);
    return (0, import_jsx_runtime30.jsx)(
      Motion,
      {
        className: "ui-loading-screen",
        ...getMotionProps(initialState2),
        __css: getOverlayStyle(),
        children: (0, import_jsx_runtime30.jsxs)(ui.div, { __css: css4, children: [
          (0, import_jsx_runtime30.jsx)(Loading, { size: "6xl", ...icon }),
          (0, import_jsx_runtime30.jsx)(Message, { message, lineClamp: 3, ...text })
        ] })
      }
    );
  }
);
ScreenComponent.displayName = "ScreenComponent";
var PageComponent = (0, import_react69.memo)(
  ({
    initialState: initialState2,
    icon,
    text,
    message,
    duration,
    onFinish
  }) => {
    const css4 = {
      bg: ["fallback(white, #fbfbfb)", "fallback(black, #141414)"],
      maxW: "24rem",
      p: "fallback(4, 1rem)",
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      gap: "fallback(2, 0.5rem)",
      rounded: "fallback(md, 0.375rem)",
      boxShadow: [
        "fallback(lg, 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05))",
        "fallback(dark-lg, 0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px 5px 10px rgba(0, 0, 0, 0.2), 0px 15px 40px rgba(0, 0, 0, 0.4))"
      ]
    };
    useTimeout(onFinish, duration);
    return (0, import_jsx_runtime30.jsx)(
      Motion,
      {
        className: "ui-loading-page",
        ...getMotionProps(initialState2),
        __css: getOverlayStyle("transparent"),
        children: (0, import_jsx_runtime30.jsxs)(
          ui.div,
          {
            as: motion.div,
            className: "ui-loading-page__inner",
            ...getMotionProps(initialState2, "scaleFade"),
            __css: css4,
            children: [
              (0, import_jsx_runtime30.jsx)(Loading, { size: "6xl", ...icon }),
              (0, import_jsx_runtime30.jsx)(Message, { message, lineClamp: 3, ...text })
            ]
          }
        )
      }
    );
  }
);
PageComponent.displayName = "PageComponent";
var BackgroundComponent = (0, import_react69.memo)(
  ({
    initialState: initialState2,
    icon,
    text,
    message,
    duration,
    onFinish
  }) => {
    const css4 = {
      position: "fixed",
      right: "fallback(4, 1rem)",
      bottom: "fallback(4, 1rem)",
      zIndex: "fallback(beerus, 9999)",
      bg: ["fallback(white, #fbfbfb)", "fallback(black, #141414)"],
      maxW: "20rem",
      p: "fallback(2, 0.5rem)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gap: "fallback(2, 0.5rem)",
      rounded: "fallback(md, 0.375rem)",
      boxShadow: [
        "fallback(3xl, 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 -25px 50px -12px rgba(0, 0, 0, 0.25))",
        "fallback(dark-lg, 0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px 5px 10px rgba(0, 0, 0, 0.2), 0px 15px 40px rgba(0, 0, 0, 0.4))"
      ]
    };
    useTimeout(onFinish, duration);
    return (0, import_jsx_runtime30.jsxs)(
      Motion,
      {
        className: "ui-loading-background",
        ...getMotionProps(initialState2, "scaleFade"),
        __css: css4,
        children: [
          (0, import_jsx_runtime30.jsx)(Loading, { size: "xl", ...icon }),
          (0, import_jsx_runtime30.jsx)(Message, { message, fontSize: "sm", lineClamp: 1, ...text })
        ]
      }
    );
  }
);
BackgroundComponent.displayName = "BackgroundComponent";
var useLoading = () => {
  const { screen, page, background, custom } = (0, import_react69.useContext)(LoadingContext);
  return { screen, page, background, custom };
};

// node_modules/@yamada-ui/alert/dist/chunk-5JHXAL6A.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var defaultStatuses = {
  info: { icon: InfoIcon, colorScheme: "info" },
  success: { icon: CheckIcon, colorScheme: "success" },
  warning: { icon: WarningIcon, colorScheme: "warning" },
  error: { icon: WarningIcon, colorScheme: "danger" },
  loading: { icon: Loading, colorScheme: "primary" }
};
var [AlertProvider, useAlert] = createContext2({
  name: `AlertStylesContext`,
  errorMessage: `useAlert returned is 'undefined'. Seems you forgot to wrap the components in "<Alert />" `
});
var getStatusColorScheme = (status, statuses) => {
  var _a, _b;
  return (_b = (_a = statuses == null ? void 0 : statuses[status]) == null ? void 0 : _a.colorScheme) != null ? _b : defaultStatuses[status].colorScheme;
};
var getStatusIcon = (status, statuses) => {
  var _a, _b;
  return (_b = (_a = statuses == null ? void 0 : statuses[status]) == null ? void 0 : _a.icon) != null ? _b : defaultStatuses[status].icon;
};
var Alert = forwardRef22(
  ({ status = "info", colorScheme, ...props2 }, ref) => {
    var _a, _b, _c;
    const { theme } = useTheme2();
    const statuses = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.alert) == null ? void 0 : _b.statuses) != null ? _c : {};
    colorScheme != null ? colorScheme : colorScheme = getStatusColorScheme(status, statuses);
    const [styles2, mergedProps] = useMultiComponentStyle("Alert", {
      ...props2,
      colorScheme
    });
    const { className, children, ...rest } = omitThemeProps(mergedProps);
    const css4 = {
      w: "100%",
      display: "flex",
      alignItems: "center",
      position: "relative",
      overflow: "hidden",
      ...styles2.container
    };
    return (0, import_jsx_runtime31.jsx)(AlertProvider, { value: { status, styles: styles2 }, children: (0, import_jsx_runtime31.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-alert", className),
        role: "alert",
        __css: css4,
        ...rest,
        children
      }
    ) });
  }
);
var AlertIcon = ({
  className,
  children,
  variant = "oval",
  ...rest
}) => {
  var _a, _b, _c;
  const { status, styles: styles2 } = useAlert();
  const { theme } = useTheme2();
  const statuses = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.alert) == null ? void 0 : _b.statuses) != null ? _c : {};
  const Icon4 = getStatusIcon(status, statuses);
  const css4 = {
    ...styles2.icon,
    ...status === "loading" ? styles2.loading : {}
  };
  return (0, import_jsx_runtime31.jsx)(
    ui.span,
    {
      display: "inherit",
      className: cx("ui-alert__icon", className),
      __css: css4,
      ...rest,
      children: children || (0, import_jsx_runtime31.jsx)(
        Icon4,
        {
          ...status === "loading" ? { variant, color: "currentcolor" } : { boxSize: "100%" }
        }
      )
    }
  );
};
var AlertTitle = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useAlert();
    const css4 = {
      display: "block",
      ...styles2.title
    };
    return (0, import_jsx_runtime31.jsx)(
      ui.p,
      {
        ref,
        className: cx("ui-alert__title", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var AlertDescription = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useAlert();
    const css4 = {
      ...styles2.description
    };
    return (0, import_jsx_runtime31.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-alert__desc", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/ripple/dist/chunk-OXCWUOIP.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var clamp2 = (value, min2, max2) => Math.min(Math.max(value, min2), max2);
var Ripple = ({
  className,
  ripples,
  onAnimationComplete,
  onClear,
  color: color2 = "currentColor",
  style,
  isDisabled: isDisabled2,
  ...rest
}) => {
  if (isDisabled2) return null;
  const css4 = {
    rounded: "fallback(full, 9999px)",
    zIndex: "fallback(kurillin, 9)"
  };
  return (0, import_jsx_runtime32.jsx)(import_jsx_runtime32.Fragment, { children: ripples.map(({ key, x, y, size }) => {
    const duration = clamp2(0.01 * size, 0.2, size > 100 ? 0.75 : 0.5);
    return (0, import_jsx_runtime32.jsx)(AnimatePresence, { mode: "popLayout", children: (0, import_jsx_runtime32.jsx)(
      Motion,
      {
        as: "span",
        className: cx("ui-ripple", className),
        initial: { transform: "scale(0)", opacity: 0.35 },
        animate: { transform: "scale(2)", opacity: 0 },
        exit: { opacity: 0 },
        transition: { duration },
        bgColor: color2,
        style: {
          position: "absolute",
          transformOrigin: "center",
          pointerEvents: "none",
          left: x,
          top: y,
          width: `${size}px`,
          height: `${size}px`,
          ...style
        },
        __css: css4,
        ...rest,
        onAnimationComplete: handlerAll(
          onAnimationComplete,
          () => onClear(key)
        )
      }
    ) }, key);
  }) });
};

// node_modules/@yamada-ui/ripple/dist/chunk-Y7JVYJGR.mjs
var import_react70 = __toESM(require_react(), 1);
var useRipple = ({
  disabled,
  isDisabled: isDisabled2,
  ...rest
} = {}) => {
  const [ripples, setRipples] = (0, import_react70.useState)([]);
  const onPointerDown = (0, import_react70.useCallback)(
    (ev) => {
      if (disabled || isDisabled2) return setRipples([]);
      const trigger2 = ev.currentTarget;
      const size = Math.max(trigger2.clientWidth, trigger2.clientHeight);
      const rect = trigger2.getBoundingClientRect();
      setRipples((prev2) => [
        ...prev2,
        {
          key: createId(prev2.length.toString()),
          size,
          x: ev.clientX - rect.x - size / 2,
          y: ev.clientY - rect.y - size / 2
        }
      ]);
    },
    [disabled, isDisabled2]
  );
  const onClear = (0, import_react70.useCallback)((key) => {
    setRipples((prev2) => prev2.filter((item) => item.key !== key));
  }, []);
  return {
    ripples,
    onPointerDown: handlerAll(onPointerDown, rest.onPointerDown),
    onClear
  };
};

// node_modules/@yamada-ui/close-button/dist/chunk-LF7HRRGI.mjs
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var CloseButton = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useComponentStyle("CloseButton", props2);
    const {
      className,
      children,
      isDisabled: isDisabled2,
      isRounded,
      __css,
      disableRipple,
      ...rest
    } = omitThemeProps(mergedProps);
    const { onPointerDown, ...rippleProps } = useRipple({
      ...rest,
      isDisabled: disableRipple || isDisabled2
    });
    const css4 = {
      position: "relative",
      overflow: "hidden",
      outline: 0,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: 0,
      ...styles2,
      ...__css,
      ...isRounded ? { borderRadius: "fallback(full, 9999px)" } : {}
    };
    return (0, import_jsx_runtime33.jsxs)(
      ui.button,
      {
        ref,
        type: "button",
        "aria-label": "Close",
        className: cx("ui-close-button", className),
        disabled: isDisabled2,
        __css: css4,
        ...rest,
        onPointerDown,
        children: [
          children || (0, import_jsx_runtime33.jsx)(CloseIcon, { width: "1em", height: "1em" }),
          (0, import_jsx_runtime33.jsx)(Ripple, { isDisabled: disableRipple || isDisabled2, ...rippleProps })
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/notice/dist/chunk-ZUN66NHW.mjs
var import_react71 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var findId = (options, id4) => options.find((notice) => notice.id === id4);
var findNotice = (state, id4) => {
  const placement = getNoticePlacement(state, id4);
  const index = placement ? state[placement].findIndex((notice) => notice.id === id4) : -1;
  return { placement, index };
};
var getNoticePlacement = (state, id4) => {
  for (const [placement, values] of Object.entries(state)) {
    if (findId(values, id4)) return placement;
  }
};
var counter = 0;
var createNotice = (message, {
  id: id4,
  placement = "top",
  duration,
  onCloseComplete,
  status,
  style
}) => {
  counter += 1;
  id4 != null ? id4 : id4 = counter;
  return {
    id: id4,
    placement,
    status,
    duration,
    message,
    onDelete: () => noticeStore.remove(String(id4), placement),
    isDelete: false,
    onCloseComplete,
    style
  };
};
var createRender = (options) => {
  const { component } = options;
  const Render2 = (props2) => {
    if (typeof component === "function") {
      return component({ ...props2, ...options });
    } else {
      return (0, import_jsx_runtime34.jsx)(Notice, { ...props2, ...options });
    }
  };
  return Render2;
};
var createNoticeFunc = (defaultOptions2, theme) => {
  var _a, _b, _c;
  const themeOptions = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.notice) == null ? void 0 : _b.options) != null ? _c : {};
  const computedOptions = (options) => merge(themeOptions, merge(defaultOptions2, options));
  const notice = (options = {}) => {
    options = computedOptions(options);
    const message = createRender(options);
    return noticeStore.create(message, options);
  };
  notice.update = (id4, options) => {
    options = computedOptions(options);
    noticeStore.update(id4, options);
  };
  notice.closeAll = noticeStore.closeAll;
  notice.close = noticeStore.close;
  notice.isActive = noticeStore.isActive;
  return notice;
};
var useNotice = (defaultOptions2) => {
  const { theme } = useTheme2();
  return (0, import_react71.useMemo)(
    () => createNoticeFunc(defaultOptions2 != null ? defaultOptions2 : {}, theme),
    [defaultOptions2, theme]
  );
};
var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  bottom: [],
  "bottom-left": [],
  "bottom-right": []
};
var createNoticeStore = (initialState2) => {
  let state = initialState2;
  const storeChangeCache = /* @__PURE__ */ new Set();
  const setState = (setStateFunc) => {
    state = setStateFunc(state);
    storeChangeCache.forEach((onStoreChange) => onStoreChange());
  };
  return {
    getSnapshot: () => state,
    subscribe: (onStoreChange) => {
      storeChangeCache.add(onStoreChange);
      return () => {
        setState(() => initialState2);
        storeChangeCache.delete(onStoreChange);
      };
    },
    remove: (id4, placement) => {
      setState((prevState) => ({
        ...prevState,
        [placement]: prevState[placement].filter((notice) => notice.id != id4)
      }));
    },
    create: (message, options) => {
      const limit = options.limit;
      const notice = createNotice(message, options);
      const { placement, id: id4 } = notice;
      setState((prev2) => {
        var _a;
        let prevNotices = (_a = prev2[placement]) != null ? _a : [];
        if (limit !== void 0 && limit > 0 && prevNotices.length > limit - 1) {
          const n = prevNotices.length - (limit - 1);
          const notices2 = placement.includes("top") ? prevNotices.slice(n * -1) : prevNotices.slice(0, n);
          const ids = notices2.map(({ id: id22 }) => id22);
          prevNotices = prevNotices.map(
            (notice2) => ids.includes(notice2.id) ? { ...notice2, isDelete: true } : notice2
          );
        }
        const notices = placement.includes("top") ? [notice, ...prevNotices] : [...prevNotices, notice];
        return { ...prev2, [placement]: notices };
      });
      return id4;
    },
    update: (id4, options) => {
      setState((prev2) => {
        const next2 = { ...prev2 };
        const { placement, index } = findNotice(next2, id4);
        if (placement && index !== -1) {
          next2[placement][index] = {
            ...next2[placement][index],
            ...options,
            message: createRender(options)
          };
        }
        return next2;
      });
    },
    closeAll: ({ placement } = {}) => {
      setState((prev2) => {
        let placements2 = [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ];
        if (placement) placements2 = placement;
        return placements2.reduce(
          (acc, placement2) => {
            acc[placement2] = prev2[placement2].map((notice) => ({
              ...notice,
              isDelete: true
            }));
            return acc;
          },
          { ...prev2 }
        );
      });
    },
    close: (id4) => {
      setState((prev2) => {
        const placement = getNoticePlacement(prev2, id4);
        if (!placement) return prev2;
        return {
          ...prev2,
          [placement]: prev2[placement].map(
            (notice) => notice.id == id4 ? { ...notice, isDelete: true } : notice
          )
        };
      });
    },
    isActive: (id4) => Boolean(findNotice(noticeStore.getSnapshot(), id4).placement)
  };
};
var noticeStore = createNoticeStore(initialState);
var Notice = ({
  variant = "basic",
  colorScheme,
  status,
  icon,
  title,
  description,
  isClosable,
  closeStrategy = "button",
  className,
  onClose
}) => {
  const isButtonClosable = isClosable && (closeStrategy === "button" || closeStrategy === "both");
  const isElementClosable = isClosable && (closeStrategy === "element" || closeStrategy === "both");
  return (0, import_jsx_runtime34.jsxs)(
    Alert,
    {
      status,
      variant,
      colorScheme,
      alignItems: "start",
      boxShadow: "fallback(lg, 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05))",
      className: cx("ui-notice", className),
      pe: isButtonClosable ? 8 : void 0,
      onClick: isElementClosable ? onClose : void 0,
      children: [
        (0, import_jsx_runtime34.jsx)(
          AlertIcon,
          {
            variant: icon == null ? void 0 : icon.variant,
            className: "ui-notice__icon",
            ...(icon == null ? void 0 : icon.color) ? { color: icon.color } : {},
            children: icon == null ? void 0 : icon.children
          }
        ),
        (0, import_jsx_runtime34.jsxs)(ui.div, { flex: "1", children: [
          title ? (0, import_jsx_runtime34.jsx)(AlertTitle, { className: "ui-notice__title", lineClamp: 1, children: title }) : null,
          description ? (0, import_jsx_runtime34.jsx)(AlertDescription, { className: "ui-notice__desc", lineClamp: 3, children: description }) : null
        ] }),
        isButtonClosable ? (0, import_jsx_runtime34.jsx)(
          CloseButton,
          {
            className: "ui-notice__close-button",
            size: "sm",
            onClick: (ev) => {
              ev.stopPropagation();
              onClose == null ? void 0 : onClose();
            },
            position: "absolute",
            top: 2,
            right: 2
          }
        ) : null
      ]
    }
  );
};

// node_modules/@yamada-ui/notice/dist/chunk-S6S7WOIN.mjs
var import_react72 = __toESM(require_react(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var NoticeProvider = ({
  variants: variants6,
  gap = "fallback(4, 1rem)",
  appendToParentPortal,
  listProps,
  itemProps,
  containerRef
}) => {
  const state = (0, import_react72.useSyncExternalStore)(
    noticeStore.subscribe,
    noticeStore.getSnapshot,
    noticeStore.getSnapshot
  );
  const components2 = Object.entries(state).map(([placement, notices]) => {
    const top2 = placement.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
    const bottom2 = placement.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
    const right2 = !placement.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
    const left2 = !placement.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
    const css4 = {
      position: "fixed",
      zIndex: "fallback(zarbon, 160)",
      pointerEvents: "none",
      display: "flex",
      flexDirection: "column",
      margin: gap,
      gap,
      top: top2,
      bottom: bottom2,
      right: right2,
      left: left2
    };
    return (0, import_jsx_runtime35.jsx)(
      ui.ul,
      {
        className: cx("ui-notice__list", `ui-notice__list--${placement}`),
        __css: css4,
        ...listProps,
        children: (0, import_jsx_runtime35.jsx)(AnimatePresence, { initial: false, children: notices.map((notice) => (0, import_jsx_runtime35.jsx)(
          NoticeComponent,
          {
            variants: variants6,
            itemProps,
            ...notice
          },
          notice.id
        )) })
      },
      placement
    );
  });
  return (0, import_jsx_runtime35.jsx)(
    Portal,
    {
      appendToParentPortal,
      containerRef,
      children: components2
    }
  );
};
var defaultVariants = {
  initial: ({ placement }) => ({
    opacity: 0,
    [["top", "bottom"].includes(placement) ? "y" : "x"]: (placement === "bottom" ? 1 : placement.includes("right") ? 1 : -1) * 24
  }),
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var NoticeComponent = (0, import_react72.memo)(
  ({
    variants: variants6 = defaultVariants,
    itemProps,
    placement,
    duration = 5e3,
    message,
    onCloseComplete,
    isDelete = false,
    onDelete,
    style
  }) => {
    const [delay2, setDelay] = (0, import_react72.useState)(duration);
    const isPresent2 = useIsPresent();
    useUpdateEffect(() => {
      if (!isPresent2) onCloseComplete == null ? void 0 : onCloseComplete();
    }, [isPresent2]);
    useUpdateEffect(() => {
      setDelay(duration);
    }, [duration]);
    const onMouseEnter = () => setDelay(null);
    const onMouseLeave = () => setDelay(duration);
    const onClose = () => {
      if (isPresent2) onDelete();
    };
    (0, import_react72.useEffect)(() => {
      if (isPresent2 && isDelete) onDelete();
    }, [isPresent2, isDelete, onDelete]);
    useTimeout(onClose, delay2);
    const css4 = {
      pointerEvents: "auto",
      maxW: "36rem",
      minW: "20rem",
      ...style
    };
    return (0, import_jsx_runtime35.jsx)(
      motion.li,
      {
        layout: true,
        className: "ui-notice__list__item",
        variants: variants6,
        initial: "initial",
        animate: "animate",
        exit: "exit",
        onHoverStart: onMouseEnter,
        onHoverEnd: onMouseLeave,
        custom: { placement },
        style: {
          display: "flex",
          justifyContent: placement.includes("left") ? "flex-start" : placement.includes("right") ? "flex-end" : "center"
        },
        ...itemProps,
        children: (0, import_jsx_runtime35.jsx)(ui.div, { className: "ui-notice__list__item__inner", __css: css4, children: runIfFunc(message, { onClose }) })
      }
    );
  }
);
NoticeComponent.displayName = "NoticeComponent";

// node_modules/@yamada-ui/theme/dist/chunk-3XQQD3E2.mjs
var radii = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};

// node_modules/@yamada-ui/theme/dist/chunk-4BWBDE56.mjs
var shadows = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  "3xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 -25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgb(0, 112, 240)",
  inline: "inset 0 0 0 3px rgb(0, 112, 240)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-sm": "0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.2)",
  "dark-md": "0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px 5px 10px rgba(0, 0, 0, 0.2)",
  "dark-lg": "0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px 5px 10px rgba(0, 0, 0, 0.2), 0px 15px 40px rgba(0, 0, 0, 0.4)"
};

// node_modules/@yamada-ui/theme/dist/chunk-RUNE52FF.mjs
var spaces = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  4.5: "1.125rem",
  5: "1.25rem",
  5.5: "1.375rem",
  6: "1.5rem",
  6.5: "1.625rem",
  7: "1.75rem",
  7.5: "1.875rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  11: "2.75rem",
  12: "3rem",
  13: "3.25rem",
  14: "3.5rem",
  15: "3.75rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  68: "17rem",
  72: "18rem",
  76: "19rem",
  80: "20rem",
  84: "21rem",
  88: "22rem",
  92: "23rem",
  96: "24rem"
};

// node_modules/@yamada-ui/theme/dist/chunk-BB2TBY4W.mjs
var sizes = {
  ...spaces,
  max: "max-content",
  min: "min-content",
  full: "100%",
  "9xs": "1rem",
  "8xs": "1.5rem",
  "7xs": "2rem",
  "6xs": "3rem",
  "5xs": "4.5rem",
  "4xs": "6rem",
  "3xs": "7.5rem",
  "2xs": "10rem",
  xs: "15rem",
  sm: "20rem",
  md: "24rem",
  lg: "28rem",
  xl: "32rem",
  "2xl": "36rem",
  "3xl": "42rem",
  "4xl": "48rem",
  "5xl": "56rem",
  "6xl": "64rem",
  "7xl": "72rem",
  "8xl": "80rem",
  "9xl": "90rem"
};

// node_modules/@yamada-ui/theme/dist/chunk-WNOKWQK2.mjs
var transitions = {
  property: {
    common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
    colors: "background-color, border-color, color, fill, stroke",
    dimensions: "width, height",
    position: "left, right, top, bottom",
    background: "background-color, background-image, background-position"
  },
  easing: {
    "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
    "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
  },
  duration: {
    "ultra-fast": "50ms",
    faster: "100ms",
    fast: "150ms",
    normal: "200ms",
    slow: "300ms",
    slower: "400ms",
    "ultra-slow": "500ms"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-CBV63Z6O.mjs
var zIndices = {
  yamcha: 1,
  kurillin: 9,
  nappa: 99,
  guldo: 100,
  jeice: 110,
  burter: 120,
  recoome: 130,
  ginyu: 140,
  dodoria: 150,
  zarbon: 160,
  freeza: 9996,
  vegeta: 9997,
  sonGoku: 9998,
  beerus: 9999
};

// node_modules/@yamada-ui/theme/dist/chunk-EYJY2X5U.mjs
var colors = {
  transparent: "transparent",
  current: "currentColor",
  black: "#141414",
  white: "#fbfbfb",
  border: ["#dcdcde", "#434248"],
  focus: "#0070F0",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)",
    950: "rgba(255, 255, 255, 0.96)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)",
    950: "rgba(0, 0, 0, 0.96)"
  },
  gray: {
    50: "#dedfe3",
    100: "#d3d5da",
    200: "#b7bbc3",
    300: "#9ea3ae",
    400: "#828997",
    500: "#6b7280",
    600: "#565c67",
    700: "#434851",
    800: "#2e3138",
    900: "#1c1e21",
    950: "#101113"
  },
  neutral: {
    50: "#dedede",
    100: "#d4d4d4",
    200: "#bababa",
    300: "#a3a3a3",
    400: "#8a8a8a",
    500: "#737373",
    600: "#5c5c5c",
    700: "#474747",
    800: "#303030",
    900: "#1c1c1c",
    950: "#0f0f0f"
  },
  red: {
    50: "#fdeae8",
    100: "#fbd9d5",
    200: "#f6b2ac",
    300: "#f28c82",
    400: "#ee6a5d",
    500: "#ea4334",
    600: "#de2817",
    700: "#b42013",
    800: "#8a190f",
    900: "#66120b",
    950: "#530f09"
  },
  rose: {
    50: "#feecef",
    100: "#fdd8de",
    200: "#fbb2be",
    300: "#f88b9d",
    400: "#f6657d",
    500: "#f43e5c",
    600: "#f2183c",
    700: "#cf0c2d",
    800: "#a40a23",
    900: "#7d071b",
    950: "#650616"
  },
  pink: {
    50: "#fde8ed",
    100: "#fcd9e3",
    200: "#f9b9ca",
    300: "#f693ad",
    400: "#f37295",
    500: "#f0517c",
    600: "#ec275c",
    700: "#d81347",
    800: "#ae0f39",
    900: "#880c2d",
    950: "#710a25"
  },
  flashy: {
    50: "#fdedf5",
    100: "#fbdaeb",
    200: "#f7b5d6",
    300: "#f390c2",
    400: "#ef6bad",
    500: "#ec4699",
    600: "#e82185",
    700: "#c6156e",
    800: "#a21159",
    900: "#780d42",
    950: "#660b38"
  },
  orange: {
    50: "#fef0e6",
    100: "#fee4d2",
    200: "#fdc7a1",
    300: "#fbac74",
    400: "#fa9247",
    500: "#f97415",
    600: "#e06106",
    700: "#b34d05",
    800: "#863a03",
    900: "#5e2902",
    950: "#461e02"
  },
  amber: {
    50: "#fdf0d8",
    100: "#fde8c4",
    200: "#fbd593",
    300: "#f9c367",
    400: "#f7b23b",
    500: "#f59f0a",
    600: "#ce8509",
    700: "#a26907",
    800: "#764c05",
    900: "#4e3303",
    950: "#362302"
  },
  yellow: {
    50: "#fef4d7",
    100: "#feefc3",
    200: "#fde290",
    300: "#fdd663",
    400: "#fcc931",
    500: "#fbbd04",
    600: "#ce9b03",
    700: "#a67d03",
    800: "#795b02",
    900: "#503d01",
    950: "#372a01"
  },
  lime: {
    50: "#e7facc",
    100: "#ddf7b5",
    200: "#c7f287",
    300: "#b2ee59",
    400: "#9de92b",
    500: "#82cb15",
    600: "#6ba611",
    700: "#507d0d",
    800: "#385809",
    900: "#1e2e05",
    950: "#121c03"
  },
  green: {
    50: "#e0f5e6",
    100: "#d0f1d9",
    200: "#a9e5b9",
    300: "#86da9c",
    400: "#5fce7d",
    500: "#3cc360",
    600: "#31a04f",
    700: "#28813f",
    800: "#1d5e2e",
    900: "#133e1f",
    950: "#0d2b15"
  },
  emerald: {
    50: "#d0fbed",
    100: "#b4f8e2",
    200: "#80f4cd",
    300: "#4defb9",
    400: "#19eba5",
    500: "#10b77f",
    600: "#0d9165",
    700: "#096748",
    800: "#06422e",
    900: "#021710",
    950: "#000503"
  },
  teal: {
    50: "#cdf9f4",
    100: "#b1f6ee",
    200: "#7ef1e3",
    300: "#51ecda",
    400: "#1ee6cf",
    500: "#14b8a5",
    600: "#108e80",
    700: "#0c6a5f",
    800: "#07403a",
    900: "#031c19",
    950: "#010504"
  },
  cyan: {
    50: "#cef6fd",
    100: "#b0f1fd",
    200: "#7ee8fb",
    300: "#4de0f9",
    400: "#16d6f8",
    500: "#07b6d5",
    600: "#0590a8",
    700: "#046e81",
    800: "#034854",
    900: "#012228",
    950: "#011114"
  },
  sky: {
    50: "#ddf3fd",
    100: "#c5eafc",
    200: "#95d9f9",
    300: "#65c8f6",
    400: "#35b7f3",
    500: "#0da2e7",
    600: "#0b87c1",
    700: "#096995",
    800: "#064e6f",
    900: "#042f43",
    950: "#032230"
  },
  blue: {
    50: "#e2edfd",
    100: "#cfe0fc",
    200: "#adcbfa",
    300: "#8bb5f8",
    400: "#659cf6",
    500: "#4387f4",
    600: "#186bf2",
    700: "#0c59d4",
    800: "#0a47a9",
    900: "#07357d",
    950: "#062c6a"
  },
  indigo: {
    50: "#e8e8fd",
    100: "#d9dafc",
    200: "#bdbef9",
    300: "#9c9ef6",
    400: "#8082f4",
    500: "#6467f2",
    600: "#3a3dee",
    700: "#1417e6",
    800: "#1114c0",
    900: "#0d0f96",
    950: "#0b0d83"
  },
  violet: {
    50: "#eee7fe",
    100: "#e3d8fd",
    200: "#cbb6fb",
    300: "#b699fa",
    400: "#a17cf8",
    500: "#895af6",
    600: "#6d34f4",
    700: "#500ced",
    800: "#410ac2",
    900: "#34089b",
    950: "#2e0788"
  },
  purple: {
    50: "#f0e2fe",
    100: "#e9d3fd",
    200: "#d7b1fb",
    300: "#c994fa",
    400: "#b772f8",
    500: "#a855f7",
    600: "#9229f5",
    700: "#7e0bea",
    800: "#6609be",
    900: "#510797",
    950: "#44067f"
  },
  fuchsia: {
    50: "#f9e3fd",
    100: "#f5d0fb",
    200: "#eeaff8",
    300: "#e78af5",
    400: "#e069f2",
    500: "#d948ef",
    600: "#d01eeb",
    700: "#b112ca",
    800: "#900ea4",
    900: "#6b0b7a",
    950: "#5b0967"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-22GKOJSG.mjs
var fontSizes = {
  "2xs": "0.625rem",
  xs: "0.75rem",
  sm: "0.875rem",
  md: "1rem",
  lg: "1.125rem",
  xl: "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2rem",
  "5xl": "2.25rem",
  "6xl": "3rem",
  "7xl": "3.75rem",
  "8xl": "4.5rem",
  "9xl": "6rem"
};

// node_modules/@yamada-ui/theme/dist/chunk-N4EQCF4T.mjs
var fontWeights = {
  hairline: 100,
  thin: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  extrabold: 800,
  black: 900
};

// node_modules/@yamada-ui/theme/dist/chunk-DHWQUZ5F.mjs
var fonts = {
  heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "", YuGothic, "YuGothic M", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
  body: `-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "", YuGothic, "YuGothic M", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
  mono: `SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`
};

// node_modules/@yamada-ui/theme/dist/chunk-X3UYXSGT.mjs
var gradients = {};

// node_modules/@yamada-ui/theme/dist/chunk-BP77TBNE.mjs
var letterSpacings = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};

// node_modules/@yamada-ui/theme/dist/chunk-XJ67ODZ6.mjs
var lineHeights = {
  normal: "normal",
  none: 1,
  shorter: 1.25,
  short: 1.375,
  base: 1.5,
  tall: 1.625,
  taller: "2",
  "3": ".75rem",
  "4": "1rem",
  "5": "1.25rem",
  "6": "1.5rem",
  "7": "1.75rem",
  "8": "2rem",
  "9": "2.25rem",
  "10": "2.5rem"
};

// node_modules/@yamada-ui/theme/dist/chunk-DABNMQT3.mjs
var animations2 = {};

// node_modules/@yamada-ui/theme/dist/chunk-O3A6UE3R.mjs
var blurs = {
  sm: "4px",
  md: "8px",
  lg: "12px",
  xl: "16px",
  "2xl": "24px"
};

// node_modules/@yamada-ui/theme/dist/chunk-K4IL7QFL.mjs
var borders2 = {};

// node_modules/@yamada-ui/theme/dist/chunk-2FI5QN2D.mjs
var breakpoints = {
  sm: "30em",
  md: "48em",
  lg: "61em",
  xl: "80em",
  "2xl": "90em"
};

// node_modules/@yamada-ui/theme/dist/chunk-BMYVGBYC.mjs
var tokens = {
  animations: animations2,
  blurs,
  borders: borders2,
  breakpoints,
  colors,
  fontSizes,
  fontWeights,
  fonts,
  gradients,
  letterSpacings,
  lineHeights,
  radii,
  shadows,
  sizes,
  spaces,
  transitions,
  zIndices
};

// node_modules/@yamada-ui/theme/dist/chunk-C7XSZ4BL.mjs
var layerStyles = {};

// node_modules/@yamada-ui/theme/dist/chunk-VX22NJSN.mjs
var resetStyle = {
  "*": {
    boxSizing: "border-box"
  },
  "::before, ::after": {
    boxSizing: "inherit"
  },
  html: {
    lineHeight: 1.15,
    WebkitTextSizeAdjust: "100%",
    WebkitTapHighlightColor: "transparent"
  },
  body: {
    margin: 0
  },
  main: {
    display: "block"
  },
  "p, table, blockquote, address, pre, iframe, form, figure, dl": {
    margin: 0
  },
  "h1, h2, h3, h4, h5, h6": {
    fontSize: "inherit",
    lineHeight: "inherit",
    fontWeight: "inherit",
    margin: 0
  },
  "ul, ol": {
    margin: 0,
    padding: 0,
    listStyle: "none"
  },
  dt: {
    fontWeight: "bold"
  },
  dd: {
    marginLeft: 0
  },
  hr: {
    boxSizing: "content-box",
    height: 0,
    overflow: "visible",
    border: 0,
    borderTop: "1px solid",
    margin: 0,
    clear: "both",
    color: "inherit"
  },
  pre: {
    fontFamily: "monospace, monospace",
    fontSize: "inherit"
  },
  address: {
    fontStyle: "inherit"
  },
  a: {
    backgroundColor: "transparent",
    textDecoration: "none",
    color: "inherit"
  },
  "abbr[title]": {
    borderBottom: "none",
    textDecoration: "underline dotted"
  },
  "b, strong": {
    fontWeight: "bolder"
  },
  "code, kbd, samp": {
    fontFamily: "monospace, monospace",
    fontSize: "inherit"
  },
  small: {
    fontSize: "80%"
  },
  "sub, sup": {
    fontSize: "75%",
    lineHeight: 0,
    position: "relative",
    verticalAlign: "baseline"
  },
  sub: {
    bottom: "-0.25em"
  },
  sup: {
    top: "-0.5em"
  },
  img: {
    borderStyle: "none",
    verticalAlign: "bottom"
  },
  "embed, object, iframe": {
    border: 0,
    verticalAlign: "bottom"
  },
  "button, input, optgroup, select, textarea": {
    WebkitAppearance: "none",
    appearance: "none",
    verticalAlign: "middle",
    color: "inherit",
    font: "inherit",
    border: 0,
    background: "transparent",
    padding: 0,
    margin: 0,
    outline: 0,
    borderRadius: 0,
    textAlign: "inherit"
  },
  "[type='checkbox']": {
    WebkitAppearance: "checkbox",
    appearance: "checkbox"
  },
  "[type='radio']": {
    WebkitAppearance: "radio",
    appearance: "radio"
  },
  "button, input": {
    overflow: "visible"
  },
  "button, select": {
    textTransform: "none"
  },
  "button, [type='button'], [type='reset'], [type='submit']": {
    cursor: "pointer",
    WebkitAppearance: "none",
    appearance: "none"
  },
  "button[disabled], [type='button'][disabled], [type='reset'][disabled], [type='submit'][disabled]": {
    cursor: "default"
  },
  "button::-moz-focus-inner, [type='button']::-moz-focus-inner, [type='reset']::-moz-focus-inner, [type='submit']::-moz-focus-inner": {
    borderStyle: "none",
    padding: 0
  },
  "button:-moz-focusring, [type='button']:-moz-focusring, [type='reset']:-moz-focusring, [type='submit']:-moz-focusring": {
    outline: "1px dotted ButtonText"
  },
  "select::-ms-expand": {
    display: "none"
  },
  option: {
    padding: 0
  },
  fieldset: {
    margin: 0,
    padding: 0,
    minWidth: 0
  },
  legend: {
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: 0,
    whiteSpace: "normal"
  },
  progress: {
    verticalAlign: "baseline"
  },
  textarea: {
    overflow: "auto"
  },
  "[type='number']::-webkit-inner-spin-button, [type='number']::-webkit-outer-spin-button": {
    display: "none"
  },
  "[type='search']": {
    outlineOffset: "-2px"
  },
  "[type='search']::-webkit-search-decoration": {
    WebkitAppearance: "none"
  },
  "[type='time']::-webkit-calendar-picker-indicator": {
    display: "none"
  },
  "::-webkit-file-upload-button": {
    WebkitAppearance: "button",
    font: "inherit"
  },
  "::-webkit-search-cancel-button": {
    WebkitAppearance: "none"
  },
  "label[for]": {
    cursor: "pointer"
  },
  details: {
    display: "block"
  },
  summary: {
    display: "list-item"
  },
  "[contenteditable]": {
    outline: "none"
  },
  table: {
    borderCollapse: "collapse",
    borderSpacing: 0
  },
  caption: {
    textAlign: "left"
  },
  "td, th": {
    verticalAlign: "top",
    padding: 0
  },
  th: {
    textAlign: "left",
    fontWeight: "bold"
  },
  template: {
    display: "none"
  },
  "[hidden]": {
    display: "none !important"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WWB5QJGZ.mjs
var textStyles = {};

// node_modules/@yamada-ui/theme/dist/chunk-H3VOGY4T.mjs
var globalStyle = {
  body: {
    fontFamily: "body",
    bg: ["white", "black"],
    color: ["black", "white"],
    transitionProperty: "background-color",
    transitionDuration: "normal",
    lineHeight: "base",
    overflowX: "hidden"
  },
  "*::placeholder, *[data-placeholder]": {
    color: "blackAlpha.600"
  },
  _dark: {
    "*::placeholder, *[data-placeholder]": {
      color: "whiteAlpha.400"
    }
  },
  "*, *::before, *::after": {
    borderWidth: "0",
    borderStyle: "solid",
    borderColor: "border",
    wordWrap: "break-word"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-RDDRDBPR.mjs
var Tabs = {
  baseStyle: {
    container: ({ orientation }) => ({
      display: "flex",
      flexDirection: orientation === "vertical" ? "row" : "column"
    }),
    tabList: ({ align, orientation }) => ({
      flexDirection: orientation === "vertical" ? "column" : "row",
      justifyContent: align === "center" ? align : `flex-${align}`
    }),
    tab: ({ isFitted }) => ({
      flex: isFitted ? 1 : void 0,
      whiteSpace: "nowrap",
      transitionProperty: "common",
      transitionDuration: "normal",
      _hover: { opacity: 0.7 },
      _focusVisible: {
        zIndex: "yamcha",
        boxShadow: "outline"
      },
      _selected: { _hover: { opacity: 1 } },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.4
      }
    }),
    tabPanels: {},
    tabPanel: {
      p: "md"
    }
  },
  variants: {
    line: ({ colorScheme: c = "primary", orientation }) => {
      const isVertical = orientation === "vertical";
      return {
        tabList: {
          borderColor: "inherit",
          ...isVertical ? { borderEndWidth: "1px" } : { borderBottomWidth: "1px" }
        },
        tab: {
          borderColor: "transparent",
          _selected: {
            color: [`${c}.500`, isGray(c) ? `${c}.100` : `${c}.400`],
            borderColor: "currentColor"
          },
          ...isVertical ? {
            borderEndWidth: "1px",
            borderEndStyle: "solid",
            me: "-1px"
          } : {
            borderBottomWidth: "1px",
            borderBottomStyle: "solid",
            mb: "-1px"
          },
          _ripple: { display: "none" }
        }
      };
    },
    sticky: ({ colorScheme: c = "primary", orientation }) => {
      const isVertical = orientation === "vertical";
      return {
        tabList: {
          borderColor: "inherit",
          ...isVertical ? { borderEndWidth: "1px" } : { borderBottomWidth: "1px" }
        },
        tab: {
          borderColor: "transparent",
          _selected: {
            color: [`${c}.500`, isGray(c) ? `${c}.100` : `${c}.400`],
            borderColor: "inherit",
            ...isVertical ? { borderEndColor: ["white", "black"] } : { borderBottomColor: ["white", "black"] }
          },
          ...isVertical ? {
            roundedLeft: "md",
            borderWidth: "1px",
            borderStyle: "solid",
            me: "-2px"
          } : {
            roundedTop: "md",
            borderWidth: "1px",
            borderStyle: "solid",
            mb: "-2px"
          },
          _ripple: { display: "none" }
        }
      };
    },
    "sticky-subtle": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary",
      orientation
    }) => {
      const isVertical = orientation === "vertical";
      return {
        tabList: {
          borderColor: "inherit",
          ...isVertical ? { borderEndWidth: "1px" } : { borderBottomWidth: "1px" }
        },
        tab: {
          borderColor: "inherit",
          _notLast: {
            ...isVertical ? { borderBottom: "none" } : { borderEnd: "none" }
          },
          _selected: {
            bg: [
              isGray(c) ? `${c}.50` : `${c}.100`,
              shadeColor(`${c}.300`, 58)(t, m2)
            ],
            color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
          },
          ...isVertical ? {
            borderWidth: "1px",
            borderStyle: "solid",
            me: "-1px"
          } : {
            borderWidth: "1px",
            borderStyle: "solid",
            mb: "-1px"
          }
        }
      };
    },
    "sticky-solid": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary",
      orientation
    }) => {
      const isVertical = orientation === "vertical";
      return {
        tabList: {
          borderColor: "inherit",
          ...isVertical ? { borderEndWidth: "1px" } : { borderBottomWidth: "1px" }
        },
        tab: {
          borderColor: "inherit",
          _notLast: {
            ...isVertical ? { borderBottom: "none" } : { borderEnd: "none" }
          },
          _selected: {
            bg: [
              tintColor(`${c}.600`, 24)(t, m2),
              shadeColor(`${c}.600`, 16)(t, m2)
            ],
            color: `white`
          },
          ...isVertical ? {
            borderWidth: "1px",
            borderStyle: "solid",
            me: "-1px"
          } : {
            borderWidth: "1px",
            borderStyle: "solid",
            mb: "-1px"
          }
        }
      };
    },
    rounded: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => {
      const color2 = mode(
        getColor(`${c}.500`)(t, m2),
        getColor(isGray(c) ? `${c}.100` : `${c}.400`)(t, m2)
      )(m2);
      return {
        tabList: { gap: "sm" },
        tab: {
          borderRadius: "full",
          _selected: {
            color: color2,
            boxShadow: `inset 0 0 0px 1px ${color2}`
          }
        }
      };
    },
    "rounded-subtle": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary"
    }) => ({
      tabList: { gap: "sm" },
      tab: {
        borderRadius: "full",
        _selected: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 58)(t, m2)
          ],
          color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
        }
      }
    }),
    "rounded-solid": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary"
    }) => ({
      tabList: { gap: "sm" },
      tab: {
        borderRadius: "full",
        _selected: {
          bg: [
            tintColor(`${c}.600`, 24)(t, m2),
            shadeColor(`${c}.600`, 16)(t, m2)
          ],
          color: `white`
        }
      }
    }),
    unstyled: {
      tab: {
        _hover: { opacity: "inherit" },
        _ripple: { display: "none" }
      }
    }
  },
  sizes: {
    sm: {
      tab: {
        py: 1,
        px: 3,
        fontSize: "sm"
      }
    },
    md: {
      tab: {
        fontSize: "md",
        py: 2,
        px: 4
      }
    },
    lg: {
      tab: {
        fontSize: "lg",
        py: 3,
        px: 5
      }
    }
  },
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-MH2LXYY3.mjs
var Tag = {
  baseStyle: {
    container: {
      outline: 0,
      fontWeight: "medium",
      rounded: "md",
      _focusVisible: {
        boxShadow: "outline"
      }
    },
    label: {
      overflow: "visible"
    },
    closeButton: {
      transitionProperty: "common",
      transitionDuration: "normal",
      rounded: "full",
      opacity: 0.5,
      _disabled: {
        opacity: 0.4
      },
      _hover: {
        opacity: 0.8,
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        }
      },
      _active: {
        opacity: 1
      },
      _focusVisible: {
        boxShadow: "outline",
        bg: "rgba(0, 0, 0, 0.14)"
      }
    }
  },
  variants: {
    solid: {
      container: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
        bg: [tintColor(`${c}.600`, 24)(t, m2), shadeColor(`${c}.600`, 16)(t, m2)],
        color: `white`
      })
    },
    subtle: {
      container: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
        bg: [
          isGray(c) ? `${c}.50` : `${c}.100`,
          shadeColor(`${c}.300`, 58)(t, m2)
        ],
        color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
      })
    },
    outline: {
      container: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => {
        const color2 = mode(
          getColor(`${c}.500`)(t, m2),
          getColor(isGray(c) ? `${c}.100` : `${c}.400`)(t, m2)
        )(m2);
        return {
          color: color2,
          boxShadow: `inset 0 0 0px 1px ${color2}`
        };
      }
    }
  },
  sizes: {
    sm: ({ theme: t }) => ({
      container: {
        minH: "6",
        minW: "6",
        fontSize: "xs",
        px: "2",
        lineHeight: getMemoizedObject(t, "sizes.6")
      }
    }),
    md: ({ theme: t }) => ({
      container: {
        minH: "7",
        minW: "7",
        fontSize: "sm",
        px: "2",
        lineHeight: getMemoizedObject(t, "sizes.7")
      }
    }),
    lg: ({ theme: t }) => ({
      container: {
        minH: "8",
        minW: "8",
        fontSize: "md",
        px: "3",
        lineHeight: getMemoizedObject(t, "sizes.8")
      }
    })
  },
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-4BFUPEJM.mjs
var Text = {};

// node_modules/@yamada-ui/theme/dist/chunk-54HCMI6Q.mjs
var Input = {
  baseStyle: {
    container: {},
    field: {
      width: "100%",
      minWidth: 0,
      outline: 0,
      position: "relative",
      appearance: "none",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    },
    element: {
      color: ["blackAlpha.600", "whiteAlpha.700"]
    }
  },
  variants: {
    outline: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        field: {
          border: "1px solid",
          borderColor: "inherit",
          bg: "inherit",
          _hover: {
            borderColor: ["blackAlpha.500", "whiteAlpha.400"]
          },
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: [errorBorderColor, errorBorderColor],
            boxShadow: `0 0 0 1px ${errorBorderColor}`
          },
          _active: {
            borderColor: [focusBorderColor, focusBorderColor],
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          },
          _focusVisible: {
            zIndex: "yamcha",
            borderColor: [focusBorderColor, focusBorderColor],
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          }
        },
        addon: {
          border: "1px solid",
          borderColor: ["inherit", "whiteAlpha.50"],
          bg: ["blackAlpha.300", "whiteAlpha.300"]
        }
      };
    },
    filled: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        field: {
          border: "2px solid",
          borderColor: "transparent",
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _hover: {
            bg: ["blackAlpha.100", "whiteAlpha.100"]
          },
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: errorBorderColor,
            boxShadow: `0 0 0 1px ${errorBorderColor}`
          },
          _active: {
            bg: "transparent",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          },
          _focusVisible: {
            bg: "transparent",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          }
        },
        addon: {
          border: "2px solid transparent",
          bg: ["blackAlpha.300", "whiteAlpha.300"]
        }
      };
    },
    flushed: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        field: {
          borderBottom: "1px solid",
          borderColor: "inherit",
          rounded: "0",
          px: "0",
          bg: "transparent",
          _hover: {
            borderColor: ["blackAlpha.500", "whiteAlpha.400"]
          },
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: [errorBorderColor, errorBorderColor],
            boxShadow: `0px 1px 0px 0px ${errorBorderColor}`
          },
          _active: {
            borderColor: [focusBorderColor, focusBorderColor],
            boxShadow: `0px 1px 0px 0px ${focusBorderColor}`
          },
          _focusVisible: {
            borderColor: [focusBorderColor, focusBorderColor],
            boxShadow: `0px 1px 0px 0px ${focusBorderColor}`
          }
        },
        addon: {
          borderBottom: "1px solid",
          borderColor: "inherit",
          bg: "transparent",
          rounded: "0"
        }
      };
    },
    unstyled: {
      field: {
        bg: "transparent",
        minH: "auto",
        px: "0"
      },
      addon: {
        bg: "transparent",
        minH: "auto",
        px: "0"
      }
    }
  },
  sizes: {
    xs: {
      field: {
        fontSize: "xs",
        px: "2",
        minH: "6",
        rounded: "sm"
      },
      addon: {
        fontSize: "xs",
        px: "2",
        minH: "6",
        rounded: "sm"
      }
    },
    sm: {
      field: {
        fontSize: "sm",
        px: "2",
        minH: "8",
        rounded: "md"
      },
      addon: {
        fontSize: "sm",
        px: "2",
        minH: "8",
        rounded: "md"
      }
    },
    md: {
      field: {
        fontSize: "md",
        px: "3",
        minH: "10",
        rounded: "md"
      },
      addon: {
        fontSize: "md",
        px: "3",
        minH: "10",
        rounded: "md"
      }
    },
    lg: {
      field: {
        fontSize: "lg",
        px: "4",
        minH: "12",
        rounded: "md"
      },
      addon: {
        fontSize: "lg",
        px: "4",
        minH: "12",
        rounded: "md"
      }
    }
  },
  defaultProps: {
    size: "md",
    variant: "outline"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-SSZY3XTT.mjs
var Textarea = mergeStyle(
  pickStyle(Input, "field"),
  {
    baseStyle: {
      py: "2",
      lineHeight: "short",
      verticalAlign: "top"
    },
    variants: {
      unstyled: {
        h: "auto",
        py: "0",
        px: "0"
      }
    },
    sizes: {
      xs: {
        py: "2",
        minH: "20"
      },
      sm: {
        py: "2",
        minH: "20"
      },
      md: {
        py: "2",
        minH: "20"
      },
      lg: {
        py: "3",
        minH: "20"
      }
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-JGD6JCZ2.mjs
var Toggle = {
  baseStyle: {
    cursor: "pointer",
    rounded: "md",
    transitionProperty: "common",
    transitionDuration: "slower",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _readOnly: {
      cursor: "default",
      _ripple: {
        display: "none"
      }
    }
  },
  variants: {
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => {
      return {
        _hover: {
          bg: [
            isGray(c) ? `blackAlpha.200` : `${c}.50`,
            transparentizeColor(`${c}.500`, 0.12)(t, m2)
          ]
        },
        _selected: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ]
        },
        _focusVisible: {
          borderColor: "transparent",
          boxShadow: "outline"
        }
      };
    },
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => {
      return {
        _hover: {
          bg: [
            isGray(c) ? `blackAlpha.200` : `${c}.100`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ]
        },
        _selected: {
          bg: isGray(c) ? [`${c}.100`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`]
        },
        _focusVisible: {
          borderColor: "transparent",
          boxShadow: "outline"
        }
      };
    },
    outline: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => {
      return {
        border: "1px solid",
        borderColor: "border",
        _hover: {
          bg: [
            isGray(c) ? `blackAlpha.200` : `${c}.50`,
            transparentizeColor(`${c}.500`, 0.12)(t, m2)
          ]
        },
        _selected: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ],
          borderColor: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ]
        },
        _focusVisible: {
          boxShadow: "outline",
          _invalid: {
            borderColor: "transparent"
          }
        }
      };
    },
    unstyled: {
      bg: "none",
      color: "inherit",
      display: "inline",
      lineHeight: "inherit",
      m: 0,
      p: 0,
      _ripple: {
        display: "none"
      }
    }
  },
  sizes: {
    xs: ({ theme: t }) => ({
      minBoxSize: 6,
      fontSize: "xs",
      lineHeight: getMemoizedObject(t, "sizes.6")
    }),
    sm: ({ theme: t }) => ({
      minBoxSize: 8,
      fontSize: "sm",
      lineHeight: getMemoizedObject(t, "sizes.8")
    }),
    md: ({ theme: t }) => ({
      minBoxSize: 10,
      fontSize: "md",
      lineHeight: getMemoizedObject(t, "sizes.10")
    }),
    lg: ({ theme: t }) => ({
      minBoxSize: 12,
      fontSize: "lg",
      lineHeight: getMemoizedObject(t, "sizes.12")
    })
  },
  defaultProps: {
    variant: "subtle",
    size: "md",
    colorScheme: "gray"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-ZXMQ3MM2.mjs
var Tooltip = {
  baseStyle: {
    rounded: "md",
    bg: ["white", "black"],
    border: "1px solid",
    borderColor: ["blackAlpha.200", "whiteAlpha.100"],
    px: "sm",
    py: "0.5",
    fontWeight: "medium",
    fontSize: "sm",
    color: "inherit",
    boxShadow: ["md", "dark-md"],
    maxW: "xs",
    zIndex: "dodoria"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-I443LQYO.mjs
var NativeSelect = mergeMultiStyle(Input, {
  baseStyle: {
    container: {},
    field: {
      cursor: "pointer",
      pr: "8",
      pb: "px",
      _focus: {
        zIndex: "unset"
      },
      _readOnly: {
        pointerEvents: "none"
      },
      "& > option, optgroup": {
        bg: ["white", "black"]
      }
    },
    icon: {
      w: "6",
      py: "2",
      color: ["blackAlpha.600", "whiteAlpha.700"],
      fontSize: "xl",
      outline: 0,
      rounded: "md",
      _disabled: {
        opacity: 0.4
      }
    }
  },
  sizes: {
    xs: {
      icon: {
        pt: "3",
        fontSize: "lg",
        insetEnd: "1"
      }
    },
    sm: {
      icon: {
        insetEnd: "2"
      }
    },
    md: {
      icon: {
        insetEnd: "2"
      }
    },
    lg: {
      icon: {
        insetEnd: "2"
      }
    }
  }
})({ omit: ["addon", "element"] });

// node_modules/@yamada-ui/theme/dist/chunk-XVM5EASY.mjs
var Menu = {
  baseStyle: {
    button: {
      transitionProperty: "common",
      transitionDuration: "normal"
    },
    content: {
      rounded: "md",
      minW: "xs",
      bg: ["white", "black"],
      border: "1px solid",
      borderColor: ["blackAlpha.200", "whiteAlpha.100"],
      color: "inherit",
      boxShadow: ["lg", "dark-lg"],
      zIndex: "guldo"
    },
    list: {
      py: "2"
    },
    item: {
      cursor: "pointer",
      py: "1.5",
      px: "3",
      transitionProperty: "background",
      transitionDuration: "ultra-fast",
      transitionTimingFunction: "ease-in",
      _focus: {
        bg: ["blackAlpha.50", "whiteAlpha.50"]
      },
      _active: {
        bg: ["blackAlpha.50", "whiteAlpha.50"],
        _disabled: {
          bg: ["white", "black"]
        }
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    },
    icon: {
      color: ["blackAlpha.600", "whiteAlpha.700"]
    },
    command: {
      opacity: 0.6
    },
    divider: {
      my: "2",
      borderBottomWidth: "1px",
      borderColor: "inherit"
    },
    group: {},
    groupLabel: {
      py: "1.5",
      px: "3",
      fontSize: "sm",
      fontWeight: "semibold",
      color: ["blackAlpha.700", "whiteAlpha.600"]
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-GT4I2KHT.mjs
var Select = mergeMultiStyle(
  NativeSelect,
  Menu,
  {
    baseStyle: {
      inner: {},
      header: {},
      content: {
        w: "100%"
      },
      list: {
        maxH: "xs",
        overflowY: "auto"
      },
      footer: {},
      item: {
        _hover: {
          bg: ["blackAlpha.100", "whiteAlpha.100"],
          _disabled: {
            bg: ["white", "black"]
          }
        },
        _active: {
          bg: ["blackAlpha.200", "whiteAlpha.200"]
        }
      },
      itemIcon: {}
    }
  }
)({ omit: ["button", "command"] });

// node_modules/@yamada-ui/theme/dist/chunk-KYUWI3NZ.mjs
var MultiSelect = mergeMultiStyle(
  Select,
  {
    baseStyle: {
      clearIcon: {
        transitionProperty: "common",
        transitionDuration: "normal",
        pointerEvents: "auto",
        _hover: {
          opacity: 0.8
        },
        _readOnly: {
          pointerEvents: "none"
        },
        _disabled: {
          pointerEvents: "none",
          opacity: 0.4
        },
        _focusVisible: {
          boxShadow: "outline"
        }
      }
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-CTM2XPDT.mjs
var DatePicker = mergeMultiStyle(
  Input,
  MultiSelect,
  {
    baseStyle: {
      container: {},
      field: {
        cursor: "text",
        pb: "px",
        _focus: {
          zIndex: "unset"
        },
        _readOnly: {
          pointerEvents: "none"
        }
      },
      content: {
        w: "auto",
        minW: "auto",
        p: "2"
      }
    },
    sizes: {
      xs: {
        icon: {
          pt: "2",
          fontSize: "md"
        }
      }
    }
  }
)({
  omit: [
    "addon",
    "element",
    "group",
    "groupLabel",
    "header",
    "footer",
    "list",
    "item",
    "itemIcon"
  ]
});

// node_modules/@yamada-ui/theme/dist/chunk-4QVBPYMV.mjs
var YearPicker = mergeMultiStyle(DatePicker)();

// node_modules/@yamada-ui/theme/dist/chunk-IVZRQ7OL.mjs
var Skeleton = {
  baseStyle: {
    background: ["blackAlpha.300", "whiteAlpha.300"],
    borderColor: ["blackAlpha.400", "whiteAlpha.400"],
    opacity: 0.7,
    borderRadius: "sm"
  },
  defaultProps: {
    startColor: ["blackAlpha.300", "whiteAlpha.300"],
    endColor: ["blackAlpha.400", "whiteAlpha.400"]
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-KTG4EHPB.mjs
var SlideFade = {
  baseStyle: {
    w: "100%"
  },
  defaultProps: {
    offsetX: 0,
    offsetY: 8,
    reverse: true
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-GRA6EQFB.mjs
var Slide = {
  baseStyle: {
    position: "fixed",
    zIndex: "fallback(jeice, 110)"
  },
  defaultProps: {
    placement: "right"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WPWUM4QW.mjs
var Stat = {
  baseStyle: {
    container: {},
    label: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontWeight: "medium"
    },
    number: ({ colorScheme: c }) => ({
      fontFeatureSettings: '"pnum"',
      fontVariantNumeric: "proportional-nums",
      verticalAlign: "baseline",
      fontSize: "5xl",
      color: c ? [`${c}.500`, `${c}.600`] : ["blackAlpha.800", "whiteAlpha.700"],
      fontWeight: "extrabold"
    }),
    helperMessage: {
      fontSize: "sm",
      color: ["blackAlpha.700", "whiteAlpha.600"]
    },
    icon: {
      marginEnd: "1",
      w: "3.5",
      h: "3.5",
      verticalAlign: "middle",
      var: [
        {
          name: "increase",
          token: "colors",
          value: "success.400"
        },
        {
          name: "decrease",
          token: "colors",
          value: "danger.400"
        }
      ]
    }
  },
  defaultProps: {}
};

// node_modules/@yamada-ui/theme/dist/chunk-QQ5JVKFK.mjs
var Stepper = {
  baseStyle: ({ colorScheme: c = "primary" }) => ({
    stepper: {
      w: "100%",
      display: "flex",
      justifyContent: "space-between",
      _vertical: {
        flexDirection: "column",
        alignItems: "flex-start",
        gap: 0
      },
      _horizontal: {
        flexDirection: "row",
        alignItems: "center",
        gap: 4
      }
    },
    step: {
      position: "relative",
      display: "flex",
      gap: 2,
      flex: 1,
      flexShrink: 0,
      _horizontal: {
        alignItems: "center"
      },
      "&:last-of-type:not([data-stretch])": {
        flex: "initial"
      }
    },
    status: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: 0,
      rounded: "full",
      transitionProperty: "common",
      transitionDuration: "slow",
      "&[data-status=active]": {
        borderWidth: "2px",
        borderColor: [`${c}.500`, `${c}.400`]
      },
      "&[data-status=complete]": {
        bg: [`${c}.500`, `${c}.400`],
        color: ["white", "black"]
      },
      "&[data-status=incomplete]": {
        borderWidth: "2px"
      }
    },
    icon: {
      flexShrink: 0
    },
    number: {},
    title: {
      fontWeight: "medium"
    },
    description: {
      color: ["blackAlpha.700", "whiteAlpha.600"]
    },
    separator: {
      bg: "border",
      flex: 1,
      transitionProperty: "common",
      transitionDuration: "slow",
      "&[data-status=complete]": {
        bg: [`${c}.500`, `${c}.400`]
      },
      _vertical: {
        position: "absolute",
        w: 0.5,
        h: "100%"
      },
      _horizontal: {
        w: "100%",
        h: 0.5,
        ms: 2
      }
    }
  }),
  sizes: {
    sm: ({ theme: t }) => ({
      title: {
        fontSize: "sm"
      },
      description: {
        fontSize: "xs"
      },
      status: {
        w: 6,
        h: 6
      },
      icon: {
        w: 4,
        h: 4
      },
      number: {
        fontSize: "sm"
      },
      separator: {
        maxHeight: `calc(100% - ${getMemoizedObject(t, "sizes.6")} - 8px)`,
        top: `calc(${getMemoizedObject(t, "sizes.6")} + 4px)`,
        insetStart: `calc(${getMemoizedObject(t, "sizes.6")} / 2 - 1px)`
      }
    }),
    md: ({ theme: t }) => ({
      title: {
        fontSize: "md"
      },
      description: {
        fontSize: "sn"
      },
      status: {
        w: 8,
        h: 8
      },
      icon: {
        w: 5,
        h: 5
      },
      number: {
        fontSize: "md"
      },
      separator: {
        maxHeight: `calc(100% - ${getMemoizedObject(t, "sizes.8")} - 8px)`,
        top: `calc(${getMemoizedObject(t, "sizes.8")} + 4px)`,
        insetStart: `calc(${getMemoizedObject(t, "sizes.8")} / 2 - 1px)`
      }
    }),
    lg: ({ theme: t }) => ({
      title: {
        fontSize: "lg"
      },
      description: {
        fontSize: "md"
      },
      status: {
        w: 10,
        h: 10
      },
      icon: {
        w: 6,
        h: 6
      },
      number: {
        fontSize: "lg"
      },
      separator: {
        maxHeight: `calc(100% - ${getMemoizedObject(t, "sizes.10")} - 8px)`,
        top: `calc(${getMemoizedObject(t, "sizes.10")} + 4px)`,
        insetStart: `calc(${getMemoizedObject(t, "sizes.10")} / 2 - 1px)`
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-NNUCHRGF.mjs
var Switch = {
  baseStyle: {
    container: {
      _readOnly: { cursor: "auto" },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    },
    track: {
      rounded: "full",
      bg: ["blackAlpha.400", "whiteAlpha.300"],
      transitionProperty: "common",
      transitionDuration: "fast",
      _checked: {
        justifyContent: "flex-end"
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    },
    thumb: {
      rounded: "inherit",
      bg: "white"
    },
    label: {
      userSelect: "none"
    }
  },
  variants: {
    thick: ({ colorScheme: c = "primary" }) => ({
      track: {
        p: "1",
        _checked: {
          bg: [`${c}.500`, `${c}.600`]
        }
      }
    }),
    thin: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      track: {
        _checked: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 58)(t, m2)
          ]
        }
      },
      thumb: {
        boxShadow: "dark-md",
        _checked: {
          bg: [`${c}.500`, `${c}.600`]
        }
      }
    })
  },
  sizes: {
    sm: ({ variant: v }) => ({
      track: {
        w: "6",
        h: v === "thin" ? "2" : void 0
      },
      thumb: {
        w: "3",
        h: "3"
      },
      label: { fontSize: "sm" }
    }),
    md: ({ variant: v }) => ({
      track: {
        w: "8",
        h: v === "thin" ? "3" : void 0
      },
      thumb: {
        w: "4",
        h: "4"
      },
      label: { fontSize: "md" }
    }),
    lg: ({ variant: v }) => ({
      track: {
        w: "10",
        h: v === "thin" ? "4" : void 0
      },
      thumb: {
        w: "5",
        h: "5"
      },
      label: { fontSize: "lg" }
    })
  },
  defaultProps: {
    size: "md",
    variant: "thick",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-LXDVUZEL.mjs
var Rating = {
  baseStyle: ({ colorScheme: c = "yellow" }) => ({
    container: {
      w: "max-content"
    },
    group: {
      position: "relative"
    },
    item: {
      cursor: "pointer",
      rounded: "sm",
      color: ["blackAlpha.300", "whiteAlpha.300"],
      outline: "none",
      _notLast: {
        position: "absolute",
        top: 0,
        left: 0
      },
      _readOnly: {
        cursor: "default"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _filled: {
        color: [`${c}.500`, `${c}.600`]
      }
    },
    icon: {
      fill: "currentColor"
    }
  }),
  sizes: {
    xs: {
      icon: {
        fontSize: "md"
      }
    },
    sm: {
      icon: {
        fontSize: "lg"
      }
    },
    md: {
      icon: {
        fontSize: "xl"
      }
    },
    lg: {
      icon: {
        fontSize: "2xl"
      }
    },
    xl: {
      icon: {
        fontSize: "3xl"
      }
    }
  },
  defaultProps: {
    size: "md",
    colorScheme: "yellow"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-IRHDVW2D.mjs
var Reorder2 = {
  baseStyle: {
    container: {
      w: "100%"
    },
    item: {
      w: "100%",
      h: "100%",
      _selected: {
        boxShadow: ["md", "dark-md"]
      }
    },
    trigger: {
      color: ["blackAlpha.300", "whiteAlpha.300"]
    }
  },
  variants: {
    elevated: {
      item: {
        bg: ["white", "black"],
        boxShadow: ["base", "dark-md"]
      }
    },
    outline: {
      item: {
        bg: ["white", "black"],
        borderWidth: "1px"
      }
    },
    unstyled: {
      item: { rounded: 0, p: 0, _selected: { boxShadow: "unset" } }
    }
  },
  sizes: {
    sm: {
      item: { rounded: "base", p: "sm" }
    },
    md: {
      item: { rounded: "md", p: "md" }
    },
    normal: {
      item: { rounded: "lg", p: "normal" }
    },
    lg: {
      item: { rounded: "xl", p: "lg" }
    }
  },
  defaultProps: {
    variant: "outline",
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-QSMBWYUW.mjs
var Resizable = {
  baseStyle: ({ direction: d }) => ({
    container: {},
    item: {},
    trigger: {},
    icon: {
      color: ["blackAlpha.600", "whiteAlpha.700"],
      rotate: d === "vertical" ? "90deg" : "0deg"
    }
  }),
  variants: {
    border: ({ direction: d }) => ({
      trigger: {
        bg: "border",
        ...d === "vertical" ? { h: "px" } : { w: "px" },
        _focus: {
          outline: "none"
        },
        _focusVisible: {
          outline: "none",
          bg: "focus"
        },
        _after: {
          content: "''",
          position: "absolute",
          ...d === "vertical" ? { left: "0", right: "0", transform: "translateY(-50%)" } : { top: "0", bottom: "0", transform: "translateX(-50%)" },
          ...d === "vertical" ? { h: "2" } : { w: "2" }
        }
      },
      icon: {
        p: "1",
        bg: "border",
        rounded: "full"
      }
    }),
    spacer: ({
      direction: d,
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray"
    }) => ({
      trigger: {
        ...d === "vertical" ? { p: "1" } : { p: "1" },
        _after: {
          transitionProperty: "common",
          transitionDuration: "slower",
          bg: "transparent",
          content: "''",
          display: "block",
          rounded: "full",
          ...d === "vertical" ? { w: "full", h: "2" } : { w: "2", h: "full" }
        },
        _dark: {
          _after: {
            bg: "transparent"
          }
        },
        _focus: {
          outline: "none"
        },
        _active: {
          _after: {
            bg: isGray(c) ? "border" : `${c}.50`
          },
          _dark: {
            _after: {
              bg: isGray(c) ? "border" : transparentizeColor(`${c}.600`, 0.12)(t, m2)
            }
          }
        },
        _focusVisible: {
          outline: "none",
          _after: {
            bg: isGray(c) ? "border" : `${c}.100`
          },
          _dark: {
            _after: {
              bg: isGray(c) ? "border" : transparentizeColor(`${c}.600`, 0.24)(t, m2)
            }
          }
        }
      },
      icon: {
        transitionProperty: "common",
        transitionDuration: "slower",
        _active: {
          color: ["transparent", "transparent"]
        }
      }
    }),
    unstyled: ({ direction: d }) => ({
      trigger: {
        _after: {
          content: "''",
          position: "absolute",
          ...d === "vertical" ? { left: "0", right: "0", transform: "translateY(-50%)" } : { top: "0", bottom: "0", transform: "translateX(-50%)" },
          ...d === "vertical" ? { h: "2" } : { w: "2" }
        }
      }
    })
  },
  defaultProps: {
    variant: "border",
    colorScheme: "gray"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-K2G5R2DG.mjs
var SaturationSlider = {
  baseStyle: {
    container: {
      w: "full",
      rounded: "md",
      cursor: "pointer",
      _readOnly: { cursor: "auto" },
      _disabled: {
        opacity: 0.6,
        cursor: "not-allowed"
      }
    },
    inner: {
      rounded: "md"
    },
    overlay: {
      rounded: "md"
    },
    track: {},
    thumb: {
      rounded: "full",
      outline: 0,
      borderWidth: "3px",
      borderColor: "whiteAlpha.950",
      boxShadow: ["md", "dark-md"],
      transitionProperty: "transform",
      transitionDuration: "normal",
      _active: {
        transform: `scale(1.15)`
      },
      _focusVisible: {
        boxShadow: ["outline", "outline"]
      }
    }
  },
  sizes: {
    sm: {
      container: { maxW: "xs" },
      thumb: { boxSize: "3" }
    },
    md: {
      container: { maxW: "sm" },
      thumb: { boxSize: "4" }
    },
    lg: {
      container: { maxW: "md" },
      thumb: { boxSize: "5" }
    },
    full: {
      container: { maxW: "full" },
      thumb: { boxSize: "5" }
    }
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WHAHJ4MY.mjs
var ScaleFade = {
  baseStyle: {
    w: "100%"
  },
  defaultProps: {
    scale: 0.95,
    reverse: true
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-QB6YK3II.mjs
var ScrollArea = {
  baseStyle: {
    outline: 0,
    _focusVisible: {
      boxShadow: "inline"
    },
    _scrollbar: {
      w: "3",
      h: "3"
    },
    _scrollbarTrack: {
      bg: "transparent"
    },
    _scrollbarThumb: {
      bg: "blackAlpha.600",
      bgClip: "padding-box",
      border: "3px solid transparent",
      rounded: "full",
      _nativeHover: {
        bg: "blackAlpha.800",
        bgClip: "padding-box"
      }
    },
    _dark: {
      _scrollbarThumb: {
        bg: "whiteAlpha.600",
        bgClip: "padding-box",
        _nativeHover: {
          bg: "whiteAlpha.800",
          bgClip: "padding-box"
        }
      }
    },
    _scrollbarButton: {},
    _scrollbarCorner: {
      bg: "transparent"
    },
    "@-moz-document url-prefix()": {
      scrollbarColor: "whiteAlpha.600 transparent",
      _light: {
        scrollbarColor: "whiteAlpha.600 transparent"
      },
      _dark: {
        scrollbarColor: "whiteAlpha.600 transparent"
      }
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-G72O65H5.mjs
var SegmentedControl = {
  baseStyle: {
    container: {
      p: "1",
      bg: ["blackAlpha.100", "whiteAlpha.50"],
      _readOnly: { cursor: "default" },
      _disabled: { cursor: "not-allowed" }
    },
    cursor: {
      boxShadow: ["md", "dark-md"]
    },
    button: {
      transitionProperty: "common",
      transitionDuration: "ultra-slow",
      fontWeight: "medium",
      whiteSpace: "nowrap",
      color: ["blackAlpha.800", "whiteAlpha.800"],
      _hover: {
        opacity: 0.7,
        _checked: {
          opacity: 1
        }
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _readOnly: { cursor: "default" },
      _disabled: { opacity: 0.4, cursor: "not-allowed" }
    }
  },
  variants: {
    basic: ({ colorScheme: c = "gray" }) => ({
      container: {
        rounded: "lg"
      },
      cursor: {
        bg: isGray(c) ? [`whiteAlpha.800`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
        color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`],
        rounded: "md"
      },
      button: {
        rounded: "md",
        _checked: {
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`]
        }
      }
    }),
    rounded: ({ colorScheme: c = "gray" }) => ({
      container: {
        rounded: "full"
      },
      cursor: {
        bg: isGray(c) ? [`whiteAlpha.800`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
        color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`],
        rounded: "full"
      },
      button: {
        rounded: "full",
        _checked: {
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`]
        }
      }
    })
  },
  sizes: {
    sm: {
      container: { minW: "xs" },
      button: { py: "1", px: "2", fontSize: "sm" }
    },
    md: {
      container: { minW: "sm" },
      button: { py: "1.5", px: "3", fontSize: "md" }
    },
    lg: {
      container: { minW: "md" },
      button: { py: "2", px: "4" }
    }
  },
  defaultProps: {
    variant: "basic",
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WU2JWN4T.mjs
var PinInput = mergeMultiStyle(
  Input,
  {
    baseStyle: {
      container: {
        gap: "sm"
      },
      field: {
        textAlign: "center"
      }
    },
    variants: {
      unstyled: {
        field: {
          h: "auto"
        }
      }
    },
    sizes: {
      xs: {
        field: {
          fontSize: "xs",
          boxSize: "6",
          rounded: "sm"
        }
      },
      sm: {
        field: {
          fontSize: "sm",
          boxSize: "8",
          rounded: "md"
        }
      },
      md: {
        field: {
          fontSize: "md",
          boxSize: "10",
          rounded: "md"
        }
      },
      lg: {
        field: {
          fontSize: "lg",
          boxSize: "12",
          rounded: "md"
        }
      }
    }
  }
)({ omit: ["addon", "sizes"] });

// node_modules/@yamada-ui/theme/dist/chunk-SOSXTFLS.mjs
var Popover = {
  baseStyle: {
    container: {
      rounded: "md",
      bg: ["white", "black"],
      border: "1px solid",
      borderColor: ["blackAlpha.200", "whiteAlpha.100"],
      color: "inherit",
      boxShadow: ["lg", "dark-lg"],
      zIndex: "guldo",
      _focusVisible: {
        outline: 0,
        boxShadow: "outline"
      }
    },
    closeButton: {
      top: "2",
      right: "2"
    },
    header: {
      p: "sm",
      gap: "sm",
      fontWeight: "semibold",
      borderBottom: "1px solid",
      borderColor: "inherit"
    },
    body: {
      my: "sm",
      px: "sm",
      gap: "sm"
    },
    footer: {
      p: "sm",
      gap: "sm",
      borderTop: "1px solid",
      borderColor: "inherit"
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-KGYAQZVI.mjs
var Progress = {
  baseStyle: {
    track: {
      bg: "border"
    },
    filledTrack: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary",
      hasStripe,
      isAnimation,
      filledTrackColor: f
    }) => {
      hasStripe = !isAnimation && hasStripe;
      const color2 = mode("rgba(255, 255, 255, 0.15)", "rgba(0,0,0,0.1)")(m2);
      const bgColor = f ? isArray(f) ? mode(getColor(f[0], f[0])(t, m2), getColor(f[1], f[1])(t, m2))(m2) : getColor(f, f)(t, m2) : getColor(`${c}.500`)(t, m2);
      const bgImage = hasStripe ? `linear-gradient(
            45deg,
            ${color2} 25%,
            transparent 25%,
            transparent 50%,
            ${color2} 50%,
            ${color2} 75%,
            transparent 75%,
            transparent
          )` : isAnimation ? `linear-gradient(
            to right,
            transparent 0%,
            ${bgColor} 50%,
            transparent 100%
          )` : void 0;
      return {
        transitionProperty: "common",
        transitionDuration: "slow",
        bgImage,
        ...hasStripe ? { bgSize: "1rem 1rem" } : {},
        ...!isAnimation ? { bgColor } : {}
      };
    }
  },
  sizes: {
    xs: {
      track: {
        h: "1"
      }
    },
    sm: {
      track: {
        h: "2"
      }
    },
    md: {
      track: {
        h: "3"
      }
    },
    lg: {
      track: {
        h: "4"
      }
    }
  },
  defaultProps: {
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-TC5P3BC7.mjs
var LineChart = {
  baseStyle: {
    container: {},
    chart: {},
    referenceLine: {
      fillOpacity: 1,
      fontSize: "xs"
    },
    grid: {
      stroke: ["blackAlpha.400", "whiteAlpha.400"],
      strokeWidth: 1
    },
    cursor: {
      fill: ["blackAlpha.50", "whiteAlpha.50"],
      stroke: ["blackAlpha.400", "whiteAlpha.400"],
      strokeWidth: 1
    },
    xAxis: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontSize: "xs"
    },
    yAxis: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontSize: "xs"
    },
    xAxisLabel: {
      fontSize: 12
    },
    yAxisLabel: {
      fontSize: 12
    },
    line: {},
    dot: {
      strokeWidth: 2
    },
    activeDot: {
      strokeWidth: 2,
      fill: ["white", "black"]
    },
    legend: {
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "flex-end"
    },
    legendItem: {
      display: "flex",
      alignItems: "center",
      rounded: "md",
      gap: "sm",
      transitionProperty: "common",
      transitionDuration: "slower",
      color: ["blackAlpha.800", "whiteAlpha.700"],
      _hover: {
        bg: ["blackAlpha.50", "whiteAlpha.100"]
      }
    },
    legendSwatch: {
      boxSize: "3",
      rounded: "full"
    },
    tooltip: {
      display: "flex",
      flexDirection: "column",
      minW: "48",
      gap: "sm",
      rounded: "md",
      bg: ["white", "black"],
      border: "1px solid",
      borderColor: ["blackAlpha.200", "whiteAlpha.100"],
      p: "3",
      fontWeight: "medium",
      fontSize: "sm",
      color: "inherit",
      boxShadow: ["md", "dark-md"],
      maxW: "xs",
      zIndex: "dodoria"
    },
    tooltipTitle: {
      fontSize: "md"
    },
    tooltipList: {
      display: "flex",
      flexDirection: "column",
      gap: "xs"
    },
    tooltipItem: {
      display: "flex",
      alignItems: "center",
      gap: "sm",
      fontSize: "sm"
    },
    tooltipSwatch: {
      boxSize: "3",
      rounded: "full"
    },
    tooltipLabel: {
      color: ["blackAlpha.800", "whiteAlpha.700"]
    },
    tooltipValue: {
      flex: 1,
      textAlign: "end"
    }
  },
  variants: {},
  sizes: {
    sm: ({ theme: t }) => ({
      container: {
        w: "xl",
        h: "xs"
      },
      legend: {
        gap: "xs",
        mb: "md"
      },
      legendItem: {
        minH: "6",
        minW: "6",
        fontSize: "xs",
        px: "2",
        lineHeight: getMemoizedObject(t, "sizes.6")
      }
    }),
    md: ({ theme: t }) => ({
      container: {
        w: "3xl",
        h: "sm"
      },
      legend: {
        gap: "xs",
        mb: "md"
      },
      legendItem: {
        minH: "7",
        minW: "7",
        fontSize: "sm",
        px: "3",
        lineHeight: getMemoizedObject(t, "sizes.7")
      }
    }),
    lg: ({ theme: t }) => ({
      container: {
        w: "5xl",
        h: "md"
      },
      legend: {
        gap: "sm",
        mb: "md"
      },
      legendItem: {
        minH: "8",
        minW: "8",
        fontSize: "md",
        px: "3",
        lineHeight: getMemoizedObject(t, "sizes.8")
      }
    }),
    full: ({ theme: t }) => ({
      container: {
        w: "full",
        h: "md"
      },
      legend: {
        gap: "sm",
        mb: "md"
      },
      legendItem: {
        minH: "8",
        minW: "8",
        fontSize: "md",
        px: "3",
        lineHeight: getMemoizedObject(t, "sizes.8")
      }
    })
  },
  defaultProps: {
    size: "full"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-Z4C7F6EI.mjs
var RadarChart = mergeMultiStyle(
  LineChart,
  {
    baseStyle: {
      radar: {},
      polarGrid: {
        stroke: ["blackAlpha.400", "whiteAlpha.400"],
        strokeWidth: 1
      },
      polarAngleAxis: {},
      polarAngleAxisTick: {
        "& > text": {
          fill: ["blackAlpha.700", "whiteAlpha.600"],
          fontSize: "xs"
        }
      },
      polarRadiusAxis: {
        "& > line": {
          stroke: ["blackAlpha.400", "whiteAlpha.400"]
        }
      },
      polarRadiusAxisTick: {
        "& > text": {
          fill: ["blackAlpha.700", "whiteAlpha.600"],
          fontSize: "xs"
        }
      }
    },
    sizes: {
      sm: {
        container: {
          w: "full"
        }
      },
      md: {
        container: {
          w: "full"
        }
      },
      lg: {
        container: {
          w: "full"
        }
      },
      full: {
        container: {
          w: "full"
        }
      }
    }
  }
)({ omit: ["line", "grid"] });

// node_modules/@yamada-ui/theme/dist/chunk-J3A2YBHF.mjs
var RadialChart = mergeMultiStyle(
  LineChart,
  {
    baseStyle: {
      background: {
        fill: "transparent"
      },
      labelList: {
        fill: "white"
      },
      cursor: {
        stroke: "none"
      },
      polarGrid: {
        stroke: ["blackAlpha.400", "whiteAlpha.400"],
        strokeWidth: 1
      }
    },
    sizes: {}
  }
)({ omit: ["line", "grid"] });

// node_modules/@yamada-ui/theme/dist/chunk-NBEQBRK4.mjs
var Radio = {
  baseStyle: {
    container: {
      _readOnly: { cursor: "auto" },
      _disabled: { cursor: "not-allowed" }
    },
    icon: ({ colorScheme: c = "primary" }) => ({
      transitionProperty: "box-shadow",
      transitionDuration: "normal",
      border: "2px solid",
      borderColor: "inherit",
      rounded: "full",
      color: "white",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      _checked: {
        _before: {
          content: `""`,
          display: "inline-block",
          rounded: "full",
          bg: [`${c}.500`, `${c}.600`]
        },
        _hover: {
          _before: {
            bg: [`${c}.600`, `${c}.700`]
          }
        },
        _disabled: {
          _before: {
            bg: ["blackAlpha.400", "whiteAlpha.300"]
          },
          _dark: {
            _before: {
              bg: "whiteAlpha.300"
            }
          }
        }
      },
      _disabled: {
        bg: ["blackAlpha.200", "whiteAlpha.100"]
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _invalid: {
        borderColor: ["danger.500", "danger.400"],
        _focusVisible: {
          borderColor: ["inherit", "inherit"]
        }
      }
    }),
    label: {
      userSelect: "none",
      _disabled: { opacity: 0.4 }
    }
  },
  sizes: {
    sm: {
      icon: {
        boxSize: "3.5",
        _before: {
          boxSize: "1.5"
        }
      },
      label: { fontSize: "sm" }
    },
    md: {
      icon: {
        boxSize: "4",
        _before: {
          boxSize: "2"
        }
      },
      label: { fontSize: "md" }
    },
    lg: {
      icon: {
        boxSize: "5",
        _before: {
          boxSize: "3"
        }
      },
      label: { fontSize: "lg" }
    }
  },
  defaultProps: {
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-CAX25ZRV.mjs
var RangeDatePicker = mergeMultiStyle(DatePicker)();

// node_modules/@yamada-ui/theme/dist/chunk-4DO2Q26G.mjs
var Slider = {
  baseStyle: {
    container: ({ orientation: o }) => ({
      display: "inline-block",
      position: "relative",
      cursor: "pointer",
      _readOnly: { cursor: "auto" },
      _disabled: {
        opacity: 0.6,
        cursor: "not-allowed"
      },
      ...o === "vertical" ? { h: "100%" } : { w: "100%" }
    }),
    track: {
      overflow: "hidden",
      rounded: "sm",
      bg: "border",
      _disabled: {
        bg: ["blackAlpha.200", "whiteAlpha.400"]
      }
    },
    filledTrack: ({ colorScheme: c = "primary" }) => ({
      w: "inherit",
      h: "inherit",
      bg: [`${c}.500`, `${c}.400`]
    }),
    mark: {
      fontSize: "sm"
    },
    thumb: ({ theme: t, colorMode: m2, orientation: o }) => ({
      position: "absolute",
      zIndex: "yamcha",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      rounded: "full",
      bg: "white",
      boxShadow: "base",
      border: "1px solid",
      borderColor: "transparent",
      transitionProperty: "transform",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        bg: [tintColor("black", 72)(t, m2), shadeColor("white", 64)]
      },
      ...o === "vertical" ? {
        left: "50%",
        transform: `translateX(-50%)`,
        _active: {
          transform: `translateX(-50%) scale(1.15)`
        }
      } : {
        top: "50%",
        transform: `translateY(-50%)`,
        _active: {
          transform: `translateY(-50%) scale(1.15)`
        }
      }
    })
  },
  sizes: {
    sm: ({ orientation: o }) => ({
      track: o === "vertical" ? { w: "0.5" } : { h: "0.5" },
      thumb: { boxSize: "2.5" },
      mark: o === "vertical" ? { ml: "2" } : { mt: "2" }
    }),
    md: ({ orientation: o }) => ({
      track: o === "vertical" ? { w: "1" } : { h: "1" },
      thumb: { boxSize: "3.5" },
      mark: o === "vertical" ? { ml: "3" } : { mt: "3" }
    }),
    lg: ({ orientation: o }) => ({
      track: o === "vertical" ? { w: "1.5" } : { h: "1.5" },
      thumb: { boxSize: "5" },
      mark: o === "vertical" ? { ml: "4" } : { mt: "4" }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-75AJOMFW.mjs
var RangeSlider = mergeMultiStyle(Slider)();

// node_modules/@yamada-ui/theme/dist/chunk-IS6HIELI.mjs
var MultiDatePicker = mergeMultiStyle(DatePicker)();

// node_modules/@yamada-ui/theme/dist/chunk-KQRB4QSR.mjs
var NumberInput = mergeMultiStyle(
  Input,
  {
    baseStyle: {
      stepper: {
        borderStart: "1px solid",
        borderColor: "inherit",
        color: ["blackAlpha.600", "whiteAlpha.700"],
        _hover: {
          bg: ["blackAlpha.100", "whiteAlpha.100"]
        },
        _active: {
          bg: ["blackAlpha.200", "whiteAlpha.200"]
        },
        _readOnly: { cursor: "auto" },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        }
      }
    },
    variants: {
      flushed: {
        stepper: {
          bg: "transparent",
          border: "none",
          _hover: {
            bg: "transparent",
            opacity: 0.8
          },
          _active: {
            bg: "transparent",
            opacity: 0.7
          },
          _last: {
            border: "none"
          }
        }
      },
      unstyled: {
        stepper: {
          bg: "transparent",
          border: "none",
          _hover: {
            bg: "transparent"
          },
          _active: {
            bg: "transparent"
          },
          _last: {
            border: "none"
          }
        }
      }
    },
    sizes: {
      xs: {
        stepper: {
          fontSize: "xs",
          _first: {
            borderTopEndRadius: "sm"
          },
          _last: {
            borderBottomEndRadius: "sm",
            mt: "-1px",
            borderTop: "1px solid",
            borderColor: "inherit"
          }
        }
      },
      sm: {
        stepper: {
          fontSize: "sm",
          _first: {
            borderTopEndRadius: "md"
          },
          _last: {
            borderBottomEndRadius: "md",
            mt: "-1px",
            borderTop: "1px solid",
            borderColor: "inherit"
          }
        }
      },
      md: {
        stepper: {
          fontSize: "md",
          _first: {
            borderTopEndRadius: "md"
          },
          _last: {
            borderBottomEndRadius: "md",
            mt: "-1px",
            borderTop: "1px solid",
            borderColor: "inherit"
          }
        }
      },
      lg: {
        stepper: {
          fontSize: "lg",
          _first: {
            borderTopEndRadius: "md"
          },
          _last: {
            borderBottomEndRadius: "md",
            mt: "-1px",
            borderTop: "1px solid",
            borderColor: "inherit"
          }
        }
      }
    }
  }
)({ omit: ["addon"] });

// node_modules/@yamada-ui/theme/dist/chunk-6PIA2OIK.mjs
var Pagination = {
  baseStyle: {
    container: {
      _disabled: {
        cursor: "not-allowed"
      }
    },
    inner: {
      flex: 1
    },
    item: {
      px: 1,
      color: ["blackAlpha.600", "whiteAlpha.700"],
      rounded: "md",
      transitionProperty: "common",
      transitionDuration: "slower",
      _selected: { cursor: "default", pointerEvents: "none" },
      _focus: {
        outline: "none"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed",
        boxShadow: "none"
      },
      _hover: {
        _disabled: {
          bg: ["initial", "initial"]
        }
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    },
    first: {},
    last: {},
    prev: {},
    next: {},
    dots: { pointerEvents: "none" }
  },
  variants: {
    solid: ({ colorScheme: c = "primary" }) => ({
      item: {
        border: "1px solid",
        borderColor: "border",
        _selected: {
          bg: isGray(c) ? [`${c}.50`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
          borderColor: isGray(c) ? [`${c}.50`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`],
          _hover: {
            bg: isGray(c) ? [`${c}.100`, `${c}.800`] : [isAccessible(c) ? `${c}.500` : `${c}.600`, `${c}.700`]
          }
        },
        _hover: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _disabled: {
            bg: ["initial", "initial"]
          }
        },
        _active: {
          bg: ["blackAlpha.100", "whiteAlpha.100"]
        }
      },
      dots: {
        border: "0"
      }
    }),
    outline: ({ colorScheme: c = "primary" }) => {
      return {
        item: {
          border: "1px solid",
          borderColor: "border",
          _selected: {
            bg: "transparent",
            borderColor: [`${c}.600`, `${c}.500`],
            color: isGray(c) ? ["blackAlpha.800", "whiteAlpha.700"] : [`${c}.600`, `${c}.500`],
            _hover: {
              bg: ["transparent", "transparent"]
            }
          },
          _hover: {
            bg: ["blackAlpha.50", "whiteAlpha.50"],
            _disabled: {
              bg: ["initial", "initial"]
            }
          },
          _active: {
            bg: ["blackAlpha.100", "whiteAlpha.100"]
          }
        },
        dots: {
          border: "0"
        }
      };
    },
    ghost: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => {
      return {
        item: {
          _selected: {
            bg: isGray(c) ? void 0 : "transparent",
            fontWeight: "semibold",
            color: isGray(c) ? ["blackAlpha.800", "whiteAlpha.700"] : [`${c}.600`, `${c}.500`]
          },
          _hover: {
            bg: [`${c}.50`, transparentizeColor(`${c}.600`, 0.12)(t, m2)]
          },
          _active: {
            bg: isGray(c) ? [`${c}.300`, `whiteAlpha.300`] : [`${c}.200`, transparentizeColor(`${c}.200`, 0.24)(t, m2)]
          }
        }
      };
    },
    unstyled: {
      container: { gap: 0 },
      inner: { gap: 0 },
      item: { bg: "none", color: "inherit", minW: "auto", minH: "auto" },
      _ripple: { display: "none" }
    }
  },
  sizes: {
    xs: {
      container: {
        gap: "xs"
      },
      inner: {
        gap: "xs"
      },
      item: {
        minW: 6,
        minH: 6,
        fontSize: "xs"
      }
    },
    sm: {
      container: {
        gap: "xs"
      },
      inner: {
        gap: "xs"
      },
      item: {
        minW: 7,
        minH: 7,
        fontSize: "sm"
      }
    },
    md: {
      container: {
        gap: "sm"
      },
      inner: {
        gap: "sm"
      },
      item: {
        minW: 8,
        minH: 8,
        fontSize: "md"
      }
    },
    lg: {
      container: {
        gap: "sm"
      },
      inner: {
        gap: "sm"
      },
      item: {
        minW: 10,
        minH: 10,
        fontSize: "lg"
      }
    },
    xl: {
      container: {
        gap: "md"
      },
      inner: {
        gap: "md"
      },
      item: {
        minW: 12,
        minH: 12,
        fontSize: "xl"
      }
    }
  },
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-O7AIDQ2P.mjs
var NativeTable = {
  baseStyle: {
    container: {
      w: "100%"
    },
    table: {
      h: "100%",
      w: "100%",
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse"
    },
    tr: {
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.4,
        _hover: {
          bg: ["initial", "initial"]
        }
      }
    },
    th: {
      fontFamily: "heading",
      fontWeight: "semibold",
      textAlign: "start",
      color: ["blackAlpha.700", "whiteAlpha.600"],
      textTransform: "uppercase",
      letterSpacing: "wider"
    },
    td: {
      textAlign: "start"
    },
    caption: {
      fontFamily: "heading",
      fontWeight: "medium",
      textAlign: "center",
      color: ["blackAlpha.700", "whiteAlpha.600"]
    }
  },
  variants: {
    simple: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray",
      withBorder,
      withColumnBorders,
      highlightOnSelected,
      highlightOnHover
    }) => ({
      table: {
        ...withBorder ? { borderWidth: "1px" } : {}
      },
      th: {
        borderBottomWidth: "1px",
        "&[data-is-numeric=true]": {
          textAlign: "end"
        },
        ...withColumnBorders ? { _notLast: { borderRightWidth: "1px" } } : {}
      },
      td: {
        borderBottomWidth: "1px",
        "&[data-is-numeric=true]": {
          textAlign: "end"
        },
        ...withColumnBorders ? { _notLast: { borderRightWidth: "1px" } } : {}
      },
      tbody: {
        tr: {
          ...highlightOnSelected ? {
            _selected: {
              bg: [
                isGray(c) ? tintColor(`${c}.50`, 72)(t, m2) : tintColor(`${c}.50`, 64)(t, m2),
                transparentizeColor(`${c}.300`, 0.04)(t, m2)
              ]
            }
          } : {},
          ...highlightOnHover ? {
            cursor: "pointer",
            transitionProperty: "common",
            transitionDuration: "slow",
            _hover: {
              bg: [
                transparentizeColor(`${c}.400`, 0.08)(t, m2),
                transparentizeColor(`${c}.300`, 0.12)(t, m2)
              ]
            }
          } : {}
        }
      },
      tfoot: {
        tr: {
          _last: {
            th: { borderBottomWidth: 0 }
          }
        }
      }
    }),
    striped: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray",
      withBorder,
      withColumnBorders,
      highlightOnHover
    }) => ({
      table: {
        ...withBorder ? { borderWidth: "1px" } : {}
      },
      th: {
        borderBottomWidth: "1px",
        "&[data-is-numeric=true]": {
          textAlign: "end"
        },
        ...withColumnBorders ? { _notLast: { borderRightWidth: "1px" } } : {}
      },
      td: {
        borderBottomWidth: "1px",
        "&[data-is-numeric=true]": {
          textAlign: "end"
        },
        ...withColumnBorders ? { _notLast: { borderRightWidth: "1px" } } : {}
      },
      tbody: {
        tr: {
          _odd: {
            bg: [
              isGray(c) ? tintColor(`${c}.50`, 72)(t, m2) : tintColor(`${c}.50`, 64)(t, m2),
              transparentizeColor(`${c}.300`, 0.04)(t, m2)
            ]
          },
          ...highlightOnHover ? {
            cursor: "pointer",
            transitionProperty: "common",
            transitionDuration: "slow",
            _hover: {
              bg: [
                transparentizeColor(`${c}.400`, 0.08)(t, m2),
                transparentizeColor(`${c}.300`, 0.12)(t, m2)
              ]
            }
          } : {}
        }
      },
      tfoot: {
        tr: {
          _last: {
            th: { borderBottomWidth: 0 }
          }
        }
      }
    }),
    unstyled: {}
  },
  sizes: {
    sm: {
      container: {
        gap: 2
      },
      th: {
        px: 2,
        py: 1,
        fontSize: "xs",
        lineHeight: 5
      },
      td: {
        px: 2,
        py: 1,
        fontSize: "xs",
        lineHeight: 5
      },
      caption: {
        mt: 1,
        px: 2,
        py: 1,
        fontSize: "xs"
      }
    },
    md: {
      container: {
        gap: 4
      },
      th: {
        px: 3,
        py: 2,
        fontSize: "sm",
        lineHeight: 5
      },
      td: {
        px: 3,
        py: 2,
        fontSize: "sm",
        lineHeight: 5
      },
      caption: {
        mt: 2,
        px: 3,
        py: 2,
        fontSize: "sm"
      }
    },
    lg: {
      container: {
        gap: 6
      },
      th: {
        px: 4,
        py: 3,
        lineHeight: 6
      },
      td: {
        px: 4,
        py: 3,
        lineHeight: 6
      },
      caption: {
        mt: 3,
        px: 4,
        py: 3
      }
    },
    xl: {
      container: {
        gap: 8
      },
      th: {
        px: 6,
        py: 4,
        fontSize: "lg",
        lineHeight: 6
      },
      td: {
        px: 6,
        py: 4,
        fontSize: "lg",
        lineHeight: 6
      },
      caption: {
        mt: 4,
        px: 6,
        py: 4,
        fontSize: "lg"
      }
    }
  },
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-FP37P7PN.mjs
var Table = mergeMultiStyle(
  NativeTable,
  {
    baseStyle: {
      sortIcon: {}
    },
    sizes: {
      sm: {
        sortIcon: {
          right: 2
        }
      },
      md: {
        sortIcon: {
          right: 3
        }
      },
      lg: {
        sortIcon: {
          right: 4
        }
      },
      xl: {
        sortIcon: {
          right: 6
        }
      }
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-K534VIQH.mjs
var PagingTable = mergeMultiStyle(
  Table,
  {
    baseStyle: {
      pagingControl: {
        gridTemplateColumns: "1fr 5fr 1fr"
      }
    },
    sizes: {
      sm: {
        pagingControl: {
          gap: 2
        }
      },
      md: {
        pagingControl: {
          gap: 4
        }
      },
      lg: {
        pagingControl: {
          gap: 6
        }
      },
      xl: {
        pagingControl: {
          gap: 8
        }
      }
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-XTOMH4WJ.mjs
var List = {
  baseStyle: {
    container: {},
    item: {},
    icon: {
      me: "2",
      display: "inline-block",
      verticalAlign: "middle"
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-SBASSWCN.mjs
var Loading2 = {
  baseStyle: ({ colorScheme: c }) => ({
    color: `${c}.500`
  }),
  defaultProps: {
    variant: "oval",
    colorScheme: "primary",
    size: "1em"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-FMMWTRLT.mjs
var Mark = {
  baseStyle: {
    px: "1",
    py: "1"
  },
  variants: {
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => ({
      bg: [tintColor(`${c}.600`, 24)(t, m2), shadeColor(`${c}.600`, 16)(t, m2)],
      color: `white`
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => ({
      bg: [
        isGray(c) ? `${c}.50` : `${c}.100`,
        shadeColor(`${c}.300`, 58)(t, m2)
      ],
      color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
    }),
    outline: ({ theme: t, colorMode: m2, colorScheme: c = "gray" }) => {
      const color2 = mode(
        getColor(`${c}.500`)(t, m2),
        getColor(isGray(c) ? `${c}.100` : `${c}.400`)(t, m2)
      )(m2);
      return {
        color: color2,
        boxShadow: `inset 0 0 0px 1px ${color2}`
      };
    },
    "text-accent": ({ colorScheme: c = "gray" }) => ({
      color: [`${c}.500`, isGray(c) ? `${c}.100` : `${c}.400`],
      p: 0
    }),
    unstyled: {
      p: 0
    }
  },
  defaultProps: {
    variant: "subtle",
    colorScheme: "secondary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-QDBJG2HK.mjs
var Markdown = {
  baseStyle: {
    w: "full",
    "*:first-of-type": {
      mt: "0 !important"
    },
    "h1, h2, h3, h4, h5, h6": {
      mt: "24px",
      mb: "16px",
      fontWeight: "semibold",
      lineHeight: "1.25"
    },
    h1: {
      pb: ".3em",
      fontSize: "2em",
      borderBottom: "1px solid",
      borderBottomColor: "border"
    },
    h2: {
      pb: ".3em",
      fontSize: "1.5em",
      borderBottom: "1px solid",
      borderBottomColor: "border"
    },
    h3: {
      fontSize: "1.25em"
    },
    h4: {
      fontSize: "1em"
    },
    h5: {
      fontSize: "0.875em"
    },
    h6: {
      fontSize: "0.85em"
    },
    "p, blockquote, ul, ol, dl, table, pre, details": {
      mt: "0px",
      mb: "16px"
    },
    strong: { fontWeight: "semibold" },
    a: { color: "link", textDecoration: "none" },
    img: { maxW: "100%", boxSizing: "content-box" },
    blockquote: {
      px: "1em",
      color: ["blackAlpha.700", "whiteAlpha.600"],
      borderLeft: "0.25em solid",
      borderLeftColor: "border"
    },
    "blockquote>:last-child": { mb: 0 },
    ul: {
      pl: "2em",
      listStyleType: "disc"
    },
    "li + li": { mt: "0.25em" },
    "code:not(pre > *)": {
      py: "0.2em",
      px: "0.4em",
      m: 0,
      fontFamily: "mono",
      fontSize: "85%",
      bg: ["blackAlpha.200", "whiteAlpha.300"],
      rounded: "6px"
    },
    pre: { mt: "16px", fontSize: "92.5%", lineHeight: 1.45, rounded: "6px" },
    hr: { h: "0.25em", p: 0, my: "24px", bg: "border", border: 0 },
    table: {
      display: "block",
      w: "max-content",
      maxW: "100%",
      overflow: "auto"
    },
    tr: { borderTop: "1px solid", borderTopColor: "border" },
    th: {
      fontWeight: "semibold"
    },
    "th, td": {
      py: "6px",
      px: "13px",
      border: "1px solid",
      borderColor: "border"
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-H2LS6HCK.mjs
var MonthPicker = mergeMultiStyle(DatePicker)();

// node_modules/@yamada-ui/theme/dist/chunk-FKPFYTOW.mjs
var MultiAutocomplete = mergeMultiStyle(MultiSelect)();

// node_modules/@yamada-ui/theme/dist/chunk-H55HBNKH.mjs
var Image2 = {};

// node_modules/@yamada-ui/theme/dist/chunk-JE3FYW2X.mjs
var Indicator = {
  baseStyle: ({ withBorder }) => ({
    zIndex: "kurillin",
    rounded: "full",
    w: "fit-content",
    h: "fit-content",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    outline: 0,
    whiteSpace: "nowrap",
    ...withBorder ? { borderWidth: "0.2em", borderColor: ["white", "black"] } : {}
  }),
  sizes: {
    sm: { minH: 2, minW: 2, fontSize: "xs", px: 1, lineHeight: 1.6 },
    md: { minH: 3, minW: 3, fontSize: "sm", px: 1.5, lineHeight: 1.5 },
    lg: { minH: 4, minW: 4, fontSize: "md", px: 2, lineHeight: 1.4 }
  },
  variants: {
    solid: ({ colorScheme: c = "primary" }) => ({
      bg: [`${c}.500`, `${c}.600`],
      color: `white`,
      var: [
        {
          name: "ping",
          token: "colors",
          value: [`${c}.300`, `${c}.400`]
        }
      ]
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      bg: [
        isGray(c) ? `${c}.50` : `${c}.100`,
        shadeColor(`${c}.300`, 58)(t, m2)
      ],
      color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`],
      var: [
        {
          name: "ping",
          token: "colors",
          value: ["blackAlpha.400", "whiteAlpha.500"]
        }
      ]
    })
  },
  defaultProps: {
    size: "md",
    variant: "solid",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-QK3Y66V3.mjs
var InfiniteScrollArea = {
  baseStyle: {
    container: {},
    trigger: {}
  },
  defaultProps: {}
};

// node_modules/@yamada-ui/theme/dist/chunk-743RUTEI.mjs
var Kbd = {
  baseStyle: {
    fontFamily: "mono",
    bg: ["blackAlpha.50", "whiteAlpha.50"],
    rounded: "md",
    borderWidth: "1px",
    fontSize: "0.8em",
    fontWeight: "bold",
    lineHeight: "shorter",
    py: "0.2em",
    px: "0.4em",
    whiteSpace: "nowrap"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-4TDHU3Z4.mjs
var Link = {
  baseStyle: {
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    cursor: "pointer",
    textDecoration: "none",
    outline: "none",
    color: "link",
    _hover: {
      textDecoration: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WYGFOMAG.mjs
var Fade = {
  baseStyle: {
    w: "100%"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-2VQIYSWP.mjs
var FormControl = {
  baseStyle: {
    container: {
      w: "100%",
      position: "relative"
    },
    label: {
      fontSize: "md",
      me: "3",
      mb: "2",
      fontWeight: "medium",
      transitionProperty: "common",
      transitionDuration: "normal",
      opacity: 1,
      _disabled: {
        opacity: 0.4
      }
    },
    requiredIndicator: {
      ms: "1",
      color: ["danger.500", "danger.400"]
    },
    helperMessage: {
      display: "block",
      mt: "2",
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontSize: "sm"
    },
    errorMessage: {
      display: "block",
      mt: "2",
      color: ["danger.500", "danger.400"],
      fontSize: "sm"
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-4GXOZYWD.mjs
var Fieldset = mergeMultiStyle(
  FormControl,
  {
    baseStyle: {
      legend: {
        display: "block",
        fontSize: "md",
        me: "3",
        mb: "2",
        fontWeight: "medium",
        transitionProperty: "common",
        transitionDuration: "normal",
        opacity: 1,
        _disabled: {
          opacity: 0.4
        }
      }
    }
  }
)({ omit: ["label"] });

// node_modules/@yamada-ui/theme/dist/chunk-C52YKKCR.mjs
var Button = {
  baseStyle: {
    cursor: "pointer",
    rounded: "md",
    fontWeight: "semibold",
    transitionProperty: "common",
    transitionDuration: "slower",
    _focus: {
      outline: "none"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _readOnly: {
      cursor: "default",
      _ripple: {
        display: "none"
      }
    },
    _hover: {
      _disabled: {
        bg: ["initial", "initial"]
      }
    }
  },
  variants: {
    solid: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        bg: isGray(c) ? [`${c}.50`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
        color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`],
        _hover: {
          bg: isGray(c) ? [`${c}.100`, `${c}.800`] : [isAccessible(c) ? `${c}.500` : `${c}.600`, `${c}.700`],
          _disabled: {
            bg: isGray(c) ? [`${c}.50`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`]
          }
        },
        _invalid: {
          border: "1px solid",
          borderColor: errorBorderColor,
          boxShadow: `0 0 0 1px ${errorBorderColor}`
        },
        _focusVisible: {
          borderColor: "transparent",
          boxShadow: "outline"
        }
      };
    },
    outline: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        border: "1px solid",
        borderColor: [`${c}.600`, `${c}.500`],
        color: isGray(c) ? ["blackAlpha.800", "whiteAlpha.700"] : [`${c}.600`, `${c}.500`],
        bg: "transparent",
        _hover: {
          bg: [`${c}.50`, transparentizeColor(`${c}.600`, 0.12)(t, m2)]
        },
        _invalid: {
          borderColor: [errorBorderColor, errorBorderColor],
          boxShadow: `0 0 0 1px ${errorBorderColor}`
        },
        _focusVisible: {
          boxShadow: "outline",
          _invalid: {
            borderColor: "transparent"
          }
        }
      };
    },
    link: ({ colorScheme: c = "gray" }) => ({
      padding: 0,
      height: "auto",
      lineHeight: "normal",
      verticalAlign: "baseline",
      color: [`${c}.600`, `${c}.500`],
      _hover: {
        textDecoration: "underline",
        _disabled: {
          textDecoration: "none"
        }
      },
      _active: {
        color: [`${c}.700`, `${c}.600`],
        _disabled: {
          color: [`${c}.600`, `${c}.500`]
        }
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _ripple: {
        display: "none"
      }
    }),
    ghost: ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "gray",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        color: isGray(c) ? ["blackAlpha.800", "whiteAlpha.700"] : [`${c}.600`, `${c}.500`],
        bg: "transparent",
        _hover: {
          bg: [`${c}.50`, transparentizeColor(`${c}.600`, 0.12)(t, m2)]
        },
        _invalid: {
          border: "1px solid",
          borderColor: errorBorderColor,
          boxShadow: `0 0 0 1px ${errorBorderColor}`
        },
        _focusVisible: {
          borderColor: "transparent",
          boxShadow: "outline"
        }
      };
    },
    unstyled: {
      bg: "none",
      color: "inherit",
      display: "inline",
      lineHeight: "inherit",
      m: 0,
      p: 0,
      _ripple: {
        display: "none"
      }
    }
  },
  sizes: {
    xs: ({ theme: t }) => ({
      h: 6,
      minW: 6,
      fontSize: "xs",
      lineHeight: getMemoizedObject(t, "sizes.6"),
      px: 2
    }),
    sm: ({ theme: t }) => ({
      h: 8,
      minW: 8,
      fontSize: "sm",
      lineHeight: getMemoizedObject(t, "sizes.8"),
      px: 3
    }),
    md: ({ theme: t }) => ({
      h: 10,
      minW: 10,
      fontSize: "md",
      lineHeight: getMemoizedObject(t, "sizes.10"),
      px: 4
    }),
    lg: ({ theme: t }) => ({
      h: 12,
      minW: 12,
      fontSize: "lg",
      lineHeight: getMemoizedObject(t, "sizes.12"),
      px: 6
    })
  },
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-UGHB64KE.mjs
var FileButton = mergeStyle(Button)();

// node_modules/@yamada-ui/theme/dist/chunk-G27TF7VJ.mjs
var FileInput = mergeMultiStyle(Input)();

// node_modules/@yamada-ui/theme/dist/chunk-6ZRDZUY4.mjs
var Heading = {
  baseStyle: {
    fontFamily: "heading",
    fontWeight: "bold"
  },
  sizes: {
    "4xl": {
      fontSize: { base: "7xl", sm: "6xl" }
    },
    "3xl": {
      fontSize: { base: "6xl", sm: "5xl" }
    },
    "2xl": {
      fontSize: { base: "5xl", sm: "4xl" }
    },
    xl: {
      fontSize: { base: "4xl", sm: "3xl" }
    },
    lg: {
      fontSize: { base: "3xl", sm: "2xl" }
    },
    md: { fontSize: "xl" },
    sm: { fontSize: "md" },
    xs: { fontSize: "sm" }
  },
  defaultProps: { size: "xl" }
};

// node_modules/@yamada-ui/theme/dist/chunk-RV4RNKBI.mjs
var Icon2 = {
  baseStyle: {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: "currentColor"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-4RZNOVMW.mjs
var ContextMenu = mergeMultiStyle(
  Menu,
  {
    baseStyle: {
      trigger: {}
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-VWGAJLDE.mjs
var Modal = {
  baseStyle: {
    container: {
      w: "100%",
      rounded: "md",
      bg: ["white", "black"],
      color: "inherit",
      boxShadow: ["lg", "dark-lg"],
      zIndex: "recoome"
    },
    closeButton: {
      top: "3",
      right: "3"
    },
    overlay: {
      bg: "blackAlpha.600",
      zIndex: "burter"
    },
    header: {
      pt: "md",
      px: "md",
      gap: "md",
      fontSize: "xl",
      fontWeight: "semibold"
    },
    body: {
      my: "md",
      px: "md",
      gap: "md",
      flex: "1"
    },
    footer: {
      px: "md",
      pb: "md",
      gap: "md"
    }
  },
  sizes: {
    xs: { container: { maxW: "xs" } },
    sm: { container: { maxW: "sm" } },
    md: { container: { maxW: "md" } },
    lg: { container: { maxW: "lg" } },
    xl: { container: { maxW: "xl" } },
    "2xl": { container: { maxW: "2xl" } },
    "3xl": { container: { maxW: "3xl" } },
    "4xl": { container: { maxW: "4xl" } },
    "5xl": { container: { maxW: "5xl" } },
    "6xl": { container: { maxW: "6xl" } },
    full: {
      container: { minW: "100vw", minH: "100dvh", rounded: 0 }
    }
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-FGQ43S67.mjs
var Dialog = mergeMultiStyle(Modal)();

// node_modules/@yamada-ui/theme/dist/chunk-2UPENSR6.mjs
var Divider = {
  baseStyle: {
    borderColor: "border"
  },
  variants: {
    solid: {
      borderStyle: "solid"
    },
    dashed: {
      borderStyle: "dashed"
    },
    dotted: {
      borderStyle: "dotted"
    }
  },
  defaultProps: { variant: "solid" }
};

// node_modules/@yamada-ui/theme/dist/chunk-SFONLMUI.mjs
var PieChart = mergeMultiStyle(
  LineChart,
  {
    baseStyle: {
      pie: {},
      activeShape: {},
      inactiveShape: {},
      label: { fillOpacity: 1, fill: "currentColor" },
      labelLine: { stroke: "currentColor" },
      cell: {}
    },
    sizes: {
      sm: ({ theme: t, withLegend, withLabels }) => ({
        container: {
          w: withLegend ? "full" : calc.add(
            getMemoizedObject(t, "sizes.3xs"),
            withLabels ? getMemoizedObject(t, "sizes.16") : "0px"
          ),
          h: calc.add(getMemoizedObject(t, "sizes.3xs"), getMemoizedObject(t, "sizes.1"))
        },
        label: {
          fontSize: "xs"
        }
      }),
      md: ({ theme: t, withLegend, withLabels }) => ({
        container: {
          w: withLegend ? "full" : calc.add(
            getMemoizedObject(t, "sizes.2xs"),
            withLabels ? getMemoizedObject(t, "sizes.16") : "0px"
          ),
          h: "2xs"
        },
        label: {
          fontSize: "sm"
        }
      }),
      lg: ({ theme: t, withLegend, withLabels }) => ({
        container: {
          w: withLegend ? "full" : calc.add(
            getMemoizedObject(t, "sizes.xs"),
            withLabels ? getMemoizedObject(t, "sizes.16") : "0px"
          ),
          h: "xs"
        },
        label: {
          fontSize: "md"
        }
      })
    },
    defaultProps: {
      size: "md"
    }
  }
)({ omit: ["line", "grid", "sizes.full"] });

// node_modules/@yamada-ui/theme/dist/chunk-R6PVTGV4.mjs
var DonutChart = mergeMultiStyle(
  PieChart,
  {
    baseStyle: {
      label: {}
    }
  }
)();

// node_modules/@yamada-ui/theme/dist/chunk-E6V6QZBX.mjs
var Drawer = mergeMultiStyle(Modal, {
  baseStyle: {
    container: ({ isFullHeight, placement }) => ({
      ...isFullHeight ? { height: "100dvh", rounded: 0 } : {},
      [`rounded${toCamelCase(placement)}`]: 0
    }),
    inner: {},
    body: {
      overflow: "auto"
    },
    dragBar: ({ placement }) => ({
      [`margin${toCamelCase(antonym(placement))}`]: "md",
      ...placement === "top" || placement === "bottom" ? { mx: "auto", w: "3xs", minH: "2" } : { my: "auto", minW: "2", h: "3xs" },
      bg: ["blackAlpha.100", "whiteAlpha.100"],
      rounded: "full"
    })
  },
  sizes: {
    xs: { container: { maxW: "xs" } },
    sm: { container: { maxW: "md" } },
    md: { container: { maxW: "lg" } },
    lg: { container: { maxW: "2xl" } },
    xl: { container: { maxW: "4xl" } },
    full: {
      container: { minW: "100vw", minH: "100dvh", rounded: 0 }
    }
  },
  defaultProps: {
    size: "md"
  }
})({ omit: ["sizes"] });

// node_modules/@yamada-ui/theme/dist/chunk-TSI3UN2R.mjs
var Dropzone = {
  baseStyle: ({ theme: t, colorMode: m2 }) => ({
    container: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      rounded: "md",
      w: "100%",
      p: "md",
      bg: ["blackAlpha.50", "whiteAlpha.50"],
      outline: 0,
      overflow: "hidden",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      _hover: {
        cursor: "pointer",
        bg: ["blackAlpha.100", "whiteAlpha.100"]
      },
      _loading: {
        cursor: "not-allowed",
        bg: ["blackAlpha.100", "whiteAlpha.100"]
      },
      _accept: {
        bg: ["success.50", transparentizeColor("success.400", 0.12)(t, m2)],
        borderColor: ["success.500", "success.400"]
      },
      _reject: {
        bg: ["danger.50", transparentizeColor("danger.400", 0.12)(t, m2)],
        borderColor: ["danger.500", "danger.400"]
      }
    },
    overlay: {
      bg: ["whiteAlpha.600", "blackAlpha.600"],
      zIndex: "kurillin"
    }
  }),
  variants: {
    solid: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        container: {
          borderWidth: "1px",
          borderStyle: "solid",
          _invalid: {
            borderColor: errorBorderColor,
            boxShadow: `0 0 0 1px ${errorBorderColor}`
          },
          _focus: {
            zIndex: "yamcha",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          },
          _focusVisible: {
            zIndex: "yamcha",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          }
        }
      };
    },
    dashed: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        container: {
          borderWidth: "1px",
          borderStyle: "dashed",
          _invalid: {
            borderColor: errorBorderColor,
            boxShadow: `0 0 0 1px ${errorBorderColor}`
          },
          _focus: {
            zIndex: "yamcha",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          },
          _focusVisible: {
            zIndex: "yamcha",
            borderColor: focusBorderColor,
            boxShadow: `0 0 0 1px ${focusBorderColor}`
          }
        }
      };
    },
    unstyled: {
      container: {
        color: "inherit",
        rounded: "inherit",
        bg: "transparent",
        h: "auto",
        _hover: {
          cursor: "inherit",
          bg: "transparent"
        },
        _loading: {
          cursor: "auto",
          bg: "transparent"
        },
        _accept: {
          bg: "transparent",
          borderColor: "inherit"
        },
        _reject: {
          bg: "transparent",
          borderColor: "inherit"
        }
      },
      overlay: {
        bg: "transparent"
      }
    }
  },
  sizes: {
    xs: {
      container: { h: "xs" }
    },
    sm: {
      container: { h: "sm" }
    },
    md: {
      container: { h: "md" }
    },
    lg: {
      container: { h: "lg" }
    },
    full: {
      container: { h: "full" }
    }
  },
  defaultProps: {
    size: "sm",
    variant: "dashed"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-FTBUJEZI.mjs
var Editable = {
  baseStyle: {
    container: {
      w: "full"
    },
    preview: {
      rounded: "md",
      p: "1",
      whiteSpace: "pre-line",
      transitionProperty: "common",
      transitionDuration: "normal"
    },
    input: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        rounded: "md",
        p: "1",
        w: "full",
        transitionProperty: "common",
        transitionDuration: "normal",
        _placeholder: { opacity: 0.6 },
        _invalid: {
          boxShadow: `0px 0px 0px 1px ${errorBorderColor}`
        },
        _focus: {
          zIndex: "yamcha",
          boxShadow: `0px 0px 0px 1px ${focusBorderColor}`
        },
        _focusVisible: {
          zIndex: "yamcha",
          boxShadow: `0px 0px 0px 1px ${focusBorderColor}`
        }
      };
    },
    textarea: ({
      theme: t,
      colorMode: m2,
      focusBorderColor: fc = "focus",
      errorBorderColor: ec = ["danger.500", "danger.400"]
    }) => {
      const focusBorderColor = isArray(fc) ? mode(getColor(fc[0], fc[0])(t, m2), getColor(fc[1], fc[1])(t, m2))(m2) : getColor(fc, fc)(t, m2);
      const errorBorderColor = isArray(ec) ? mode(getColor(ec[0], ec[0])(t, m2), getColor(ec[1], ec[1])(t, m2))(m2) : getColor(ec, ec)(t, m2);
      return {
        boxSizing: "content-box",
        rounded: "md",
        p: "1",
        w: "full",
        h: "1lh",
        transitionProperty: "common",
        transitionDuration: "normal",
        _placeholder: { opacity: 0.6 },
        _invalid: {
          boxShadow: `0px 0px 0px 1px ${errorBorderColor}`
        },
        _focus: {
          zIndex: "yamcha",
          boxShadow: `0px 0px 0px 1px ${focusBorderColor}`
        },
        _focusVisible: {
          zIndex: "yamcha",
          boxShadow: `0px 0px 0px 1px ${focusBorderColor}`
        }
      };
    }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-SS4IMXST.mjs
var Checkbox = {
  baseStyle: {
    container: {
      _readOnly: { cursor: "auto" },
      _disabled: { cursor: "not-allowed" }
    },
    icon: ({ colorScheme: c = "primary" }) => ({
      transitionProperty: "box-shadow",
      transitionDuration: "normal",
      border: "2px solid",
      borderColor: "inherit",
      color: ["white", "black"],
      _checked: {
        bg: `${c}.500`,
        borderColor: `${c}.500`,
        color: ["white", "black"],
        _hover: {
          bg: `${c}.600`,
          borderColor: `${c}.600`
        },
        _disabled: {
          bg: ["blackAlpha.400", "whiteAlpha.300"]
        }
      },
      _indeterminate: {
        bg: `${c}.500`,
        borderColor: `${c}.500`,
        color: ["white", "black"]
      },
      _disabled: {
        bg: ["blackAlpha.200", "whiteAlpha.100"],
        borderColor: ["transparent", "transparent"]
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _invalid: {
        borderColor: ["danger.500", "danger.400"],
        _focusVisible: {
          borderColor: "inherit",
          _checked: {
            borderColor: `${c}.500`
          }
        }
      }
    }),
    label: {
      userSelect: "none",
      _disabled: { opacity: 0.4 }
    }
  },
  sizes: {
    sm: {
      icon: { boxSize: "3.5", rounded: "base", fontSize: "2xs" },
      label: { fontSize: "sm" }
    },
    md: {
      icon: { boxSize: "4", rounded: "base", fontSize: "2xs" },
      label: { fontSize: "md" }
    },
    lg: {
      icon: { boxSize: "5", rounded: "base", fontSize: "sm" },
      label: { fontSize: "lg" }
    }
  },
  defaultProps: {
    size: "md",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-WMMFZ6CK.mjs
var CircleProgress = {
  baseStyle: {
    display: "inline-block",
    position: "relative",
    verticalAlign: "middle"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-HUIXH4E6.mjs
var CloseButton2 = mergeStyle(Button, {
  baseStyle: {
    _hover: {
      bg: ["blackAlpha.100", "whiteAlpha.100"]
    },
    _active: {
      bg: ["blackAlpha.200", "whiteAlpha.200"]
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  },
  sizes: {
    sm: {
      boxSize: 6,
      fontSize: "2xs"
    },
    md: {
      boxSize: 8,
      fontSize: "xs"
    },
    lg: {
      boxSize: 10,
      fontSize: "md"
    }
  },
  defaultProps: {
    size: "md"
  }
})({ omit: ["variants", "sizes", "defaultProps"] });

// node_modules/@yamada-ui/theme/dist/chunk-B3SRZT36.mjs
var Collapse = {
  baseStyle: {
    w: "100%"
  },
  defaultProps: {
    animationOpacity: true,
    startingHeight: 0,
    endingHeight: "auto"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-OZGGH275.mjs
var ColorPicker = mergeMultiStyle(
  Input,
  Menu,
  {
    baseStyle: {
      container: {},
      inner: {},
      field: {
        pr: "8",
        pb: "px",
        _focus: {
          zIndex: "unset"
        },
        _readOnly: {
          pointerEvents: "none"
        }
      },
      swatch: {},
      eyeDropper: {
        w: "6",
        py: "1",
        fontSize: "lg",
        outline: 0,
        rounded: "md",
        transitionProperty: "common",
        transitionDuration: "normal",
        pointerEvents: "auto",
        color: ["blackAlpha.600", "whiteAlpha.700"],
        _hover: {
          color: ["blackAlpha.500", "whiteAlpha.600"]
        },
        _disabled: {
          pointerEvents: "none",
          opacity: 0.4
        },
        _focusVisible: {
          boxShadow: "outline"
        }
      },
      content: {
        w: "auto",
        minW: "auto",
        p: "2"
      }
    },
    sizes: {
      xs: ({ withSwatch }) => ({
        field: {
          pl: withSwatch ? "6" : "2"
        },
        swatch: {
          insetStart: "1",
          boxSize: "4"
        },
        eyeDropper: {
          insetEnd: "1",
          fontSize: "sm"
        }
      }),
      sm: ({ withSwatch }) => ({
        field: {
          pl: withSwatch ? "9" : "2"
        },
        swatch: {
          insetStart: "2",
          boxSize: "5"
        },
        eyeDropper: {
          insetEnd: "2"
        }
      }),
      md: ({ withSwatch }) => ({
        field: {
          pl: withSwatch ? "10" : "3"
        },
        swatch: {
          insetStart: "2",
          boxSize: "6"
        },
        eyeDropper: {
          insetEnd: "2"
        }
      }),
      lg: ({ withSwatch }) => ({
        field: {
          pl: withSwatch ? "12" : "4"
        },
        swatch: {
          insetStart: "2"
        },
        eyeDropper: {
          insetEnd: "2"
        }
      })
    }
  }
)({
  omit: [
    "addon",
    "element",
    "button",
    "list",
    "item",
    "command",
    "icon",
    "divider",
    "group",
    "groupLabel"
  ]
});

// node_modules/@yamada-ui/theme/dist/chunk-N5JKIJON.mjs
var ColorSelector = {
  baseStyle: {
    container: { w: "full" },
    saturationSlider: { maxW: "full" },
    body: {},
    sliders: { flex: "1" },
    hueSlider: {},
    alphaSlider: {},
    eyeDropper: {
      borderColor: "border",
      color: ["blackAlpha.600", "whiteAlpha.700"],
      _hover: {
        borderColor: ["blackAlpha.500", "whiteAlpha.400"],
        _disabled: {
          borderColor: "inherit"
        }
      }
    },
    result: {},
    channels: {},
    channelLabel: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontWeight: "medium"
    },
    channel: {},
    swatchesLabel: {
      color: ["blackAlpha.700", "whiteAlpha.600"],
      fontWeight: "medium"
    },
    swatches: {},
    swatch: {
      _readOnly: { cursor: "auto" },
      _disabled: {
        opacity: 0.6,
        cursor: "not-allowed"
      }
    }
  },
  sizes: {
    sm: {
      container: { w: "xs", gap: "sm" },
      body: { gap: "xs" },
      sliders: { gap: "xs" },
      channels: { gap: "xs" },
      eyeDropper: { boxSize: "7", fontSize: "xs" },
      result: { boxSize: "7" },
      channelLabel: { fontSize: "xs" },
      swatchesLabel: { fontSize: "xs" },
      swatches: { gap: "xs" }
    },
    md: {
      container: { w: "sm", gap: "sm" },
      body: { gap: "sm" },
      sliders: { gap: "sm" },
      channels: { gap: "sm" },
      eyeDropper: { boxSize: "10" },
      result: { boxSize: "10" },
      channelLabel: { fontSize: "sm", mb: "xs" },
      swatchesLabel: { fontSize: "sm", mb: "xs" },
      swatches: { gap: "sm" }
    },
    lg: {
      container: { w: "md", gap: "md" },
      body: { gap: "sm" },
      sliders: { gap: "sm" },
      channels: { gap: "sm" },
      eyeDropper: { boxSize: "12", fontSize: "xl" },
      result: { boxSize: "12" },
      channelLabel: { fontSize: "md", mb: "xs" },
      swatchesLabel: { fontSize: "md", mb: "xs" },
      swatches: { gap: "sm" }
    },
    full: {
      container: { w: "full", gap: "md" },
      body: { gap: "sm" },
      sliders: { gap: "sm" },
      channels: { gap: "sm" },
      eyeDropper: { boxSize: "12", fontSize: "xl" },
      result: { boxSize: "12" },
      channelLabel: { fontSize: "md", mb: "xs" },
      swatchesLabel: { fontSize: "md", mb: "xs" },
      swatches: { gap: "sm" }
    }
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-HGHCNQH6.mjs
var ColorSwatch = {
  baseStyle: {
    container: {},
    overlay: { boxSize: "full" }
  },
  variants: {
    basic: {
      container: { rounded: "md" },
      overlay: { rounded: "md" }
    },
    rounded: {
      container: { rounded: "full" },
      overlay: { rounded: "full" }
    }
  },
  sizes: {
    sm: {
      container: { boxSize: "6" }
    },
    md: {
      container: { boxSize: "8" }
    },
    lg: {
      container: { boxSize: "10" }
    }
  },
  defaultProps: {
    variant: "basic",
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-6YW6M7M5.mjs
var Container = {
  baseStyle: {
    w: "100%",
    display: "flex",
    flexDirection: "column",
    gap: { base: "lg", sm: "md" },
    p: { base: "lg", sm: "md" }
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-33TP765L.mjs
var Avatar = {
  baseStyle: {
    group: {},
    container: ({ theme: t, colorMode: m2, name: string2 }) => {
      const bg = string2 ? randomColor({ string: string2 }) : mode("gray.200", "gray.500")(m2);
      return {
        bg,
        color: isDark(bg)(t, m2) ? "white" : "black",
        borderColor: ["white", "black"],
        verticalAlign: "top",
        _loaded: { bg: "inherit" }
      };
    },
    name: {},
    excess: {
      borderColor: ["white", "black"],
      bg: ["blackAlpha.200", "whiteAlpha.200"]
    },
    badge: {
      rounded: "full",
      borderWidth: "0.2em",
      borderColor: ["white", "black"]
    }
  },
  sizes: {
    "2xs": ({ theme: t }) => ({
      container: {
        w: "4",
        h: "4",
        fontSize: `calc(${getMemoizedObject(t, "sizes.4")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.4")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: {
        w: "4",
        h: "4",
        fontSize: `calc(${getMemoizedObject(t, "sizes.4")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      }
    }),
    xs: ({ theme: t }) => ({
      container: {
        w: "6",
        h: "6",
        fontSize: `calc(${getMemoizedObject(t, "sizes.6")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.6")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "6", h: "6" }
    }),
    sm: ({ theme: t }) => ({
      container: {
        w: "8",
        h: "8",
        fontSize: `calc(${getMemoizedObject(t, "sizes.8")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.8")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "8", h: "8" }
    }),
    md: ({ theme: t }) => ({
      container: {
        w: "12",
        h: "12",
        fontSize: `calc(${getMemoizedObject(t, "sizes.12")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.12")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "12", h: "12" }
    }),
    lg: ({ theme: t }) => ({
      container: {
        w: "16",
        h: "16",
        fontSize: `calc(${getMemoizedObject(t, "sizes.16")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.16")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "16", h: "16" }
    }),
    xl: ({ theme: t }) => ({
      container: {
        w: "24",
        h: "24",
        fontSize: `calc(${getMemoizedObject(t, "sizes.24")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.24")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "24", h: "24" }
    }),
    "2xl": ({ theme: t }) => ({
      container: {
        w: "32",
        h: "32",
        fontSize: `calc(${getMemoizedObject(t, "sizes.32")} / 2.5)`
      },
      name: {
        fontSize: `calc(${getMemoizedObject(t, "sizes.32")} / 2.5)`,
        lineHeight: getMemoizedObject(t, "sizes.16")
      },
      excess: { w: "32", h: "32" }
    })
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-LRKOXCHU.mjs
var Badge = {
  baseStyle: {
    px: 1,
    textTransform: "uppercase",
    fontSize: "xs",
    rounded: "sm",
    fontWeight: "bold"
  },
  variants: {
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      bg: [tintColor(`${c}.600`, 24)(t, m2), shadeColor(`${c}.600`, 16)(t, m2)],
      color: `white`
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      bg: [
        isGray(c) ? `${c}.50` : `${c}.100`,
        shadeColor(`${c}.300`, 58)(t, m2)
      ],
      color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
    }),
    outline: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => {
      const color2 = mode(
        getColor(`${c}.500`)(t, m2),
        getColor(
          isGray(c) ? `${c}.100` : transparentizeColor(`${c}.400`, 0.92)(t, m2)
        )(t, m2)
      )(m2);
      return {
        color: color2,
        boxShadow: `inset 0 0 0px 1px ${color2}`
      };
    }
  },
  defaultProps: {
    variant: "subtle",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-ODUDXHBX.mjs
var BarChart = mergeMultiStyle(
  LineChart,
  {
    baseStyle: {
      bar: {},
      activeBar: {},
      background: { fill: "transparent" },
      cursor: { strokeDasharray: "5 5" }
    }
  }
)({ omit: ["dot", "activeDot"] });

// node_modules/@yamada-ui/theme/dist/chunk-ZVKUPX4E.mjs
var Breadcrumb = {
  baseStyle: {
    container: {},
    item: {},
    link: {
      transitionProperty: "common",
      transitionDuration: "fast",
      transitionTimingFunction: "ease-out",
      textDecoration: "none",
      outline: "none",
      color: "inherit",
      "&:not([aria-current=page])": {
        cursor: "pointer",
        _hover: {
          textDecoration: "underline"
        },
        _focusVisible: {
          boxShadow: "outline"
        }
      }
    },
    separator: {},
    ellipsis: {}
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-53XOLHPZ.mjs
var Calendar = {
  baseStyle: {
    container: {
      gap: "md"
    },
    header: {},
    label: {
      color: ["blackAlpha.700", "whiteAlpha.600"]
    },
    labelIcon: {
      color: ["blackAlpha.500", "whiteAlpha.500"]
    },
    control: {
      color: ["blackAlpha.500", "whiteAlpha.500"],
      fontSize: "1.25em",
      _hidden: {
        opacity: 0,
        pointerEvents: "none"
      }
    },
    prev: {},
    next: {},
    content: {},
    year: {
      gridTemplateColumns: "repeat(4, 1fr)"
    },
    month: {
      gridTemplateColumns: "repeat(3, 1fr)"
    },
    button: {
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed",
        boxShadow: "none",
        _focusVisible: {
          boxShadow: "0 0 0 3px rgba(125, 125, 125, 0.6)"
        }
      }
    },
    date: {},
    row: {},
    cell: {
      transitionProperty: "common",
      transitionDuration: "slower"
    },
    weekday: {
      userSelect: "none",
      color: ["blackAlpha.700", "whiteAlpha.600"],
      justifyContent: "center",
      alignItems: "center"
    },
    day: {
      _weekend: {
        color: ["red.600", "red.400"]
      },
      _outside: {
        color: ["blackAlpha.500", "whiteAlpha.500"]
      },
      _holiday: {
        color: ["red.600", "red.400"]
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed",
        _ripple: {
          display: "none"
        }
      }
    }
  },
  variants: {
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      button: {
        _hover: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _disabled: {
            bg: ["initial", "initial"]
          }
        },
        _selected: {
          bg: isGray(c) ? [`${c}.50`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`]
        }
      },
      cell: {
        _between: {
          bg: [
            isGray(c) ? transparentizeColor(`${c}.50`, 0.48)(t, m2) : `${c}.50`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ],
          _start: {
            roundedLeft: "md"
          },
          _end: {
            roundedRight: "md"
          }
        }
      },
      day: {
        _hover: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _between: {
            bg: ["initial", "initial"]
          },
          _disabled: {
            bg: ["initial", "initial"]
          },
          _selected: {
            bg: isGray(c) ? [`${c}.100`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`]
          }
        },
        _today: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _between: {
            bg: ["initial", "initial"]
          }
        },
        _start: {
          roundedRight: "0"
        },
        _end: {
          roundedLeft: "0"
        },
        _selected: {
          bg: isGray(c) ? [`${c}.100`, `${c}.700`] : [isAccessible(c) ? `${c}.400` : `${c}.500`, `${c}.600`],
          color: [isGray(c) || isAccessible(c) ? `black` : `white`, `white`],
          borderColor: ["transparent", "transparent"]
        }
      }
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      button: {
        _hover: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _disabled: {
            bg: ["initial", "initial"]
          }
        },
        _selected: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 58)(t, m2)
          ],
          color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`]
        }
      },
      cell: {
        _between: {
          bg: [
            isGray(c) ? transparentizeColor(`${c}.50`, 0.48)(t, m2) : `${c}.50`,
            shadeColor(`${c}.300`, 72)(t, m2)
          ],
          _start: {
            roundedLeft: "md"
          },
          _end: {
            roundedRight: "md"
          }
        }
      },
      day: {
        _hover: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _between: {
            bg: ["initial", "initial"]
          },
          _disabled: {
            bg: ["initial", "initial"]
          },
          _selected: {
            bg: [
              isGray(c) ? `${c}.50` : `${c}.100`,
              shadeColor(`${c}.300`, 58)(t, m2)
            ]
          }
        },
        _today: {
          bg: ["blackAlpha.50", "whiteAlpha.50"],
          _between: {
            bg: ["initial", "initial"]
          }
        },
        _start: {
          roundedRight: "0"
        },
        _end: {
          roundedLeft: "0"
        },
        _selected: {
          bg: [
            isGray(c) ? `${c}.50` : `${c}.100`,
            shadeColor(`${c}.300`, 58)(t, m2)
          ],
          color: [`${c}.800`, isGray(c) ? `${c}.50` : `${c}.200`],
          borderColor: ["transparent", "transparent"]
        }
      }
    }),
    unstyled: {
      container: {
        gap: "inherit",
        fontSize: "inherit"
      },
      content: {
        w: "auto"
      },
      label: {
        h: "auto",
        pointerEvents: "inherit",
        _hover: {
          bg: "inherit"
        },
        _active: {
          bg: "inherit",
          pointerEvents: "inherit"
        }
      },
      labelIcon: {
        color: "inherit"
      },
      control: {
        fontSize: "inherit",
        w: "auto",
        h: "auto",
        _hover: {
          bg: "inherit"
        },
        _active: {
          bg: "inherit"
        },
        _hidden: {
          opacity: "inherit",
          pointerEvents: "inherit"
        }
      },
      button: {
        h: "auto",
        _hover: {
          bg: "inherit"
        },
        _active: {
          bg: "inherit"
        },
        _disabled: {
          opacity: "inherit",
          cursor: "inherit",
          boxShadow: "inherit",
          _focusVisible: {
            boxShadow: "inherit"
          }
        }
      },
      weekday: {
        userSelect: "auto",
        color: "inherit",
        w: "auto",
        h: "auto"
      },
      day: {
        w: "auto",
        h: "auto",
        _hover: {
          bg: "inherit"
        },
        _active: {
          bg: "inherit"
        },
        _weekend: {
          color: "inherit"
        },
        _outside: {
          color: "inherit"
        },
        _holiday: {
          color: "inherit"
        },
        _disabled: {
          opacity: "inherit",
          cursor: "inherit",
          boxShadow: "inherit",
          _focusVisible: {
            boxShadow: "inherit"
          }
        }
      }
    }
  },
  sizes: {
    sm: {
      container: {
        fontSize: "xs"
      },
      content: {
        w: 56
      },
      label: {
        h: 8
      },
      control: {
        w: 8,
        h: 8
      },
      button: {
        h: 8
      },
      weekday: {
        w: 8,
        h: 8
      },
      day: {
        w: 8,
        h: 8
      }
    },
    md: {
      container: {
        fontSize: "sm"
      },
      content: {
        w: "17.5rem"
      },
      label: {
        h: 10
      },
      control: {
        w: 10,
        h: 10
      },
      button: {
        h: 10
      },
      weekday: {
        w: 10,
        h: 10
      },
      day: {
        w: 10,
        h: 10
      }
    },
    lg: {
      container: {
        fontSize: "md"
      },
      content: {
        w: "21rem"
      },
      label: {
        h: 12
      },
      control: {
        fontSize: "1.5em",
        w: 12,
        h: 12
      },
      button: {
        h: 12
      },
      weekday: {
        w: 12,
        h: 12
      },
      day: {
        w: 12,
        h: 12
      }
    },
    full: {
      container: {
        w: "full",
        fontSize: "md"
      },
      content: {
        w: "full"
      },
      label: {
        h: 12
      },
      control: {
        fontSize: "1.5em",
        w: 12,
        h: 12
      },
      button: {
        h: 12
      },
      weekday: {
        w: "full",
        h: 12
      },
      day: {
        w: "full",
        h: 12
      }
    }
  },
  defaultProps: {
    size: "md",
    variant: "solid",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-MILHHRQL.mjs
var Card = {
  baseStyle: {
    container: {},
    header: {},
    body: {
      flex: "1"
    },
    footer: {}
  },
  variants: {
    elevated: {
      container: {
        boxShadow: ["md", "dark-md"]
      }
    },
    outline: {
      container: {
        borderWidth: "1px"
      }
    },
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: {
        bg: [tintColor(`${c}.600`, 16)(t, m2), shadeColor(`${c}.600`, 16)(t, m2)],
        color: "white"
      }
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: {
        bg: [`${c}.100`, shadeColor(`${c}.300`, 58)(t, m2)]
      }
    }),
    unstyled: {
      container: { rounded: 0 },
      header: { p: 0 },
      body: { p: 0 },
      footer: { p: 0 }
    }
  },
  sizes: {
    sm: {
      container: { rounded: "base" },
      header: { pt: "sm", px: "sm", gap: "sm" },
      body: { py: "sm", px: "sm", gap: "sm" },
      footer: { pb: "sm", px: "sm", gap: "sm" }
    },
    md: {
      container: { rounded: "md" },
      header: { pt: "md", px: "md", gap: "md" },
      body: { py: "md", px: "md", gap: "md" },
      footer: { pb: "md", px: "md", gap: "md" }
    },
    normal: {
      container: { rounded: "lg" },
      header: { pt: "normal", px: "normal", gap: "normal" },
      body: { py: "normal", px: "normal", gap: "normal" },
      footer: { pb: "normal", px: "normal", gap: "normal" }
    },
    lg: {
      container: { rounded: "xl" },
      header: { pt: "lg", px: "lg", gap: "lg" },
      body: { py: "lg", px: "lg", gap: "lg" },
      footer: { pb: "lg", px: "lg", gap: "lg" }
    }
  },
  defaultProps: {
    variant: "elevated",
    colorScheme: "primary",
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-ROGAMFA6.mjs
var Carousel = {
  baseStyle: {
    container: {
      w: "100%"
    },
    inner: {},
    slide: {},
    control: {},
    prev: ({ orientation: o }) => ({
      ...o === "vertical" ? { left: "50%", top: "4", transform: "translateX(-50%)" } : { top: "50%", left: "4", transform: "translateY(-50%)" }
    }),
    next: ({ orientation: o }) => ({
      ...o === "vertical" ? { left: "50%", bottom: "4", transform: "translateX(-50%)" } : { top: "50%", right: "4", transform: "translateY(-50%)" }
    }),
    indicators: ({ orientation: o }) => ({
      gap: "md",
      ...o === "vertical" ? {
        py: "4",
        h: "100%",
        top: "50%",
        right: "4",
        transform: "translateY(-50%)"
      } : {
        px: "4",
        w: "100%",
        h: "2",
        left: "50%",
        bottom: "4",
        transform: "translateX(-50%)"
      }
    }),
    indicator: ({ orientation: o }) => ({
      rounded: "full",
      bg: ["whiteAlpha.400", "blackAlpha.400"],
      _hover: {
        bg: ["whiteAlpha.500", "blackAlpha.500"]
      },
      _active: {
        bg: [`whiteAlpha.600`, `blackAlpha.600`]
      },
      _selected: {
        bg: [`whiteAlpha.700`, `blackAlpha.700`]
      },
      transitionProperty: "common",
      transitionDuration: "slower",
      ...o === "vertical" ? { h: "8", right: "4" } : { w: "8", bottom: "4" }
    })
  },
  sizes: {
    sm: {
      inner: {
        h: "sm"
      },
      indicators: ({ orientation: o }) => ({
        ...o === "vertical" ? { w: "1.5" } : { h: "1.5" }
      })
    },
    md: {
      inner: {
        h: "md"
      },
      indicators: ({ orientation: o }) => ({
        ...o === "vertical" ? { w: "1.5" } : { h: "1.5" }
      })
    },
    lg: {
      inner: {
        h: "lg"
      },
      indicators: ({ orientation: o }) => ({
        ...o === "vertical" ? { w: "2" } : { h: "2" }
      })
    },
    xl: {
      inner: {
        h: "xl"
      },
      indicators: ({ orientation: o }) => ({
        ...o === "vertical" ? { w: "2" } : { h: "2" }
      })
    }
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-7MHA3HIA.mjs
var Accordion = {
  baseStyle: {
    container: {},
    item: {},
    button: {
      transitionProperty: "common",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _nativeDisabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      "&[aria-disabled=true]": {
        cursor: "default"
      },
      py: "3",
      px: "4"
    },
    panel: {
      px: "4",
      pb: "3"
    },
    icon: {
      ml: "auto",
      fontSize: "1.25em",
      color: ["blackAlpha.600", "whiteAlpha.700"]
    }
  },
  variants: {
    basic: {
      item: {
        borderTopWidth: "1px",
        borderColor: "inherit",
        _last: {
          borderBottomWidth: "1px"
        }
      },
      button: {
        "&:hover:not(:disabled):not([aria-disabled=true])": {
          bg: ["blackAlpha.50", "whiteAlpha.50"]
        }
      }
    },
    card: {
      item: {
        borderWidth: "1px",
        rounded: "md",
        bg: ["blackAlpha.50", "whiteAlpha.50"],
        _expanded: {
          bg: ["white", "black"]
        },
        _notFirst: {
          mt: "md"
        }
      },
      button: {
        _hover: {
          "&:hover:not(:disabled):not([aria-disabled=true])": {
            bg: ["blackAlpha.50", "whiteAlpha.50"]
          },
          _expanded: {
            bg: "none"
          }
        }
      }
    },
    unstyled: {}
  },
  defaultProps: {
    variant: "basic"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-OOQAVO3V.mjs
var Alert2 = {
  baseStyle: {
    container: {
      px: 4,
      py: 3,
      rounded: "md"
    },
    icon: {
      flexShrink: 0,
      marginEnd: 3,
      boxSize: 5
    },
    loading: {
      flexShrink: 0,
      marginEnd: 3,
      fontSize: "xl"
    },
    title: {
      marginEnd: 2,
      fontWeight: "bold",
      lineHeight: 5
    },
    description: {
      lineHeight: 5
    }
  },
  variants: {
    basic: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: { bg: ["white", "black"], borderWidth: "1px" },
      icon: { color: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`] }
    }),
    subtle: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: { bg: [`${c}.100`, shadeColor(`${c}.300`, 58)(t, m2)] },
      icon: { color: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`] }
    }),
    solid: ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: {
        bg: [tintColor(`${c}.600`, 16)(t, m2), shadeColor(`${c}.600`, 16)(t, m2)],
        color: "white"
      }
    }),
    "island-accent": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary"
    }) => ({
      container: {
        bg: ["white", "black"],
        borderWidth: "1px",
        pl: 7,
        _before: {
          content: '""',
          position: "absolute",
          top: "50%",
          left: 3,
          transform: "translateY(-50%)",
          w: 1,
          h: "calc(100% - 1.5rem)",
          bg: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`],
          rounded: "full"
        }
      },
      icon: { color: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`] }
    }),
    "left-accent": ({
      theme: t,
      colorMode: m2,
      colorScheme: c = "primary"
    }) => ({
      container: {
        bg: [`${c}.100`, shadeColor(`${c}.300`, 58)(t, m2)],
        pl: 3,
        borderLeft: "0.25rem solid",
        borderLeftColor: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`],
        rounded: 4
      },
      icon: { color: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`] }
    }),
    "top-accent": ({ theme: t, colorMode: m2, colorScheme: c = "primary" }) => ({
      container: {
        bg: [`${c}.100`, shadeColor(`${c}.300`, 58)(t, m2)],
        pt: 3,
        borderTop: "0.25rem solid",
        borderTopColor: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`],
        rounded: 4
      },
      icon: { color: [tintColor(`${c}.600`, 16)(t, m2), `${c}.400`] }
    })
  },
  defaultProps: {
    variant: "basic",
    colorScheme: "primary"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-6HCWNNG4.mjs
var HueSlider = {
  baseStyle: {
    container: {
      w: "100%",
      rounded: "full",
      cursor: "pointer",
      _readOnly: { cursor: "auto" },
      _disabled: {
        opacity: 0.6,
        cursor: "not-allowed"
      }
    },
    overlay: {
      rounded: "full"
    },
    track: {},
    thumb: {
      rounded: "full",
      outline: 0,
      borderWidth: "3px",
      borderColor: "whiteAlpha.950",
      boxShadow: ["md", "dark-md"],
      transitionProperty: "transform",
      transitionDuration: "normal",
      _active: {
        transform: `scale(1.15)`
      },
      _focusVisible: {
        boxShadow: ["outline", "outline"]
      }
    }
  },
  sizes: {
    sm: {
      container: { h: "3" },
      thumb: { boxSize: "3" }
    },
    md: {
      container: { h: "4" },
      thumb: { boxSize: "4" }
    },
    lg: {
      container: { h: "5" },
      thumb: { boxSize: "5" }
    }
  },
  defaultProps: {
    size: "md"
  }
};

// node_modules/@yamada-ui/theme/dist/chunk-CKG635AU.mjs
var AlphaSlider = mergeMultiStyle(HueSlider)();

// node_modules/@yamada-ui/theme/dist/chunk-5VO6Z7SC.mjs
var AreaChart = mergeMultiStyle(
  LineChart,
  {
    baseStyle: {
      area: {}
    }
  }
)({ omit: ["line"] });

// node_modules/@yamada-ui/theme/dist/chunk-5LAQ4NUS.mjs
var Autocomplete = mergeMultiStyle(Select)();

// node_modules/@yamada-ui/theme/dist/chunk-AFSU3HAL.mjs
var components = {
  Accordion,
  Alert: Alert2,
  AlphaSlider,
  AreaChart,
  Autocomplete,
  Avatar,
  Badge,
  BarChart,
  Breadcrumb,
  Button,
  Calendar,
  Card,
  Carousel,
  Checkbox,
  CircleProgress,
  CloseButton: CloseButton2,
  Collapse,
  ColorPicker,
  ColorSelector,
  ColorSwatch,
  Container,
  ContextMenu,
  DatePicker,
  Dialog,
  Divider,
  DonutChart,
  Drawer,
  Dropzone,
  Editable,
  Fade,
  Fieldset,
  FileButton,
  FileInput,
  FormControl,
  Heading,
  HueSlider,
  Icon: Icon2,
  Image: Image2,
  Indicator,
  InfiniteScrollArea,
  Input,
  Kbd,
  LineChart,
  Link,
  List,
  Loading: Loading2,
  Mark,
  Markdown,
  Menu,
  Modal,
  MonthPicker,
  MultiAutocomplete,
  MultiDatePicker,
  MultiSelect,
  NativeSelect,
  NumberInput,
  Pagination,
  PagingTable,
  PieChart,
  PinInput,
  Popover,
  Progress,
  RadarChart,
  RadialChart,
  Radio,
  RangeDatePicker,
  RangeSlider,
  Rating,
  Reorder: Reorder2,
  Resizable,
  SaturationSlider,
  ScaleFade,
  ScrollArea,
  SegmentedControl,
  Select,
  NativeTable,
  Skeleton,
  Slide,
  SlideFade,
  Slider,
  Stat,
  Stepper,
  Switch,
  Table,
  Tabs,
  Tag,
  Text,
  Textarea,
  Toggle,
  Tooltip,
  YearPicker
};

// node_modules/@yamada-ui/theme/dist/chunk-E2BHHEWG.mjs
var config = {
  initialThemeScheme: "base",
  initialColorMode: "light",
  var: { prefix: "ui" },
  breakpoint: { direction: "down", identifier: "@media screen" }
};

// node_modules/@yamada-ui/theme/dist/chunk-VEG7NYSY.mjs
var semantics = {
  colors: {
    primary: "blue.500",
    secondary: "violet.500",
    info: "blue.500",
    success: "green.500",
    warning: "orange.500",
    danger: "red.500",
    link: "blue.500"
  },
  colorSchemes: {
    primary: "blue",
    secondary: "violet",
    info: "blue",
    success: "green",
    warning: "orange",
    danger: "red",
    link: "blue"
  },
  spaces: {
    xs: "1",
    sm: "2",
    md: "4",
    normal: "6",
    lg: "8",
    xl: "12",
    "2xl": "16",
    "3xl": "24",
    "4xl": "32"
  }
};

// node_modules/@yamada-ui/theme/dist/index.mjs
var defaultTheme = {
  styles: { globalStyle, resetStyle, layerStyles, textStyles },
  semantics,
  components,
  ...tokens
};
var baseTheme = {
  styles: { globalStyle, resetStyle, layerStyles, textStyles },
  semantics,
  ...tokens
};
var defaultConfig = config;

// node_modules/@yamada-ui/providers/dist/chunk-DT5D5WTK.mjs
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var UIProvider = ({
  theme = defaultTheme,
  config: config2 = defaultConfig,
  disableResetStyle,
  disableGlobalStyle,
  colorModeManager: colorModeManager2,
  colorModeStorageKey,
  themeSchemeManager: themeSchemeManager2,
  themeSchemeStorageKey,
  environment: environment2,
  disableEnvironment,
  children
}) => {
  var _a;
  return (0, import_jsx_runtime36.jsx)(
    EnvironmentProvider,
    {
      environment: environment2,
      disabled: disableEnvironment,
      children: (0, import_jsx_runtime36.jsx)(
        ThemeProvider3,
        {
          theme,
          config: config2,
          themeSchemeManager: themeSchemeManager2,
          storageKey: themeSchemeStorageKey,
          children: (0, import_jsx_runtime36.jsx)(
            ColorModeProvider,
            {
              colorModeManager: colorModeManager2,
              storageKey: colorModeStorageKey,
              config: config2,
              children: (0, import_jsx_runtime36.jsx)(MotionConfig, { ...(_a = config2.motion) == null ? void 0 : _a.config, children: (0, import_jsx_runtime36.jsxs)(LoadingProvider, { ...config2.loading, children: [
                !disableResetStyle ? (0, import_jsx_runtime36.jsx)(ResetStyle, {}) : null,
                !disableGlobalStyle ? (0, import_jsx_runtime36.jsx)(GlobalStyle, {}) : null,
                children,
                (0, import_jsx_runtime36.jsx)(NoticeProvider, { ...config2.notice })
              ] }) })
            }
          )
        }
      )
    }
  );
};

// node_modules/@yamada-ui/theme-tools/dist/chunk-ZKU3SVSM.mjs
var extendConfig = (config2) => merge(defaultConfig, config2);

// node_modules/@yamada-ui/theme-tools/dist/chunk-RZ5VOD2J.mjs
var createExtendTheme = (initialTheme = defaultTheme) => (...extensions) => ({ merge: merge5 = true, pick = [], omit = [] } = {}) => {
  let overrides = [...extensions];
  let theme = extensions[extensions.length - 1];
  if (omit.length) initialTheme = omitObject(initialTheme, omit);
  if (pick.length) initialTheme = pickObject(initialTheme, pick);
  if (!isFunction(theme) && overrides.length > 1) {
    overrides = overrides.slice(0, overrides.length - 1);
    if (merge5) theme = merge(initialTheme, theme);
  } else {
    theme = merge5 ? initialTheme : {};
  }
  return overrides.reduce(
    (prev2, extension) => merge(prev2, runIfFunc(extension, prev2)),
    theme
  );
};
var extendTheme = createExtendTheme(defaultTheme);
var extendBaseTheme = createExtendTheme(baseTheme);
var extendToken = (token2, tokens2) => merge(getMemoizedObject(defaultTheme, token2, {}), tokens2 != null ? tokens2 : {});
var extendStyle = (name, style) => {
  var _a;
  const props2 = {
    theme: {
      __config: {},
      __cssMap: {},
      __cssVars: {},
      __breakpoints: void 0
    }
  };
  return merge(
    runIfFunc(getMemoizedObject(defaultTheme, `styles.${name}`, {}), props2),
    (_a = runIfFunc(style, props2)) != null ? _a : {}
  );
};
var extendComponent = (name, componentStyle) => merge(
  getMemoizedObject(
    defaultTheme,
    `components.${name}`,
    {}
  ),
  componentStyle != null ? componentStyle : {}
);
var extendComponentSize = (name, componentSizes) => merge(
  getMemoizedObject(defaultTheme, `components.${name}.sizes`, {}),
  componentSizes != null ? componentSizes : {}
);
var extendComponentVariant = (name, componentVariants) => merge(
  getMemoizedObject(
    defaultTheme,
    `components.${name}.variants`,
    {}
  ),
  componentVariants != null ? componentVariants : {}
);
var extendComponentDefaultProps = (name, componentDefaultProps) => merge(
  getMemoizedObject(
    defaultTheme,
    `components.${name}.defaultProps`,
    {}
  ),
  componentDefaultProps != null ? componentDefaultProps : {}
);

// node_modules/@yamada-ui/theme-tools/dist/chunk-QHLS3VI4.mjs
var analyzeValue = (value) => {
  const n = parseFloat(value.toString());
  const unit = value.toString().replace(String(n), "");
  return { n, unit };
};
var spaces2 = (x) => {
  if (isNaN(x)) throw new Error("The multiplier must be a valid number.");
  if (!isFinite(x)) throw new Error("The multiplier must be a finite number.");
  if (isString(x)) throw new Error("The multiplier must be a number.");
  const { spaces: defaultSpaces } = defaultTheme;
  const generateValue = (value) => {
    const { n, unit } = analyzeValue(value);
    return `${n * x}${unit}`;
  };
  const computedSpaces = Object.entries(defaultSpaces).reduce(
    (prev2, [key, value]) => {
      if (key === "px") {
        prev2[key] = value;
      } else {
        const resolvedKey = Number(key);
        if (isArray(value)) {
          const [lightValue, darkValue] = value;
          prev2[resolvedKey] = [
            generateValue(lightValue),
            generateValue(darkValue)
          ];
        } else {
          prev2[resolvedKey] = generateValue(value);
        }
      }
      return prev2;
    },
    {}
  );
  return computedSpaces;
};
var tones = (hex2) => {
  var _a;
  const [h, s, l, a] = (_a = parseToHsla2(hex2)) != null ? _a : [0, 0, 0];
  const v = l > 0.5;
  const x = ((v ? 1 : 0.95) - l) / 5;
  const y = (l - (!v ? 0.05 : 0.15)) / 5;
  const tokens2 = TONES.reduce((prev2, tone) => {
    if (tone === 500) {
      prev2[tone] = hex2;
    } else {
      const t = tone / 100;
      const w = t > 5;
      const u = (w ? t - 5 : 5 - t) * (w ? y : x);
      const z = w ? l - u : l + u;
      prev2[tone] = hslaTo([h, s, z, a != null ? a : 1])("hex");
    }
    return prev2;
  }, {});
  return tokens2;
};
var generate = {
  /**
   * Generate tokens by multiplying the default theme's `spaces` with the provided number.
   */
  spaces: spaces2,
  /**
   * Generate tone colors from 50 to 950 based on the provided hex value.
   */
  tones
};

// node_modules/@yamada-ui/theme-tools/dist/chunk-OO3Q6WLN.mjs
var withDefaultSize = ({
  size,
  components: components2
}) => (theme) => {
  var _a;
  let keys2 = Object.keys((_a = theme.components) != null ? _a : {});
  if (isArray(components2)) keys2 = components2;
  return merge(theme, {
    components: Object.fromEntries(
      keys2.map((key) => [key, { defaultProps: { size } }])
    )
  });
};
var withDefaultVariant = ({
  variant,
  components: components2
}) => (theme) => {
  var _a;
  let keys2 = Object.keys((_a = theme.components) != null ? _a : {});
  if (isArray(components2)) keys2 = components2;
  return merge(theme, {
    components: Object.fromEntries(
      keys2.map((key) => [key, { defaultProps: { variant } }])
    )
  });
};
var withDefaultColorScheme = ({
  colorScheme,
  components: components2
}) => (theme) => {
  var _a;
  let keys2 = Object.keys((_a = theme.components) != null ? _a : {});
  if (isArray(components2)) keys2 = components2;
  return merge(theme, {
    components: Object.fromEntries(
      keys2.map((key) => [key, { defaultProps: { colorScheme } }])
    )
  });
};
var withDefaultProps = ({
  defaultProps,
  components: components2
}) => (theme) => {
  var _a;
  let keys2 = Object.keys((_a = theme.components) != null ? _a : {});
  if (isArray(components2)) keys2 = components2;
  return merge(theme, {
    components: Object.fromEntries(
      keys2.map((key) => [key, { defaultProps }])
    )
  });
};

// node_modules/@yamada-ui/use-controllable-state/dist/index.mjs
var import_react73 = __toESM(require_react(), 1);
var useControllableState = ({
  value,
  ...rest
}) => {
  var _a;
  (_a = rest.onUpdate) != null ? _a : rest.onUpdate = (prev2, next2) => prev2 !== next2;
  const onChange = useCallbackRef(rest.onChange);
  const onUpdate = useCallbackRef(rest.onUpdate);
  const [defaultValue, setDefaultValue] = (0, import_react73.useState)(rest.defaultValue);
  const controlled = value !== void 0;
  const resolvedValue = controlled ? value : defaultValue;
  const setValue = useCallbackRef(
    (next2) => {
      const nextValue = runIfFunc(next2, resolvedValue);
      if (!onUpdate(resolvedValue, nextValue)) return;
      if (!controlled || isUndefined(nextValue) || isNull(nextValue))
        setDefaultValue(nextValue);
      onChange(nextValue);
    },
    [controlled, resolvedValue, onChange, onUpdate]
  );
  return [resolvedValue, setValue];
};

// node_modules/@yamada-ui/use-descendant/dist/index.mjs
var import_react74 = __toESM(require_react(), 1);
var sortNodes = (nodes) => nodes.sort((a, b) => {
  const compare2 = a.compareDocumentPosition(b);
  if (compare2 & Node.DOCUMENT_POSITION_FOLLOWING || compare2 & Node.DOCUMENT_POSITION_CONTAINED_BY)
    return -1;
  if (compare2 & Node.DOCUMENT_POSITION_PRECEDING || compare2 & Node.DOCUMENT_POSITION_CONTAINS)
    return 1;
  if (compare2 & Node.DOCUMENT_POSITION_DISCONNECTED || compare2 & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
    throw Error("Cannot sort the given nodes.");
  } else {
    return 0;
  }
});
var getNextIndex = (current, max2, loop) => {
  let next2 = current + 1;
  if (loop && next2 >= max2) next2 = 0;
  return next2;
};
var getPrevIndex = (current, max2, loop) => {
  let next2 = current - 1;
  if (loop && next2 < 0) next2 = max2;
  return next2;
};
var descendantsManager = () => {
  const descendants = /* @__PURE__ */ new Map();
  const assignIndex = (newDescendants) => {
    descendants.forEach((descendant) => {
      const index = newDescendants.indexOf(descendant.node);
      descendant.index = index;
      descendant.node.dataset.index = descendant.index.toString();
    });
  };
  const setDescendants = (node3, options) => {
    if (!node3 || descendants.has(node3)) return;
    const keys2 = Array.from(descendants.keys()).concat(node3);
    const sorted = sortNodes(keys2);
    if (options == null ? void 0 : options.disabled) options.disabled = !!options.disabled;
    const descendant = { node: node3, index: -1, ...options };
    descendants.set(node3, descendant);
    assignIndex(sorted);
  };
  const register = (nodeOrOptions) => {
    if (nodeOrOptions == null) return;
    if (isElement(nodeOrOptions)) return setDescendants(nodeOrOptions);
    return (node3) => setDescendants(node3, nodeOrOptions);
  };
  const unregister = (node3) => {
    descendants.delete(node3);
    const sorted = sortNodes(Array.from(descendants.keys()));
    assignIndex(sorted);
  };
  const destroy = () => descendants.clear();
  const count = (filter3) => values(filter3).length;
  const enabledCount = (filter3) => enabledValues(filter3).length;
  const indexOf = (node3) => {
    var _a, _b;
    return !node3 ? -1 : (_b = (_a = descendants.get(node3)) == null ? void 0 : _a.index) != null ? _b : -1;
  };
  const enabledIndexOf = (node3, filter3) => node3 == null ? -1 : enabledValues(filter3).findIndex((i) => i.node.isSameNode(node3));
  const values = (filter3) => {
    const values2 = Array.from(descendants.values());
    if (filter3) {
      return values2.filter(filter3).sort((a, b) => a.index - b.index);
    } else {
      return values2.sort((a, b) => a.index - b.index);
    }
  };
  const enabledValues = (filter3) => values(filter3).filter(({ disabled }) => !disabled);
  const value = (index, filter3) => {
    if (count(filter3) === 0) return void 0;
    return values(filter3)[index];
  };
  const enabledValue = (index, filter3) => {
    if (enabledCount(filter3) === 0) return void 0;
    return enabledValues(filter3)[index];
  };
  const firstValue = (filter3) => value(0, filter3);
  const enabledFirstValue = (filter3) => enabledValue(0, filter3);
  const lastValue = (filter3) => value(descendants.size - 1, filter3);
  const enabledLastValue = (filter3) => enabledValue(enabledValues(filter3).length - 1, filter3);
  const prevValue = (index, filter3, loop = true) => {
    const prev2 = getPrevIndex(index, count(filter3) - 1, loop);
    return value(prev2, filter3);
  };
  const enabledPrevValue = (index, filter3, loop = true) => {
    const target = value(index);
    if (!target) return;
    const enabledIndex = enabledIndexOf(target.node, filter3);
    const prevEnabledIndex = getPrevIndex(
      enabledIndex,
      enabledCount(filter3) - 1,
      loop
    );
    return enabledValue(prevEnabledIndex, filter3);
  };
  const nextValue = (index, filter3, loop = true) => {
    const next2 = getNextIndex(index, count(filter3), loop);
    return value(next2, filter3);
  };
  const enabledNextValue = (index, filter3, loop = true) => {
    const target = value(index);
    if (!target) return;
    const enabledIndex = enabledIndexOf(target.node, filter3);
    const nextEnabledIndex = getNextIndex(
      enabledIndex,
      enabledCount(filter3),
      loop
    );
    return enabledValue(nextEnabledIndex, filter3);
  };
  return {
    register,
    unregister,
    destroy,
    count,
    values,
    value,
    indexOf,
    firstValue,
    lastValue,
    prevValue,
    nextValue,
    enabledCount,
    enabledValues,
    enabledValue,
    enabledIndexOf,
    enabledFirstValue,
    enabledLastValue,
    enabledPrevValue,
    enabledNextValue
  };
};
var useDescendants = () => {
  const descendants = (0, import_react74.useRef)(descendantsManager());
  useSafeLayoutEffect(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
};
var [DescendantsContextProvider, useDescendantsContext] = createContext2({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsContextProvider"
});
var useDescendant = (options) => {
  const descendants = useDescendantsContext();
  const [index, setIndex] = (0, import_react74.useState)(-1);
  const ref = (0, import_react74.useRef)(null);
  useSafeLayoutEffect(() => {
    return () => {
      if (!ref.current) return;
      descendants.unregister(ref.current);
    };
  }, []);
  useSafeLayoutEffect(() => {
    if (!ref.current) return;
    const dataIndex = Number(ref.current.dataset.index);
    if (index != dataIndex && !Number.isNaN(dataIndex)) setIndex(dataIndex);
  });
  const refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
  return {
    descendants,
    index,
    enabledIndex: descendants.enabledIndexOf(
      ref.current,
      options == null ? void 0 : options.filter
    ),
    register: mergeRefs(refCallback, ref)
  };
};
var createDescendant = () => ({
  DescendantsContextProvider: cast(
    DescendantsContextProvider
  ),
  useDescendantsContext: () => cast(useDescendantsContext()),
  useDescendants: () => useDescendants(),
  useDescendant: (options) => useDescendant(options)
});

// node_modules/@yamada-ui/accordion/dist/chunk-HXC752RO.mjs
var import_react75 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var {
  DescendantsContextProvider: DescendantsContextProvider2,
  useDescendants: useDescendants2,
  useDescendant: useAccordionDescendant
} = createDescendant();
var [AccordionProvider, useAccordionContext] = createContext2({
  name: "AccordionContext",
  errorMessage: `useAccordionContext returned is 'undefined'. Seems you forgot to wrap the components in "<Accordion />"`
});
var Accordion2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Accordion", props2);
  const {
    className,
    index: value,
    defaultIndex: defaultValue,
    isMultiple,
    isToggle,
    iconHidden,
    icon,
    onChange,
    ...rest
  } = omitThemeProps(mergedProps);
  if ((value || defaultValue) != null && !isArray(value || defaultValue) && isMultiple) {
    console.warn(
      `Accordion: If 'isMultiple' is passed, then 'index' or 'defaultIndex' must be an array.`
    );
  }
  if (isMultiple && isToggle) {
    console.warn(
      `Accordion: If 'isMultiple' is passed, 'isToggle' will be ignored. Either remove 'isToggle' or 'isMultiple' depending on whether you want isMultiple accordions visible or not`
    );
  }
  const descendants = useDescendants2();
  const [focusedIndex, setFocusedIndex] = (0, import_react75.useState)(-1);
  const [index, setIndex] = useControllableState({
    value,
    defaultValue: () => isMultiple ? defaultValue != null ? defaultValue : [] : defaultValue != null ? defaultValue : -1,
    onChange
  });
  (0, import_react75.useEffect)(() => {
    return () => setFocusedIndex(-1);
  }, []);
  const css4 = { w: "100%", ...styles2.container };
  return (0, import_jsx_runtime37.jsx)(DescendantsContextProvider2, { value: descendants, children: (0, import_jsx_runtime37.jsx)(
    AccordionProvider,
    {
      value: {
        index,
        setIndex,
        focusedIndex,
        setFocusedIndex,
        isMultiple,
        isToggle,
        iconHidden,
        icon,
        styles: styles2
      },
      children: (0, import_jsx_runtime37.jsx)(
        ui.div,
        {
          ref,
          className: cx("ui-accordion", className),
          __css: css4,
          ...rest
        }
      )
    }
  ) });
});

// node_modules/@yamada-ui/accordion/dist/chunk-XVRHRDCY.mjs
var import_react78 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/transitions/dist/chunk-DLA72AGB.mjs
var import_react76 = __toESM(require_react(), 1);
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var isNumeric2 = (value) => value != null && parseFloat(value.toString()) > 0;
var variants = {
  enter: ({
    animationOpacity,
    endingHeight: height,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    enter
  } = {}) => ({
    ...animationOpacity ? { opacity: 1 } : {},
    height,
    transition: transitionEnter(transition == null ? void 0 : transition.enter)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    ...enter
  }),
  exit: ({
    animationOpacity,
    startingHeight: height,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    exit
  } = {}) => ({
    ...animationOpacity ? { opacity: isNumeric2(height) ? 1 : 0 } : {},
    height,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
    ...exit
  })
};
var collapseProps = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants
};
var Collapse2 = motionForwardRef((props2, ref) => {
  const [style, mergedProps] = useComponentStyle("Collapse", props2);
  let {
    unmountOnExit,
    isOpen,
    animationOpacity,
    startingHeight,
    endingHeight,
    transition: transitionProp,
    transitionEnd,
    delay: delay2,
    duration,
    className,
    __css,
    ...rest
  } = omitThemeProps(mergedProps);
  const [mounted, setMounted] = (0, import_react76.useState)(false);
  (0, import_react76.useEffect)(() => {
    const isBrowser4 = createdDom();
    if (isBrowser4) setMounted(true);
  }, []);
  const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
  isOpen = unmountOnExit ? isOpen : true;
  const transition = (0, import_react76.useMemo)(() => {
    if (!mounted) {
      return { enter: { duration: 0 } };
    } else if (transitionProp) {
      return transitionProp;
    } else {
      return {
        enter: {
          height: {
            duration: duration != null ? duration : 0.3,
            ease: MOTION_TRANSITION_EASINGS.ease
          },
          opacity: {
            duration: duration != null ? duration : 0.4,
            ease: MOTION_TRANSITION_EASINGS.ease
          }
        },
        exit: {
          height: {
            duration: duration != null ? duration : 0.3,
            ease: MOTION_TRANSITION_EASINGS.ease
          },
          opacity: {
            duration: duration != null ? duration : 0.4,
            ease: MOTION_TRANSITION_EASINGS.ease
          }
        }
      };
    }
  }, [mounted, duration, transitionProp]);
  const custom = {
    animationOpacity,
    startingHeight,
    endingHeight,
    transition,
    transitionEnd,
    delay: delay2,
    duration
  };
  const css4 = {
    ...style,
    ...__css
  };
  return (0, import_jsx_runtime38.jsx)(AnimatePresence, { initial: false, custom, children: isOpen ? (0, import_jsx_runtime38.jsx)(
    Motion,
    {
      ref,
      className: cx("ui-collapse", className),
      ...rest,
      ...collapseProps,
      custom,
      animate: animate2,
      initial: unmountOnExit ? "exit" : false,
      __css: css4,
      style: { overflow: "hidden", ...rest.style }
    }
  ) : null });
});

// node_modules/@yamada-ui/transitions/dist/chunk-TLX7YR22.mjs
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var variants2 = {
  enter: ({ transition, transitionEnd, delay: delay2, duration, enter } = {}) => ({
    opacity: 1,
    transition: transitionEnter(transition == null ? void 0 : transition.enter)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    ...enter
  }),
  exit: ({ transition, transitionEnd, delay: delay2, duration, exit } = {}) => ({
    opacity: 0,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
    ...exit
  })
};
var fadeProps = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants2
};
var Fade2 = motionForwardRef((props2, ref) => {
  const [style, mergedProps] = useComponentStyle("Fade", props2);
  let {
    unmountOnExit,
    isOpen,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    className,
    ...rest
  } = omitThemeProps(mergedProps);
  const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
  const custom = { transition, transitionEnd, delay: delay2, duration };
  isOpen = unmountOnExit ? isOpen && unmountOnExit : true;
  return (0, import_jsx_runtime39.jsx)(AnimatePresence, { custom, children: isOpen ? (0, import_jsx_runtime39.jsx)(
    Motion,
    {
      ref,
      className: cx("ui-fade", className),
      custom,
      ...fadeProps,
      animate: animate2,
      __css: style,
      ...rest
    }
  ) : null });
});

// node_modules/@yamada-ui/transitions/dist/chunk-OZ3KA2B4.mjs
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var variants3 = {
  enter: ({ transition, transitionEnd, delay: delay2, duration, enter } = {}) => ({
    opacity: 1,
    scale: 1,
    transition: transitionEnter(transition == null ? void 0 : transition.enter)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    ...enter
  }),
  exit: ({
    scale: scale2,
    reverse,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    exit
  } = {}) => ({
    opacity: 0,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    ...reverse ? { scale: scale2, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { scale: scale2, ...transitionEnd == null ? void 0 : transitionEnd.exit } },
    ...exit
  })
};
var scaleFadeProps = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants3
};
var ScaleFade2 = motionForwardRef(
  (props2, ref) => {
    const [style, mergedProps] = useComponentStyle("ScaleFade", props2);
    let {
      unmountOnExit,
      isOpen,
      scale: scale2,
      reverse,
      transition,
      transitionEnd,
      delay: delay2,
      duration,
      className,
      ...rest
    } = omitThemeProps(mergedProps);
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = {
      scale: scale2,
      reverse,
      transition,
      transitionEnd,
      delay: delay2,
      duration
    };
    isOpen = unmountOnExit ? isOpen && unmountOnExit : true;
    return (0, import_jsx_runtime40.jsx)(AnimatePresence, { custom, children: isOpen ? (0, import_jsx_runtime40.jsx)(
      Motion,
      {
        ref,
        className: cx("ui-scale-fade", className),
        custom,
        ...scaleFadeProps,
        animate: animate2,
        __css: style,
        ...rest
      }
    ) : null });
  }
);

// node_modules/@yamada-ui/use-breakpoint/dist/index.mjs
var import_react77 = __toESM(require_react(), 1);
var useBreakpoint = () => {
  var _a, _b;
  const animationFrameId = (0, import_react77.useRef)(0);
  const { theme } = useTheme2();
  const breakpoints2 = theme.__breakpoints;
  const {
    containerRef,
    direction = "down",
    identifier: identifier2 = "@media screen"
  } = (_b = (_a = theme.__config) == null ? void 0 : _a.breakpoint) != null ? _b : {};
  const hasContainer = !!containerRef;
  if (!breakpoints2)
    throw Error(
      "useBreakpoint: `breakpoints` is undefined. Seems you forgot to put theme in `breakpoints`"
    );
  const queries2 = (0, import_react77.useMemo)(
    () => breakpoints2.queries.map(({ breakpoint: breakpoint2, minMaxQuery, minW, maxW }) => {
      var _a2;
      const searchValue = identifier2 === "@media screen" ? "@media screen and " : `${identifier2} `;
      const query = (_a2 = minMaxQuery == null ? void 0 : minMaxQuery.replace(searchValue, "")) != null ? _a2 : "";
      return {
        breakpoint: breakpoint2,
        query,
        minW,
        maxW
      };
    }),
    [breakpoints2, identifier2]
  );
  const [breakpoint, setBreakpoint] = (0, import_react77.useState)(() => {
    const isBrowser4 = createdDom();
    if (!isBrowser4 || hasContainer) return "base";
    for (const { breakpoint: breakpoint2, query } of queries2) {
      const mql = window.matchMedia(query);
      if (mql.matches) return breakpoint2;
    }
  });
  const getBreakpoint = (0, import_react77.useCallback)(
    (width) => {
      for (const { breakpoint: breakpoint2, minW, maxW } of queries2) {
        if (direction !== "up") {
          if ((minW != null ? minW : 0) <= width) return breakpoint2;
        } else {
          if (width <= (maxW != null ? maxW : Infinity)) return breakpoint2;
        }
      }
      return "base";
    },
    [queries2, direction]
  );
  (0, import_react77.useEffect)(() => {
    if (!hasContainer) return;
    const isBrowser4 = createdDom();
    if (!isBrowser4) return;
    const observer2 = new ResizeObserver(([entry]) => {
      if (!entry) return;
      cancelAnimationFrame(animationFrameId.current);
      const { width } = entry.contentRect;
      animationFrameId.current = requestAnimationFrame(() => {
        const breakpoint2 = getBreakpoint(width);
        setBreakpoint(breakpoint2);
      });
    });
    if (containerRef.current) observer2.observe(containerRef.current);
    return () => {
      observer2.disconnect();
      if (true)
        cancelAnimationFrame(animationFrameId.current);
    };
  }, [hasContainer, containerRef, getBreakpoint]);
  (0, import_react77.useEffect)(() => {
    if (hasContainer) return;
    const observer2 = queries2.map(({ breakpoint: breakpoint2, query }) => {
      const mql = window.matchMedia(query);
      const onChange = (e) => {
        if (e.matches) setBreakpoint(breakpoint2);
      };
      if (typeof mql.addEventListener === "function")
        mql.addEventListener("change", onChange);
      return () => {
        if (typeof mql.removeEventListener === "function")
          mql.removeEventListener("change", onChange);
      };
    });
    return () => {
      observer2.forEach((unobserve) => unobserve());
    };
  }, [queries2, hasContainer]);
  return breakpoint;
};
var useBreakpointValue = (values) => {
  const { theme } = useTheme2();
  const breakpoint = useBreakpoint();
  return getBreakpointValue(values)(theme, breakpoint);
};
var getBreakpointValue = (values = {}) => (theme, breakpoint) => {
  var _a;
  if (!theme) throw Error("getBreakpointValue: `theme` is undefined.");
  const breakpoints2 = (_a = theme.__breakpoints) == null ? void 0 : _a.keys;
  if (!breakpoints2)
    throw Error("getBreakpointValue: `breakpoints` is undefined.");
  const currentIndex = breakpoints2.indexOf(breakpoint);
  for (let i = currentIndex; 0 < i; i--) {
    const nextBreakpoint = breakpoints2[i];
    if (values.hasOwnProperty(nextBreakpoint)) {
      return values[nextBreakpoint];
    }
  }
  return values.base;
};
var useBreakpointState = (initialState2) => {
  const state = useBreakpointValue(initialState2);
  return (0, import_react77.useState)(state);
};
var useBreakpointEffect = (callback, deps) => {
  const breakpoint = useBreakpoint();
  (0, import_react77.useEffect)(() => {
    callback(breakpoint);
  }, [breakpoint, ...deps]);
};
var useUpdateBreakpointEffect = (callback, deps) => {
  const breakpoint = useBreakpoint();
  useUpdateEffect(() => {
    callback(breakpoint);
  }, [breakpoint, ...deps]);
};

// node_modules/@yamada-ui/use-value/dist/index.mjs
var useValue = (value) => {
  if (isObject(value)) {
    return useBreakpointValue(value);
  } else if (isArray(value)) {
    return useColorModeValue(...value);
  } else {
    return value;
  }
};
var getValue3 = (value) => (theme, colorMode, breakpoint) => {
  if (isObject(value)) {
    return getBreakpointValue(value)(theme, breakpoint);
  } else if (isArray(value)) {
    return getColorModeValue(...value)(colorMode);
  } else {
    return value;
  }
};

// node_modules/@yamada-ui/transitions/dist/chunk-W5FI37PS.mjs
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var variants4 = {
  initial: ({
    offsetX,
    offsetY,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    initial
  }) => ({
    opacity: 0,
    x: offsetX,
    y: offsetY,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
    ...initial
  }),
  enter: ({ transition, transitionEnd, delay: delay2, duration, enter } = {}) => ({
    opacity: 1,
    x: 0,
    y: 0,
    transition: transitionEnter(transition == null ? void 0 : transition.enter)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    ...enter
  }),
  exit: ({
    offsetX,
    offsetY,
    reverse,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    exit
  } = {}) => ({
    opacity: 0,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    ...reverse ? { x: offsetX, y: offsetY, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { x: offsetX, y: offsetY, ...transitionEnd == null ? void 0 : transitionEnd.exit } },
    ...exit
  })
};
var slideFadeProps = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants4
};
var SlideFade2 = motionForwardRef(
  (props2, ref) => {
    const [style, mergedProps] = useComponentStyle("SlideFade", props2);
    let {
      unmountOnExit,
      isOpen,
      offsetX: _offsetX,
      offsetY: _offsetY,
      reverse,
      transition,
      transitionEnd,
      delay: delay2,
      duration,
      className,
      ...rest
    } = omitThemeProps(mergedProps);
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const offsetX = useValue(_offsetX);
    const offsetY = useValue(_offsetY);
    const custom = {
      offsetX,
      offsetY,
      reverse,
      transition,
      transitionEnd,
      delay: delay2,
      duration
    };
    isOpen = unmountOnExit ? isOpen && unmountOnExit : true;
    return (0, import_jsx_runtime41.jsx)(AnimatePresence, { custom, children: isOpen ? (0, import_jsx_runtime41.jsx)(
      Motion,
      {
        ref,
        className: cx("ui-slide-fade", className),
        custom,
        ...slideFadeProps,
        animate: animate2,
        __css: style,
        ...rest
      }
    ) : null });
  }
);

// node_modules/@yamada-ui/transitions/dist/chunk-JOOY5WMC.mjs
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var getSlideProps = (placement = "right") => {
  switch (placement) {
    case "right":
      return MOTION_TRANSITION_VARIANTS.slideRight;
    case "left":
      return MOTION_TRANSITION_VARIANTS.slideLeft;
    case "bottom":
      return MOTION_TRANSITION_VARIANTS.slideDown;
    case "top":
      return MOTION_TRANSITION_VARIANTS.slideUp;
  }
};
var variants5 = {
  enter: ({
    placement,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    enter
  } = {}) => ({
    ...getSlideProps(placement).enter,
    transition: transitionEnter(transition == null ? void 0 : transition.enter)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    ...enter
  }),
  exit: ({
    placement,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    exit
  } = {}) => ({
    ...getSlideProps(placement).exit,
    transition: transitionExit(transition == null ? void 0 : transition.exit)(delay2, duration),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
    ...exit
  })
};
var slideProps = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants5
};
var Slide2 = motionForwardRef((props2, ref) => {
  const [style, mergedProps] = useComponentStyle("Slide", props2);
  let {
    unmountOnExit,
    isOpen,
    placement: _placement,
    transition,
    transitionEnd,
    delay: delay2,
    duration = { enter: 0.4, exit: 0.3 },
    className,
    __css,
    ...rest
  } = omitThemeProps(mergedProps);
  const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
  const placement = useValue(_placement);
  const custom = { placement, transition, transitionEnd, delay: delay2, duration };
  isOpen = unmountOnExit ? isOpen && unmountOnExit : true;
  const { position: position2 } = getSlideProps(placement);
  const css4 = {
    ...style,
    ...__css,
    ...position2
  };
  return (0, import_jsx_runtime42.jsx)(AnimatePresence, { custom, children: isOpen ? (0, import_jsx_runtime42.jsx)(
    Motion,
    {
      ref,
      className: cx("ui-slide", className),
      custom,
      ...slideProps,
      animate: animate2,
      __css: css4,
      ...rest
    }
  ) : null });
});

// node_modules/@yamada-ui/accordion/dist/chunk-XVRHRDCY.mjs
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var AccordionPanel = forwardRef22(
  ({
    className,
    unmountOnExit,
    animationOpacity,
    startingHeight,
    endingHeight,
    transition,
    transitionEnd,
    delay: delay2,
    duration,
    children,
    ...rest
  }, ref) => {
    const { isOpen, getPanelProps } = useAccordionItemContext();
    const { styles: styles2 } = useAccordionContext();
    const resolvedChildren = typeof children === "string" ? (0, import_jsx_runtime43.jsx)("p", { children }) : children;
    const css4 = { ...styles2.panel };
    return (0, import_jsx_runtime43.jsx)(
      Collapse2,
      {
        ...{
          isOpen,
          unmountOnExit,
          animationOpacity,
          startingHeight,
          endingHeight,
          transition,
          transitionEnd,
          delay: delay2,
          duration
        },
        children: (0, import_jsx_runtime43.jsx)(
          ui.div,
          {
            ...getPanelProps(rest, ref),
            className: cx("ui-accordion__panel", className),
            __css: css4,
            children: resolvedChildren
          }
        )
      }
    );
  }
);
var [AccordionItemProvider, useAccordionItemContext] = createContext2({
  name: "AccordionItemContext",
  errorMessage: `useAccordionItemContext returned is 'undefined'. Seems you forgot to wrap the components in "<AccordionItem />"`
});
var AccordionItem = forwardRef22(
  ({ id: id4, className, isDisabled: isDisabled2 = false, label, icon, children, ...rest }, ref) => {
    id4 != null ? id4 : id4 = (0, import_react78.useId)();
    const itemId = `${id4}-item`;
    const panelId = `${id4}-panel`;
    const { index, setIndex, setFocusedIndex, isMultiple, isToggle, styles: styles2 } = useAccordionContext();
    const {
      index: i,
      register,
      descendants
    } = useAccordionDescendant({ disabled: isDisabled2 });
    const isOpen = i !== -1 ? isArray(index) ? index.includes(i) : index === i : false;
    if (isOpen && isDisabled2)
      console.warn(`Accordion: Cannot open a disabled accordion item`);
    const onChange = (0, import_react78.useCallback)(
      (isOpen2) => {
        if (i === -1) return;
        if (isMultiple && isArray(index)) {
          setIndex(isOpen2 ? index.concat(i) : index.filter((v) => v !== i));
        } else if (isOpen2) {
          setIndex(i);
        } else if (isToggle) {
          setIndex(-1);
        }
      },
      [isMultiple, isToggle, i, index, setIndex]
    );
    const onFocus4 = (0, import_react78.useCallback)(() => {
      setFocusedIndex(i);
    }, [setFocusedIndex, i]);
    const onClick2 = (0, import_react78.useCallback)(() => {
      onChange(!isOpen);
      setFocusedIndex(i);
    }, [i, setFocusedIndex, isOpen, onChange]);
    const onKeyDown = (0, import_react78.useCallback)(
      (ev) => {
        const actions = {
          ArrowDown: () => {
            const next2 = descendants.enabledNextValue(i);
            next2 == null ? void 0 : next2.node.focus();
          },
          ArrowUp: () => {
            const prev2 = descendants.enabledPrevValue(i);
            prev2 == null ? void 0 : prev2.node.focus();
          },
          Home: () => {
            const first = descendants.enabledFirstValue();
            first == null ? void 0 : first.node.focus();
          },
          End: () => {
            const last = descendants.enabledLastValue();
            last == null ? void 0 : last.node.focus();
          }
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        action(ev);
      },
      [descendants, i]
    );
    const getLabelProps = (0, import_react78.useCallback)(
      (props2 = {}, ref2 = null) => ({
        id: itemId,
        type: "button",
        "aria-expanded": isOpen,
        "aria-controls": panelId,
        "aria-disabled": ariaAttr(
          !isMultiple && !isToggle && isOpen || isDisabled2
        ),
        ...props2,
        disabled: isDisabled2,
        ref: mergeRefs(register, ref2),
        onClick: handlerAll(props2.onClick, onClick2),
        onFocus: handlerAll(props2.onFocus, onFocus4),
        onKeyDown: handlerAll(props2.onKeyDown, onKeyDown)
      }),
      [
        itemId,
        isOpen,
        panelId,
        isMultiple,
        isToggle,
        isDisabled2,
        register,
        onClick2,
        onFocus4,
        onKeyDown
      ]
    );
    const getPanelProps = (0, import_react78.useCallback)(
      (props2 = {}, ref2 = null) => ({
        id: panelId,
        role: "region",
        "aria-labelledby": itemId,
        ...props2,
        ref: ref2
      }),
      [itemId, panelId]
    );
    const css4 = { ...styles2.item, overflowAnchor: "none" };
    const cloneLabel = typeof label === "function" ? label({
      isExpanded: isOpen,
      isDisabled: isDisabled2
    }) : label;
    if (typeof children === "function")
      children = children({ isExpanded: isOpen, isDisabled: isDisabled2 });
    const validChildren = getValidChildren(children);
    const [customAccordionLabel] = findChildren(validChildren, AccordionLabel);
    const [customAccordionPanel] = findChildren(validChildren, AccordionPanel);
    const cloneChildren = !isEmpty(validChildren) ? omitChildren(validChildren, AccordionLabel, AccordionPanel) : children;
    return (0, import_jsx_runtime44.jsx)(
      AccordionItemProvider,
      {
        value: { isOpen, isDisabled: isDisabled2, icon, getLabelProps, getPanelProps },
        children: (0, import_jsx_runtime44.jsxs)(
          ui.div,
          {
            ref,
            className: cx("ui-accordion__item", className),
            id: id4,
            "data-expanded": dataAttr(isOpen),
            __css: css4,
            ...rest,
            children: [
              customAccordionLabel != null ? customAccordionLabel : (0, import_jsx_runtime44.jsx)(AccordionLabel, { children: cloneLabel }),
              customAccordionPanel != null ? customAccordionPanel : (0, import_jsx_runtime44.jsx)(AccordionPanel, { children: cloneChildren })
            ]
          }
        )
      }
    );
  }
);
var AccordionLabel = forwardRef22(
  ({ className, icon: customIcon, containerProps, children, ...rest }, ref) => {
    var _a;
    const {
      isOpen,
      isDisabled: isDisabled2 = false,
      icon: supplementIcon,
      getLabelProps
    } = useAccordionItemContext();
    const { icon: generalIcon, iconHidden, styles: styles2 } = useAccordionContext();
    const css4 = {
      display: "inline-flex",
      alignItems: "center",
      width: "100%",
      outline: 0,
      ...styles2.button
    };
    const cloneCustomIcon = typeof customIcon === "function" ? customIcon({
      isExpanded: isOpen,
      isDisabled: isDisabled2
    }) : customIcon;
    const cloneSupplementIcon = typeof supplementIcon === "function" ? supplementIcon({
      isExpanded: isOpen,
      isDisabled: isDisabled2
    }) : supplementIcon;
    const cloneGeneralIcon = typeof generalIcon === "function" ? generalIcon({
      isExpanded: isOpen,
      isDisabled: isDisabled2
    }) : generalIcon;
    return (0, import_jsx_runtime45.jsx)(ui.div, { role: "heading", "aria-level": "3", ...containerProps, children: (0, import_jsx_runtime45.jsxs)(
      ui.button,
      {
        ...getLabelProps(rest, ref),
        className: cx("ui-accordion__label", className),
        __css: css4,
        children: [
          children,
          !iconHidden ? (0, import_jsx_runtime45.jsx)(AccordionIcon, { children: (_a = cloneCustomIcon != null ? cloneCustomIcon : cloneSupplementIcon) != null ? _a : cloneGeneralIcon }) : null
        ]
      }
    ) });
  }
);
var AccordionIcon = ({
  className,
  children,
  ...rest
}) => {
  const { isOpen, isDisabled: isDisabled2 } = useAccordionItemContext();
  const { styles: styles2 } = useAccordionContext();
  const css4 = {
    opacity: isDisabled2 ? 0.4 : 1,
    transform: isOpen ? "rotate(-180deg)" : void 0,
    transition: "transform 0.2s",
    transformOrigin: "center",
    ...styles2.icon
  };
  if (children)
    return (0, import_jsx_runtime45.jsx)(
      ui.span,
      {
        className: cx("ui-accordion__icon", className),
        __css: {
          display: "inline-flex",
          justifyContent: "center",
          alignItems: "center",
          ml: "auto"
        },
        children
      }
    );
  return (0, import_jsx_runtime45.jsx)(
    ChevronIcon,
    {
      className: cx("ui-accordion__icon", className),
      __css: css4,
      ...rest
    }
  );
};

// node_modules/@yamada-ui/badge/dist/chunk-URGLF2HC.mjs
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var Badge2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("Badge", props2);
  const { className, ...rest } = omitThemeProps(mergedProps);
  const css4 = {
    display: "inline-block",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    ...styles2
  };
  return (0, import_jsx_runtime46.jsx)(
    ui.span,
    {
      ref,
      className: cx("ui-badge", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/breadcrumb/dist/chunk-OCOIJNO5.mjs
var import_react79 = __toESM(require_react(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var [BreadcrumbProvider, useBreadcrumb] = createContext2({
  name: "BreadcrumbContext",
  errorMessage: `useBreadcrumb returned is 'undefined'. Seems you forgot to wrap the components in "<Breadcrumb />" `
});
var Breadcrumb2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Breadcrumb", props2);
  const {
    className,
    children,
    separator = "/",
    gap = "fallback(2, 0.5rem)",
    listProps,
    items = [],
    startBoundaries: _startBoundaries,
    endBoundaries: _endBoundaries,
    ellipsis,
    ...rest
  } = omitThemeProps(mergedProps);
  let startBoundaries = useValue(_startBoundaries);
  let endBoundaries = useValue(_endBoundaries);
  if (startBoundaries === 0) startBoundaries = 1;
  if (endBoundaries === 0) endBoundaries = 1;
  if (startBoundaries) endBoundaries != null ? endBoundaries : endBoundaries = 1;
  if (endBoundaries) startBoundaries != null ? startBoundaries : startBoundaries = 1;
  const hasBoundaries = isNumber(startBoundaries) && isNumber(endBoundaries);
  const isExceed = hasBoundaries && startBoundaries + endBoundaries < items.length;
  const css4 = {
    display: "flex",
    alignItems: "center",
    ...styles2.container
  };
  const validChildren = getValidChildren(children);
  const hasChildren = validChildren.length;
  const customEllipsis = (0, import_react79.useCallback)(
    (providedItems) => {
      if (!ellipsis) return null;
      const resolvedItems = providedItems != null ? providedItems : items.slice(startBoundaries, items.length - endBoundaries);
      return runIfFunc(ellipsis, { items: resolvedItems });
    },
    [ellipsis, endBoundaries, items, startBoundaries]
  );
  const cloneChildren = (0, import_react79.useMemo)(() => {
    if (hasChildren) {
      return validChildren.map(
        (child, index) => (0, import_react79.cloneElement)(child, {
          separator,
          gap,
          isLastChild: validChildren.length === index + 1
        })
      );
    } else {
      let hiddenEllipsis = [];
      return items.map((item, index) => {
        var _a, _b, _c;
        const { containerProps, name, isCurrentPage, isEllipsisPage, ...rest2 } = item;
        const isLastChild = items.length === index + 1;
        const props22 = {
          separator,
          gap,
          isCurrentPage,
          ...containerProps
        };
        if (!hasBoundaries && isEllipsisPage) {
          hiddenEllipsis.push(item);
          return isLastChild ? (0, import_jsx_runtime47.jsx)(BreadcrumbItem, { ...props22, isLastChild: true, children: (_a = customEllipsis([item])) != null ? _a : (0, import_jsx_runtime47.jsx)(BreadcrumbEllipsis, {}) }, index) : null;
        }
        if (hasBoundaries && isExceed) {
          const lastIndex = items.length - index - 1;
          if (startBoundaries <= index && endBoundaries <= lastIndex) {
            if (startBoundaries === index) {
              return (0, import_jsx_runtime47.jsx)(BreadcrumbItem, { ...props22, children: (_b = customEllipsis()) != null ? _b : (0, import_jsx_runtime47.jsx)(BreadcrumbEllipsis, {}) }, index);
            } else {
              return null;
            }
          }
        }
        if (hiddenEllipsis.length) {
          const resolvedEllipsis = (_c = customEllipsis(hiddenEllipsis)) != null ? _c : (0, import_jsx_runtime47.jsx)(BreadcrumbEllipsis, {});
          hiddenEllipsis = [];
          return (0, import_jsx_runtime47.jsxs)(import_react79.Fragment, { children: [
            (0, import_jsx_runtime47.jsx)(BreadcrumbItem, { ...props22, children: resolvedEllipsis }),
            (0, import_jsx_runtime47.jsx)(BreadcrumbItem, { ...props22, isLastChild, children: (0, import_jsx_runtime47.jsx)(BreadcrumbLink, { ...rest2, children: name }) })
          ] }, index);
        } else {
          return (0, import_jsx_runtime47.jsx)(BreadcrumbItem, { ...props22, isLastChild, children: (0, import_jsx_runtime47.jsx)(BreadcrumbLink, { ...rest2, children: name }) }, index);
        }
      });
    }
  }, [
    hasChildren,
    validChildren,
    separator,
    gap,
    items,
    hasBoundaries,
    isExceed,
    startBoundaries,
    endBoundaries,
    customEllipsis
  ]);
  return (0, import_jsx_runtime47.jsx)(BreadcrumbProvider, { value: styles2, children: (0, import_jsx_runtime47.jsx)(
    ui.nav,
    {
      ref,
      className: cx("ui-breadcrumb", className),
      __css: styles2.container,
      "aria-label": "Breadcrumb",
      ...rest,
      children: (0, import_jsx_runtime47.jsx)(ui.ol, { className: "ui-breadcrumb__list", ...listProps, __css: css4, children: cloneChildren })
    }
  ) });
});
var BreadcrumbItem = forwardRef22(
  ({
    className,
    children,
    separator,
    isCurrentPage,
    isLastChild,
    gap,
    ...rest
  }, ref) => {
    const styles2 = useBreadcrumb();
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map((child) => {
      if (child.type === BreadcrumbLink) {
        return (0, import_react79.cloneElement)(child, {
          isCurrentPage
        });
      }
      if (child.type === BreadcrumbSeparator) {
        return (0, import_react79.cloneElement)(child, {
          gap,
          children: child.props.children || separator
        });
      }
      return child;
    });
    const css4 = {
      display: "inline-flex",
      alignItems: "center",
      ...styles2.item
    };
    return (0, import_jsx_runtime47.jsxs)(
      ui.li,
      {
        ref,
        className: cx("ui-breadcrumb__item", className),
        __css: css4,
        ...rest,
        children: [
          cloneChildren,
          !isLastChild ? (0, import_jsx_runtime47.jsx)(BreadcrumbSeparator, { gap, children: separator }) : null
        ]
      }
    );
  }
);
var BreadcrumbLink = forwardRef22(
  ({ className, children, isCurrentPage, href, ...rest }, ref) => {
    const styles2 = useBreadcrumb();
    return (0, import_jsx_runtime47.jsx)(
      ui.a,
      {
        ref,
        as: !isCurrentPage ? "a" : "span",
        href: !isCurrentPage ? href : void 0,
        "aria-current": isCurrentPage ? "page" : void 0,
        className: cx("ui-breadcrumb__link", className),
        __css: styles2.link,
        ...rest,
        children
      }
    );
  }
);
var BreadcrumbSeparator = forwardRef22(
  ({ children, gap: mx, ...rest }, ref) => {
    const styles2 = useBreadcrumb();
    const css4 = {
      mx,
      ...styles2.separator
    };
    return (0, import_jsx_runtime47.jsx)(
      ui.span,
      {
        ref,
        className: "ui-breadcrumb__item__separator",
        __css: css4,
        ...rest,
        children
      }
    );
  }
);
var BreadcrumbEllipsis = forwardRef22(
  ({ children, className, ...rest }, ref) => {
    const styles2 = useBreadcrumb();
    const css4 = {
      ...styles2.ellipsis
    };
    return children != null ? children : (0, import_jsx_runtime47.jsxs)(
      Icon,
      {
        ref,
        "aria-label": "ellipsis",
        className: cx("ui-breadcrumb__item__ellipsis", className),
        __css: css4,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 36 24",
        stroke: "currentColor",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        ...rest,
        children: [
          (0, import_jsx_runtime47.jsx)("circle", { cx: "10", cy: "12", r: "2", fill: "currentColor" }),
          (0, import_jsx_runtime47.jsx)("circle", { cx: "20", cy: "12", r: "2", fill: "currentColor" }),
          (0, import_jsx_runtime47.jsx)("circle", { cx: "30", cy: "12", r: "2", fill: "currentColor" })
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/button/dist/chunk-QEKFZB7J.mjs
var import_react80 = __toESM(require_react(), 1);
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var [ButtonGroupProvider, useButtonGroup] = createContext2(
  {
    strict: false,
    name: "ButtonGroupContext"
  }
);
var ButtonGroup = forwardRef22(
  ({
    className,
    size,
    variant,
    direction: flexDirection,
    isAttached,
    isDisabled: isDisabled2,
    gap,
    columnGap,
    rowGap,
    ...rest
  }, ref) => {
    const isColumn = flexDirection === "column" || flexDirection === "column-reverse";
    const css4 = {
      display: "inline-flex",
      flexDirection
    };
    const context = (0, import_react80.useMemo)(
      () => ({ size, variant, isDisabled: isDisabled2 }),
      [size, variant, isDisabled2]
    );
    if (isAttached) {
      Object.assign(css4, {
        "> *:first-of-type:not(:last-of-type)": isColumn ? { borderBottomRadius: 0, marginBlockEnd: "-1px" } : { borderRightRadius: 0, marginInlineEnd: "-1px" },
        "> *:not(:first-of-type):not(:last-of-type)": isColumn ? { borderRadius: 0, marginBlockStart: "-1px" } : { borderRadius: 0, marginInlineEnd: "-1px" },
        "> *:not(:first-of-type):last-of-type": isColumn ? { borderTopRadius: 0, marginBlockStart: "-1px" } : { borderLeftRadius: 0 }
      });
    } else {
      Object.assign(css4, {
        gap,
        columnGap,
        rowGap
      });
    }
    return (0, import_jsx_runtime48.jsx)(ButtonGroupProvider, { value: context, children: (0, import_jsx_runtime48.jsx)(
      ui.div,
      {
        ref,
        role: "group",
        className: cx("ui-button-group", className),
        "data-attached": dataAttr(isAttached),
        __css: css4,
        ...rest
      }
    ) });
  }
);

// node_modules/@yamada-ui/button/dist/chunk-DOAXEX55.mjs
var import_react81 = __toESM(require_react(), 1);
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var Button2 = forwardRef22(
  ({ children, __isProcessSkip, __styles, ...props2 }, ref) => {
    const group = useButtonGroup();
    const [styles2, mergedProps] = useComponentStyle(
      "Button",
      {
        ...group,
        ...props2
      },
      { isProcessSkip: __isProcessSkip, styles: __styles }
    );
    const {
      className,
      as,
      type,
      isRounded,
      isLoading,
      isActive,
      isDisabled: isDisabled2 = group == null ? void 0 : group.isDisabled,
      leftIcon,
      rightIcon,
      loadingIcon,
      loadingText,
      loadingPlacement = "start",
      disableRipple,
      __css,
      ...rest
    } = omitThemeProps(mergedProps);
    const trulyDisabled = isDisabled2 || isLoading;
    const { ref: buttonRef, type: defaultType } = useButtonType(as);
    const { onPointerDown, ...rippleProps } = useRipple({
      ...rest,
      isDisabled: disableRipple || trulyDisabled
    });
    const css4 = (0, import_react81.useMemo)(() => {
      var _a;
      const _focus = "_focus" in styles2 ? merge((_a = styles2._focus) != null ? _a : {}, { zIndex: "fallback(yamcha, 1)" }) : {};
      return {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "fallback(2, 0.5rem)",
        appearance: "none",
        userSelect: "none",
        position: "relative",
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        overflow: "hidden",
        outline: "none",
        ...styles2,
        ...__css,
        ...!!group ? { _focus } : {},
        ...isRounded ? { borderRadius: "fallback(full, 9999px)" } : {}
      };
    }, [styles2, __css, group, isRounded]);
    const contentProps = {
      leftIcon,
      rightIcon,
      children
    };
    const loadingProps = {
      loadingIcon,
      loadingText
    };
    return (0, import_jsx_runtime49.jsxs)(
      ui.button,
      {
        ref: mergeRefs(ref, buttonRef),
        as,
        className: cx("ui-button", className),
        type: type != null ? type : defaultType,
        disabled: trulyDisabled,
        "data-active": dataAttr(isActive),
        "data-loading": dataAttr(isLoading),
        __css: css4,
        ...rest,
        onPointerDown,
        children: [
          isLoading && loadingPlacement === "start" ? (0, import_jsx_runtime49.jsx)(Loading3, { className: "ui-button__loading--start", ...loadingProps }) : null,
          isLoading ? loadingText || (0, import_jsx_runtime49.jsx)(ui.span, { opacity: 0, children: (0, import_jsx_runtime49.jsx)(Content, { ...contentProps }) }) : (0, import_jsx_runtime49.jsx)(Content, { ...contentProps }),
          isLoading && loadingPlacement === "end" ? (0, import_jsx_runtime49.jsx)(Loading3, { className: "ui-button__loading--end", ...loadingProps }) : null,
          (0, import_jsx_runtime49.jsx)(Ripple, { isDisabled: disableRipple || trulyDisabled, ...rippleProps })
        ]
      }
    );
  }
);
var Loading3 = ({ className, loadingIcon, loadingText }) => {
  const css4 = (0, import_react81.useMemo)(
    () => ({
      display: "flex",
      alignItems: "center",
      position: loadingText ? "relative" : "absolute",
      fontSize: "1em",
      lineHeight: "normal"
    }),
    [loadingText]
  );
  const element = (0, import_react81.useMemo)(() => {
    if (typeof loadingIcon === "string") {
      return (0, import_jsx_runtime49.jsx)(Loading, { color: "current", variant: loadingIcon });
    } else {
      return loadingIcon || (0, import_jsx_runtime49.jsx)(Loading, { color: "current" });
    }
  }, [loadingIcon]);
  return (0, import_jsx_runtime49.jsx)(ui.div, { className: cx("ui-button__loading", className), __css: css4, children: element });
};
var Content = ({
  leftIcon,
  rightIcon,
  children
}) => {
  return (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [
    leftIcon ? (0, import_jsx_runtime49.jsx)(Icon3, { children: leftIcon }) : null,
    children,
    rightIcon ? (0, import_jsx_runtime49.jsx)(Icon3, { children: rightIcon }) : null
  ] });
};
var Icon3 = ({ children, className, ...rest }) => {
  return (0, import_jsx_runtime49.jsx)(
    ui.span,
    {
      className: cx("ui-button__icon", className),
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      "aria-hidden": true,
      ...rest,
      children
    }
  );
};
var useButtonType = (value) => {
  const isButton = (0, import_react81.useRef)(!value);
  const ref = (0, import_react81.useCallback)((node3) => {
    if (node3) isButton.current = node3.tagName === "BUTTON";
  }, []);
  const type = isButton.current ? "button" : void 0;
  return { ref, type };
};

// node_modules/@yamada-ui/button/dist/chunk-OLTYKY4J.mjs
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var IconButton = forwardRef22(
  ({ icon, children, className, ...rest }, ref) => {
    return (0, import_jsx_runtime50.jsx)(
      Button2,
      {
        className: cx("ui-icon-button", className),
        ref,
        p: 0,
        ...rest,
        children: icon || children
      }
    );
  }
);

// node_modules/@yamada-ui/card/dist/chunk-F3TZ4KBM.mjs
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var [CardProvider, useCard] = createContext2({
  name: `CardContext`,
  errorMessage: `useCard returned is 'undefined'. Seems you forgot to wrap the components in "<Card />" `
});
var Card2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Card", props2);
  const {
    className,
    direction: flexDirection = "column",
    justify: justifyContent,
    align: alignItems,
    ...rest
  } = omitThemeProps(mergedProps);
  const css4 = {
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems,
    wordWrap: "break-word",
    ...styles2.container
  };
  return (0, import_jsx_runtime51.jsx)(CardProvider, { value: styles2, children: (0, import_jsx_runtime51.jsx)(
    ui.article,
    {
      ref,
      className: cx("ui-card", className),
      __css: css4,
      ...rest
    }
  ) });
});
var CardHeader = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useCard();
    const css4 = {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      ...styles2.header
    };
    return (0, import_jsx_runtime51.jsx)(
      ui.header,
      {
        ref,
        className: cx("ui-card__header", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var CardBody = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useCard();
    const css4 = {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      ...styles2.body
    };
    return (0, import_jsx_runtime51.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-card__body", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var CardFooter = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useCard();
    const css4 = {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      ...styles2.footer
    };
    return (0, import_jsx_runtime51.jsx)(
      ui.footer,
      {
        ref,
        className: cx("ui-card__footer", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/form-control/dist/chunk-Q3SAXKY3.mjs
var import_react82 = __toESM(require_react(), 1);
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var [FormControlContextProvider, useFormControlContext] = createContext2({
  strict: false,
  name: "FormControlContext"
});
var [FormControlStylesProvider, useFormControlStyles] = createContext2({
  strict: false,
  name: "FormControlStyleContext"
});
var FormControl2 = forwardRef22(
  ({ id: id4, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("FormControl", props2);
    const {
      className,
      isRequired = false,
      isDisabled: isDisabled2 = false,
      isInvalid = false,
      isReadOnly = false,
      isReplace = true,
      label,
      helperMessage,
      errorMessage,
      children,
      requiredIndicator,
      optionalIndicator,
      labelProps,
      helperMessageProps,
      errorMessageProps,
      ...rest
    } = omitThemeProps(mergedProps);
    id4 != null ? id4 : id4 = (0, import_react82.useId)();
    const labelId = (0, import_react82.useId)();
    const [isFocused, setFocused] = (0, import_react82.useState)(false);
    const validChildren = getValidChildren(children);
    const [customLabel] = findChildren(validChildren, Label);
    const [customHelperMessage] = findChildren(validChildren, HelperMessage);
    const [customErrorMessage] = findChildren(validChildren, ErrorMessage);
    const isCustomLabel = !!customLabel;
    const isCustomHelperMessage = !!customHelperMessage;
    const isCustomErrorMessage = !!customErrorMessage;
    const css4 = { ...styles2.container };
    return (0, import_jsx_runtime52.jsx)(
      FormControlContextProvider,
      {
        value: {
          id: id4,
          labelId,
          isFocused,
          isRequired,
          isDisabled: isDisabled2,
          isInvalid,
          isReadOnly,
          isReplace,
          onFocus: () => setFocused(true),
          onBlur: () => setFocused(false)
        },
        children: (0, import_jsx_runtime52.jsx)(FormControlStylesProvider, { value: styles2, children: (0, import_jsx_runtime52.jsxs)(
          ui.div,
          {
            ref,
            className: cx("ui-form__control", className),
            "data-focus": dataAttr(isFocused),
            "data-disabled": dataAttr(isDisabled2),
            "data-invalid": dataAttr(isInvalid),
            "data-readonly": dataAttr(isReadOnly),
            __css: css4,
            ...rest,
            children: [
              !isCustomLabel && label ? (0, import_jsx_runtime52.jsx)(
                Label,
                {
                  requiredIndicator,
                  optionalIndicator,
                  ...labelProps,
                  children: label
                }
              ) : null,
              children,
              !isCustomHelperMessage && helperMessage ? (0, import_jsx_runtime52.jsx)(HelperMessage, { ...helperMessageProps, children: helperMessage }) : null,
              !isCustomErrorMessage && errorMessage ? (0, import_jsx_runtime52.jsx)(ErrorMessage, { ...errorMessageProps, children: errorMessage }) : null
            ]
          }
        ) })
      }
    );
  }
);
var useFormControl = ({
  id: idProp,
  disabled,
  readOnly,
  required,
  isDisabled: isDisabledProp,
  isReadOnly: isReadOnlyProp,
  isRequired: isRequiredProp,
  isInvalid: isInvalidProp,
  ...rest
}) => {
  var _a, _b, _c;
  const control = useFormControlContext();
  const id4 = idProp != null ? idProp : control == null ? void 0 : control.id;
  const labelId = control == null ? void 0 : control.labelId;
  const isDisabled2 = (_a = disabled != null ? disabled : isDisabledProp) != null ? _a : control == null ? void 0 : control.isDisabled;
  const isReadOnly = (_b = readOnly != null ? readOnly : isReadOnlyProp) != null ? _b : control == null ? void 0 : control.isReadOnly;
  const isRequired = (_c = required != null ? required : isRequiredProp) != null ? _c : control == null ? void 0 : control.isRequired;
  const isInvalid = isInvalidProp != null ? isInvalidProp : control == null ? void 0 : control.isInvalid;
  return {
    id: id4,
    labelId,
    isDisabled: isDisabled2,
    isReadOnly,
    isRequired,
    isInvalid,
    ...rest
  };
};
var useFormControlProps = ({
  id: id4,
  disabled,
  readOnly,
  required,
  isDisabled: isDisabled2,
  isReadOnly,
  isRequired,
  isInvalid,
  onFocus: onFocus4,
  onBlur: onBlur4,
  ...rest
}) => {
  const control = useFormControlContext();
  disabled != null ? disabled : disabled = isDisabled2 != null ? isDisabled2 : control == null ? void 0 : control.isDisabled;
  required != null ? required : required = isRequired != null ? isRequired : control == null ? void 0 : control.isRequired;
  readOnly != null ? readOnly : readOnly = isReadOnly != null ? isReadOnly : control == null ? void 0 : control.isReadOnly;
  isInvalid != null ? isInvalid : isInvalid = control == null ? void 0 : control.isInvalid;
  return {
    id: id4 != null ? id4 : control == null ? void 0 : control.id,
    disabled,
    required,
    readOnly,
    "aria-disabled": ariaAttr(disabled),
    "aria-readonly": ariaAttr(readOnly),
    "aria-required": ariaAttr(required),
    "aria-invalid": ariaAttr(isInvalid),
    "data-readonly": dataAttr(readOnly),
    onFocus: handlerAll(control == null ? void 0 : control.onFocus, onFocus4),
    onBlur: handlerAll(control == null ? void 0 : control.onBlur, onBlur4),
    ...disabled || readOnly ? {
      _hover: {},
      _active: {},
      _focus: {},
      _invalid: {},
      _focusVisible: {}
    } : {},
    ...rest
  };
};
var formControlBaseProperties = [
  "disabled",
  "required",
  "readOnly",
  "aria-disabled",
  "aria-readonly",
  "aria-required",
  "aria-invalid",
  "data-readonly",
  "onFocus",
  "onBlur",
  "_hover",
  "_active",
  "_focus",
  "_invalid",
  "_focusVisible"
];
var formControlProperties = formControlBaseProperties;
var getFormControlProperties = ({
  omit = [],
  pick = []
} = {}) => {
  let result = formControlProperties;
  if (pick.length) {
    result = result.filter((property) => pick.includes(property));
  }
  if (omit.length) {
    result = result.filter((property) => !omit.includes(property));
  }
  return result;
};
var Label = forwardRef22(
  ({
    id: idProp,
    className,
    htmlFor,
    isRequired: isRequiredProp,
    requiredIndicator = null,
    optionalIndicator = null,
    children,
    ...rest
  }, ref) => {
    var _a, _b;
    const {
      id: formControlId,
      labelId,
      isRequired,
      isFocused,
      isDisabled: isDisabled2,
      isInvalid,
      isReadOnly
    } = (_a = useFormControlContext()) != null ? _a : {};
    const styles2 = (_b = useFormControlStyles()) != null ? _b : {};
    idProp != null ? idProp : idProp = labelId;
    isRequiredProp != null ? isRequiredProp : isRequiredProp = isRequired;
    const css4 = {
      display: "block",
      pointerEvents: isReadOnly ? "none" : void 0,
      ...styles2.label
    };
    return (0, import_jsx_runtime52.jsxs)(
      ui.label,
      {
        ref,
        id: idProp,
        className: cx("ui-form__label", className),
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled2),
        "data-readonly": dataAttr(isReadOnly),
        "data-invalid": dataAttr(isInvalid),
        htmlFor: htmlFor != null ? htmlFor : formControlId,
        __css: css4,
        style: { cursor: isDisabled2 ? "not-allowed" : void 0 },
        ...rest,
        children: [
          children,
          isRequiredProp ? requiredIndicator ? (0, import_jsx_runtime52.jsx)(RequiredIndicator, { children: requiredIndicator }) : (0, import_jsx_runtime52.jsx)(RequiredIndicator, {}) : optionalIndicator
        ]
      }
    );
  }
);
var RequiredIndicator = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    var _a;
    const styles2 = (_a = useFormControlStyles()) != null ? _a : {};
    const css4 = { ...styles2.requiredIndicator };
    return !(0, import_react82.isValidElement)(children) ? (0, import_jsx_runtime52.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-form__required-indicator", className),
        role: "presentation",
        "aria-hidden": true,
        __css: css4,
        ...rest,
        children: children != null ? children : (0, import_jsx_runtime52.jsx)(import_jsx_runtime52.Fragment, { children: "*" })
      }
    ) : children;
  }
);
var HelperMessage = forwardRef22(
  ({ className, ...rest }, ref) => {
    var _a, _b;
    const { id: id4, isInvalid, isReplace } = (_a = useFormControlContext()) != null ? _a : {};
    const styles2 = (_b = useFormControlStyles()) != null ? _b : {};
    if (isReplace && isInvalid) return null;
    const css4 = { ...styles2.helperMessage };
    return (0, import_jsx_runtime52.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-form__helper-message", className),
        __css: css4,
        "aria-describedby": id4,
        ...rest
      }
    );
  }
);
var ErrorMessage = forwardRef22(
  ({ className, ...rest }, ref) => {
    var _a, _b;
    const { isInvalid } = (_a = useFormControlContext()) != null ? _a : {};
    const styles2 = (_b = useFormControlStyles()) != null ? _b : {};
    if (!isInvalid) return null;
    const css4 = { ...styles2.errorMessage };
    return (0, import_jsx_runtime52.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-form__error-message", className),
        "aria-live": "polite",
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/visually-hidden/dist/chunk-247CGF3F.mjs
var VisuallyHidden = ui("span", {
  baseStyle: {
    border: "0",
    clip: "rect(0, 0, 0, 0)",
    height: "1px",
    width: "1px",
    margin: "-1px",
    padding: "0",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
  }
});

// node_modules/@yamada-ui/form-control/dist/chunk-NB2N3EAF.mjs
var import_react83 = __toESM(require_react(), 1);
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var Fieldset2 = forwardRef22(
  ({ id: id4, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Fieldset", props2);
    const {
      className,
      isRequired = false,
      isDisabled: isDisabled2 = false,
      isInvalid = false,
      isReadOnly = false,
      isReplace = true,
      legend,
      helperMessage,
      errorMessage,
      children,
      requiredIndicator,
      optionalIndicator,
      legendProps,
      helperMessageProps,
      errorMessageProps,
      ...rest
    } = omitThemeProps(mergedProps);
    id4 != null ? id4 : id4 = (0, import_react83.useId)();
    const [isFocused, setFocused] = (0, import_react83.useState)(false);
    const validChildren = getValidChildren(children);
    const [customLegend] = findChildren(validChildren, Legend);
    const [customHelperMessage] = findChildren(validChildren, HelperMessage);
    const [customErrorMessage] = findChildren(validChildren, ErrorMessage);
    const isCustomLegend = !!customLegend;
    const isCustomHelperMessage = !!customHelperMessage;
    const isCustomErrorMessage = !!customErrorMessage;
    const css4 = { ...styles2.container };
    return (0, import_jsx_runtime53.jsx)(
      FormControlContextProvider,
      {
        value: {
          isFocused,
          isRequired,
          isDisabled: isDisabled2,
          isInvalid,
          isReadOnly,
          isReplace,
          onFocus: () => setFocused(true),
          onBlur: () => setFocused(false)
        },
        children: (0, import_jsx_runtime53.jsx)(FormControlStylesProvider, { value: styles2, children: (0, import_jsx_runtime53.jsxs)(
          ui.fieldset,
          {
            ref,
            className: cx("ui-fieldset", className),
            disabled: isDisabled2,
            "data-focus": dataAttr(isFocused),
            "data-disabled": dataAttr(isDisabled2),
            "data-invalid": dataAttr(isInvalid),
            "data-readonly": dataAttr(isReadOnly),
            __css: css4,
            ...rest,
            children: [
              !isCustomLegend && legend ? (0, import_jsx_runtime53.jsxs)(
                Legend,
                {
                  requiredIndicator,
                  optionalIndicator,
                  ...legendProps,
                  children: [
                    legend,
                    (!isReplace || !isInvalid) && helperMessage ? (0, import_jsx_runtime53.jsx)(VisuallyHidden, { children: helperMessage }) : null,
                    isInvalid && errorMessage ? (0, import_jsx_runtime53.jsx)(VisuallyHidden, { children: errorMessage }) : null
                  ]
                }
              ) : null,
              children,
              !isCustomHelperMessage && helperMessage ? (0, import_jsx_runtime53.jsx)(HelperMessage, { ...helperMessageProps, children: helperMessage }) : null,
              !isCustomErrorMessage && errorMessage ? (0, import_jsx_runtime53.jsx)(ErrorMessage, { ...errorMessageProps, children: errorMessage }) : null
            ]
          }
        ) })
      }
    );
  }
);
var Legend = forwardRef22(
  ({
    className,
    isRequired: isRequiredProp,
    requiredIndicator = null,
    optionalIndicator = null,
    children,
    ...rest
  }, ref) => {
    var _a, _b;
    const { isRequired, isFocused, isDisabled: isDisabled2, isInvalid, isReadOnly } = (_a = useFormControlContext()) != null ? _a : {};
    const styles2 = (_b = useFormControlStyles()) != null ? _b : {};
    isRequiredProp != null ? isRequiredProp : isRequiredProp = isRequired;
    const css4 = { ...styles2.legend };
    return (0, import_jsx_runtime53.jsxs)(
      ui.legend,
      {
        ref,
        className: cx("ui-fieldset__legend", className),
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled2),
        "data-readonly": dataAttr(isReadOnly),
        "data-invalid": dataAttr(isInvalid),
        __css: css4,
        ...rest,
        children: [
          children,
          isRequiredProp ? requiredIndicator ? (0, import_jsx_runtime53.jsx)(RequiredIndicator, { children: requiredIndicator }) : (0, import_jsx_runtime53.jsx)(RequiredIndicator, {}) : optionalIndicator
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/use-focus-visible/dist/index.mjs
var import_react84 = __toESM(require_react(), 1);
var hasSetup = false;
var modality = null;
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var handlers = /* @__PURE__ */ new Set();
var trigger = (modality2, ev) => handlers.forEach((handler) => handler(modality2, ev));
var onValid = (e) => {
  return !(e.metaKey || !isMac && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
};
var onKeyboard = (ev) => {
  hasEventBeforeFocus = true;
  if (onValid(ev)) {
    modality = "keyboard";
    trigger("keyboard", ev);
  }
};
var onPointer = (ev) => {
  modality = "pointer";
  if (ev.type === "mousedown" || ev.type === "pointerdown" || ev.type === "pointerup") {
    hasEventBeforeFocus = true;
    const target = ev.composedPath ? ev.composedPath()[0] : ev.target;
    if (target.matches(":focus-visible")) return;
    trigger("pointer", ev);
  }
};
var isVirtualClick = (ev) => {
  if (ev.mozInputSource === 0 && ev.isTrusted) return true;
  return ev.detail === 0 && !ev.pointerType;
};
var onClick = (ev) => {
  if (!isVirtualClick(ev)) return;
  hasEventBeforeFocus = true;
  modality = "virtual";
};
var onFocus = (ev) => {
  if (ev.target === window || ev.target === document) return;
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    modality = "virtual";
    trigger("virtual", ev);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
};
var onBlur = () => {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
};
var isFocusVisible = () => modality !== "pointer";
var setGlobalFocusEvents = () => {
  if (typeof window === "undefined" || hasSetup) return;
  const { focus } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function customFocus(...args) {
    hasEventBeforeFocus = true;
    if (this) focus.apply(this, args);
  };
  document.addEventListener("keydown", onKeyboard, true);
  document.addEventListener("keyup", onKeyboard, true);
  document.addEventListener("click", onClick, true);
  window.addEventListener("focus", onFocus, true);
  window.addEventListener("blur", onBlur, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", onPointer, true);
    document.addEventListener("pointermove", onPointer, true);
    document.addEventListener("pointerup", onPointer, true);
  } else {
    document.addEventListener("mousedown", onPointer, true);
    document.addEventListener("mousemove", onPointer, true);
    document.addEventListener("mouseup", onPointer, true);
  }
  hasSetup = true;
};
var trackFocusVisible = (func2, { force } = {}) => {
  if (force) hasSetup = false;
  setGlobalFocusEvents();
  func2(isFocusVisible());
  const handler = () => func2(isFocusVisible());
  handlers.add(handler);
  return () => {
    handlers.delete(handler);
  };
};
var useFocusVisible = (options) => {
  const [focusVisible, setFocusVisible] = (0, import_react84.useState)(false);
  const [focus, setFocus] = (0, import_react84.useState)(false);
  (0, import_react84.useEffect)(() => {
    return trackFocusVisible(setFocusVisible, options);
  }, [options]);
  return {
    focusVisible: focusVisible && focus,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false)
  };
};

// node_modules/@yamada-ui/checkbox/dist/chunk-IZQAQAZP.mjs
var import_react89 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/layouts/dist/chunk-3UF3MSZ3.mjs
var Spacer = ui("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});

// node_modules/@yamada-ui/layouts/dist/chunk-OVVZFMIQ.mjs
var import_react85 = __toESM(require_react(), 1);
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var Stack = forwardRef22(
  ({
    direction: flexDirection = "column",
    justify: justifyContent,
    align: alignItems,
    wrap: flexWrap,
    gap = "fallback(md, 1rem)",
    divider,
    className,
    children,
    ...rest
  }, ref) => {
    const isColumn = (value) => value === "column" || value === "column-reverse";
    const dividerCSS = (0, import_react85.useMemo)(
      () => ({
        w: replaceObject(
          flexDirection,
          (value) => isColumn(value) ? "100%" : "fit-content"
        ),
        h: replaceObject(
          flexDirection,
          (value) => isColumn(value) ? "fit-content" : "100%"
        ),
        borderLeftWidth: replaceObject(
          flexDirection,
          (value) => isColumn(value) ? 0 : "1px"
        ),
        borderBottomWidth: replaceObject(
          flexDirection,
          (value) => isColumn(value) ? "1px" : 0
        )
      }),
      [flexDirection]
    );
    const validChildren = getValidChildren(children);
    const cloneChildren = divider ? validChildren.map((child, index) => {
      const key = typeof child.key !== "undefined" ? child.key : index;
      const cloneDivider = (0, import_react85.cloneElement)(
        divider,
        {
          __css: dividerCSS
        }
      );
      return (0, import_jsx_runtime54.jsxs)(import_react85.Fragment, { children: [
        !!index ? cloneDivider : null,
        child
      ] }, key);
    }) : validChildren;
    const css4 = (0, import_react85.useMemo)(
      () => ({
        display: "flex",
        flexDirection,
        justifyContent,
        alignItems,
        flexWrap,
        gap
      }),
      [alignItems, flexDirection, flexWrap, gap, justifyContent]
    );
    return (0, import_jsx_runtime54.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-stack", className),
        __css: css4,
        ...rest,
        children: cloneChildren
      }
    );
  }
);
var HStack = forwardRef22(
  ({ className, ...rest }, ref) => (0, import_jsx_runtime54.jsx)(
    Stack,
    {
      ref,
      className: cx("ui-stack--horizontal", className),
      direction: "row",
      align: "center",
      ...rest
    }
  )
);
var VStack = forwardRef22(
  ({ className, ...rest }, ref) => (0, import_jsx_runtime54.jsx)(
    Stack,
    {
      ref,
      className: cx("ui-stack--vertical", className),
      direction: "column",
      align: "stretch",
      w: "100%",
      ...rest
    }
  )
);
var ZStack = forwardRef22(
  ({
    className,
    direction = "bottom",
    startIndex = 0,
    gap = "fallback(md, 1rem)",
    reverse = false,
    fit = true,
    children,
    ...rest
  }, ref) => {
    const refMap = (0, import_react85.useRef)(/* @__PURE__ */ new Map());
    const [rect, setRect] = (0, import_react85.useState)({
      width: 0,
      height: 0
    });
    const boxSize = {
      minWidth: `${rect.width}px`,
      minHeight: `${rect.height}px`
    };
    const css4 = {
      position: "relative",
      overflow: "hidden",
      var: [{ name: "space", token: "spaces", value: gap }],
      ...fit ? boxSize : {}
    };
    const vertical = (0, import_react85.useCallback)(
      (space) => {
        if (direction.includes("top")) {
          return { [!reverse ? "bottom" : "top"]: space };
        } else if (direction.includes("bottom")) {
          return { [!reverse ? "top" : "bottom"]: space };
        } else {
          return { [!reverse ? "top" : "bottom"]: 0 };
        }
      },
      [direction, reverse]
    );
    const horizontal = (0, import_react85.useCallback)(
      (space) => {
        if (direction.includes("left")) {
          return { [!reverse ? "right" : "left"]: space };
        } else if (direction.includes("right")) {
          return { [!reverse ? "left" : "right"]: space };
        } else {
          return { [!reverse ? "left" : "right"]: 0 };
        }
      },
      [direction, reverse]
    );
    const cloneChildren = (0, import_react85.useMemo)(() => {
      const validChildren = getValidChildren(children);
      const clonedChildren = validChildren.map((child, index) => {
        var _a;
        const ref2 = (0, import_react85.createRef)();
        refMap.current.set(index, ref2);
        const key = (_a = child.key) != null ? _a : index;
        const zIndex = startIndex + index;
        const space = `calc($space * ${index})`;
        let css22 = {};
        css22 = {
          ...css22,
          position: "absolute",
          zIndex
        };
        css22 = { ...css22, ...vertical(space) };
        css22 = { ...css22, ...horizontal(space) };
        const props2 = {
          ...child.props,
          ref: mergeRefs(child.ref, ref2),
          __css: css22
        };
        const clonedChild = (0, import_react85.cloneElement)(child, props2);
        return (0, import_jsx_runtime54.jsx)(import_react85.Fragment, { children: clonedChild }, key);
      });
      return clonedChildren;
    }, [children, startIndex, vertical, horizontal]);
    (0, import_react85.useEffect)(() => {
      var _a, _b;
      if (!fit) return;
      let isNegativeLeft = direction.includes("left");
      let isNegativeTop = direction.includes("top");
      let width = 0;
      let height = 0;
      if (reverse) {
        isNegativeLeft = !isNegativeLeft;
        isNegativeTop = !isNegativeTop;
      }
      for (const ref2 of refMap.current.values()) {
        if (!ref2.current) continue;
        let { offsetParent, offsetWidth, offsetHeight, offsetTop, offsetLeft } = ref2.current;
        if (!offsetParent && true) continue;
        if (isNegativeLeft) {
          const offsetParentWidth = (_a = offsetParent == null ? void 0 : offsetParent.offsetWidth) != null ? _a : 0;
          offsetLeft = offsetParentWidth - offsetLeft - offsetWidth;
        }
        if (isNegativeTop) {
          const offsetParentHeight = (_b = offsetParent == null ? void 0 : offsetParent.offsetHeight) != null ? _b : 0;
          offsetTop = offsetParentHeight - offsetTop - offsetHeight;
        }
        offsetWidth += offsetLeft;
        offsetHeight += offsetTop;
        if (offsetWidth > width) width = offsetWidth;
        if (offsetHeight > height) height = offsetHeight;
      }
      setRect({ width, height });
    }, [cloneChildren, direction, reverse, fit]);
    return (0, import_jsx_runtime54.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-stack--depth", className),
        __css: css4,
        ...rest,
        children: cloneChildren
      }
    );
  }
);

// node_modules/@yamada-ui/layouts/dist/chunk-XKPB42SF.mjs
var import_react86 = __toESM(require_react(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var AspectRatio = forwardRef22(
  ({ className, ratio = 4 / 3, children, ...rest }, ref) => {
    const child = import_react86.Children.only(children);
    const css4 = {
      position: "relative",
      _before: {
        content: `""`,
        display: "block",
        h: 0,
        pb: replaceObject(ratio, (r2) => `${1 / r2 * 100}%`)
      },
      "& > *:not(style)": {
        overflow: "hidden",
        position: "absolute",
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        w: "100%",
        h: "100%"
      },
      "& > img, & > video": {
        objectFit: "cover"
      }
    };
    return (0, import_jsx_runtime55.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-aspect-ratio", className),
        __css: css4,
        ...rest,
        children: child
      }
    );
  }
);

// node_modules/@yamada-ui/layouts/dist/chunk-PPDZIDUX.mjs
var Box = ui("div");

// node_modules/@yamada-ui/layouts/dist/chunk-FVTNUHXG.mjs
var Center = ui("div", {
  baseStyle: {
    justifyContent: "center",
    display: "flex",
    alignItems: "center"
  }
});

// node_modules/@yamada-ui/layouts/dist/chunk-FWOFB3QN.mjs
var import_react87 = __toESM(require_react(), 1);
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var Container2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("Container", props2);
  const { className, centerContent, ...rest } = omitThemeProps(mergedProps);
  const css4 = (0, import_react87.useMemo)(
    () => ({
      alignItems: centerContent ? "center" : void 0,
      ...styles2
    }),
    [centerContent, styles2]
  );
  return (0, import_jsx_runtime56.jsx)(
    ui.section,
    {
      ref,
      className: cx("ui-container", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/layouts/dist/chunk-VB6N7ESX.mjs
var import_react88 = __toESM(require_react(), 1);
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var Divider2 = forwardRef22((props2, ref) => {
  const [
    {
      borderRightWidth,
      borderLeftWidth,
      borderTopWidth,
      borderBottomWidth,
      borderWidth,
      borderStyle,
      borderColor,
      ...styles2
    },
    mergedProps
  ] = useComponentStyle("Divider", props2);
  const {
    className,
    orientation = "horizontal",
    __css,
    ...rest
  } = omitThemeProps(mergedProps);
  const customStyles = (0, import_react88.useMemo)(
    () => ({
      vertical: {
        border: "0",
        borderStyle,
        borderColor,
        borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
        height: "100%"
      },
      horizontal: {
        border: "0",
        borderStyle,
        borderColor,
        borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
        width: "100%"
      }
    }),
    [
      borderBottomWidth,
      borderColor,
      borderLeftWidth,
      borderRightWidth,
      borderStyle,
      borderTopWidth,
      borderWidth
    ]
  );
  const dividerStyles = (0, import_react88.useMemo)(
    () => customStyles[orientation],
    [customStyles, orientation]
  );
  const css4 = {
    ...styles2,
    ...dividerStyles,
    ...__css
  };
  return (0, import_jsx_runtime57.jsx)(
    ui.hr,
    {
      ref,
      className: cx("ui-divider", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/layouts/dist/chunk-I7F4GS4Y.mjs
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var Flex = forwardRef22(
  ({
    direction: flexDirection,
    justify: justifyContent,
    align: alignItems,
    wrap: flexWrap,
    basis: flexBasis,
    grow: flexGrow,
    shrink: flexShrink,
    ...rest
  }, ref) => {
    const css4 = {
      display: "flex",
      flexDirection,
      justifyContent,
      alignItems,
      flexWrap,
      flexBasis,
      flexGrow,
      flexShrink
    };
    return (0, import_jsx_runtime58.jsx)(ui.div, { ref, __css: css4, ...rest });
  }
);
var Wrap = forwardRef22((props2, ref) => (0, import_jsx_runtime58.jsx)(Flex, { ref, wrap: "wrap", ...props2 }));

// node_modules/@yamada-ui/layouts/dist/chunk-KHNWTOIQ.mjs
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var Grid2 = forwardRef22(
  ({
    templateColumns: gridTemplateColumns,
    templateRows: gridTemplateRows,
    templateAreas: gridTemplateAreas,
    column: gridColumn,
    row: gridRow,
    area: gridArea,
    gap,
    rowGap,
    columnGap,
    autoFlow: gridAutoFlow,
    autoColumns: gridAutoColumns,
    autoRows: gridAutoRows,
    ...rest
  }, ref) => {
    const css4 = {
      display: "grid",
      gridTemplateColumns,
      gridTemplateRows,
      gridTemplateAreas,
      gridColumn,
      gridRow,
      gridArea,
      gap,
      rowGap,
      columnGap,
      gridAutoFlow,
      gridAutoColumns,
      gridAutoRows
    };
    return (0, import_jsx_runtime59.jsx)(ui.div, { ref, __css: css4, ...rest });
  }
);
var transformColumns = (columns, minWidth) => (theme) => {
  if (minWidth) {
    return replaceObject(minWidth, (value) => {
      value = getMemoizedObject(theme, `sizes.${value}`, transforms.px(value));
      return value != null ? `repeat(auto-fit, minmax(${value}, 1fr))` : void 0;
    });
  } else {
    return replaceObject(
      columns,
      (value) => value != null ? `repeat(${value}, minmax(0, 1fr))` : void 0
    );
  }
};
var SimpleGrid = forwardRef22(
  ({ minChildWidth, columns, ...rest }, ref) => {
    const { theme } = useTheme2();
    const templateColumns = transformColumns(columns, minChildWidth)(theme);
    return (0, import_jsx_runtime59.jsx)(Grid2, { ref, templateColumns, ...rest });
  }
);
var GridItem = forwardRef22(
  ({
    area: gridArea,
    colSpan,
    rowSpan,
    colStart: gridColumnStart,
    colEnd: gridColumnEnd,
    rowStart: gridRowStart,
    rowEnd: gridRowEnd,
    ...rest
  }, ref) => {
    const css4 = {
      gridColumn: replaceObject(
        colSpan,
        (value) => value != null ? `span ${value}/span ${value}` : void 0
      ),
      gridRow: replaceObject(
        rowSpan,
        (value) => value != null ? `span ${value}/span ${value}` : void 0
      ),
      gridColumnStart,
      gridColumnEnd,
      gridRowStart,
      gridRowEnd,
      gridArea
    };
    return (0, import_jsx_runtime59.jsx)(ui.div, { ref, __css: css4, ...rest });
  }
);

// node_modules/@yamada-ui/checkbox/dist/chunk-IZQAQAZP.mjs
var import_react90 = __toESM(require_react(), 1);
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var isEvent = (value) => value && isObject(value) && isObject(value.target);
var useCheckboxGroup = ({
  value: valueProp,
  defaultValue = [],
  onChange: onChangeProp,
  isNative,
  ...props2
}) => {
  const onChangeRef = useCallbackRef(onChangeProp);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeRef
  });
  const onChange = (0, import_react90.useCallback)(
    (evOrValue) => {
      const isChecked = isEvent(evOrValue) ? evOrValue.target.checked : !value.includes(evOrValue);
      const selectedValue = isEvent(evOrValue) ? evOrValue.target.value : evOrValue;
      const nextValue = isChecked ? [...value, selectedValue] : value.filter((v) => String(v) !== String(selectedValue));
      setValue(nextValue);
    },
    [value, setValue]
  );
  const getContainerProps = (0, import_react90.useCallback)(
    (props22 = {}, ref = null) => ({
      role: "group",
      ...props22,
      ref
    }),
    []
  );
  const getCheckboxProps = (0, import_react90.useCallback)(
    (props22, ref = null) => ({
      ...props22,
      ref,
      [isNative ? "checked" : "isChecked"]: value.some(
        (val) => String(props22 == null ? void 0 : props22.value) === String(val)
      ),
      onChange
    }),
    [onChange, isNative, value]
  );
  return {
    props: props2,
    value,
    setValue,
    onChange,
    getContainerProps,
    getCheckboxProps
  };
};
var [CheckboxGroupProvider, useCheckboxGroupContext] = createContext2({
  strict: false,
  name: "CheckboxGroupContext"
});
var CheckboxGroup = (0, import_react90.forwardRef)(
  ({
    className,
    size,
    variant,
    colorScheme,
    children,
    items = [],
    direction = "column",
    gap,
    ...props2
  }, ref) => {
    const {
      value,
      onChange,
      props: computedProps,
      getContainerProps
    } = useCheckboxGroup(props2);
    const { labelId, isRequired, isReadOnly, isDisabled: isDisabled2, isInvalid, ...rest } = useFormControl(computedProps);
    const validChildren = getValidChildren(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props22 }, i) => (0, import_jsx_runtime60.jsx)(Checkbox2, { value: value2, ...props22, children: label }, i));
    }
    return (0, import_jsx_runtime60.jsx)(
      CheckboxGroupProvider,
      {
        value: {
          size,
          variant,
          colorScheme,
          isRequired,
          isReadOnly,
          isDisabled: isDisabled2,
          isInvalid,
          value,
          onChange
        },
        children: (0, import_jsx_runtime60.jsx)(
          Flex,
          {
            ref,
            className: cx("ui-checkbox-group", className),
            direction,
            gap: gap != null ? gap : direction === "row" ? "1rem" : void 0,
            ...getContainerProps({
              "aria-labelledby": labelId,
              ...rest
            }),
            children: children != null ? children : computedChildren
          }
        )
      }
    );
  }
);
CheckboxGroup.displayName = "CheckboxGroup";
var useCheckbox = ({
  id: id4,
  ...props2
}) => {
  id4 != null ? id4 : id4 = (0, import_react89.useId)();
  const {
    id: _id,
    name,
    value,
    isChecked: isCheckedProp,
    defaultIsChecked,
    tabIndex,
    required,
    disabled,
    readOnly,
    isIndeterminate,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    ...computedProps
  } = useFormControlProps({ id: id4, ...props2 });
  const [{ "aria-readonly": _ariaReadonly, ...formControlProps }, rest] = splitObject(computedProps, formControlProperties);
  const [isFocusVisible2, setIsFocusVisible] = (0, import_react89.useState)(false);
  const [isFocused, setFocused] = (0, import_react89.useState)(false);
  const [isHovered, setHovered] = (0, import_react89.useState)(false);
  const [isActive, setActive] = (0, import_react89.useState)(false);
  const inputRef = (0, import_react89.useRef)(null);
  const [isLabel, setIsLabel] = (0, import_react89.useState)(true);
  const [isChecked, setIsChecked] = (0, import_react89.useState)(!!defaultIsChecked);
  const isControlled = isCheckedProp !== void 0;
  const checked = isControlled ? isCheckedProp : isChecked;
  const onChange = useCallbackRef(
    (ev) => {
      if (readOnly || disabled) {
        ev.preventDefault();
        return;
      }
      if (!isControlled)
        setIsChecked(!checked || isIndeterminate ? true : ev.target.checked);
      onChangeProp == null ? void 0 : onChangeProp(ev);
    },
    [readOnly, disabled, isControlled, checked, isIndeterminate]
  );
  const onFocus4 = useCallbackRef(onFocusProp);
  const onBlur4 = useCallbackRef(onBlurProp);
  const onKeyDown = (0, import_react89.useCallback)(
    ({ key }) => {
      if (key === " ") setActive(true);
    },
    [setActive]
  );
  const onKeyUp = (0, import_react89.useCallback)(
    ({ key }) => {
      if (key === " ") setActive(false);
    },
    [setActive]
  );
  (0, import_react89.useEffect)(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  useSafeLayoutEffect(() => {
    if (inputRef.current)
      inputRef.current.indeterminate = Boolean(isIndeterminate);
  }, [isIndeterminate]);
  useUpdateEffect(() => {
    if (disabled) setFocused(false);
  }, [disabled, setFocused]);
  useSafeLayoutEffect(() => {
    var _a;
    if (!((_a = inputRef.current) == null ? void 0 : _a.form)) return;
    inputRef.current.form.onreset = () => setIsChecked(!!defaultIsChecked);
  }, []);
  useSafeLayoutEffect(() => {
    if (!inputRef.current) return;
    if (inputRef.current.checked !== checked)
      setIsChecked(inputRef.current.checked);
  }, [inputRef.current]);
  const getContainerProps = (0, import_react89.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(ref, (el) => {
        if (el) setIsLabel(el.tagName === "LABEL");
      }),
      "data-checked": dataAttr(checked),
      onClick: handlerAll(props22.onClick, () => {
        var _a;
        if (isLabel) return;
        (_a = inputRef.current) == null ? void 0 : _a.click();
        requestAnimationFrame(() => {
          var _a2;
          return (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
        });
      })
    }),
    [checked, isLabel, formControlProps]
  );
  const getIconProps = (0, import_react89.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(checked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible2),
      "data-indeterminate": dataAttr(isIndeterminate),
      "aria-hidden": true,
      onMouseDown: handlerAll(props22.onMouseDown, (ev) => {
        if (isFocused) ev.preventDefault();
        setActive(true);
      }),
      onMouseUp: handlerAll(props22.onMouseUp, () => setActive(false)),
      onMouseEnter: handlerAll(props22.onMouseEnter, () => setHovered(true)),
      onMouseLeave: handlerAll(props22.onMouseLeave, () => setHovered(false))
    }),
    [
      isActive,
      checked,
      isFocused,
      isHovered,
      isFocusVisible2,
      isIndeterminate,
      formControlProps
    ]
  );
  const getInputProps = (0, import_react89.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(inputRef, ref),
      id: id4,
      type: "checkbox",
      name,
      value,
      tabIndex,
      required,
      disabled,
      readOnly,
      checked,
      "aria-checked": isIndeterminate ? "mixed" : checked,
      style: {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      },
      onChange: handlerAll(props22.onChange, onChange),
      onBlur: handlerAll(props22.onBlur, onBlur4, () => setFocused(false)),
      onFocus: handlerAll(props22.onFocus, onFocus4, () => setFocused(true)),
      onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
      onKeyUp: handlerAll(props22.onKeyUp, onKeyUp)
    }),
    [
      isIndeterminate,
      formControlProps,
      id4,
      name,
      value,
      tabIndex,
      required,
      disabled,
      readOnly,
      checked,
      onChange,
      onBlur4,
      onFocus4,
      onKeyDown,
      onKeyUp
    ]
  );
  const getLabelProps = (0, import_react89.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      "data-checked": dataAttr(checked),
      onMouseDown: handlerAll(props22.onMouseDown, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      onTouchStart: handlerAll(props22.onTouchStart, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      })
    }),
    [checked, formControlProps]
  );
  return {
    props: rest,
    isFocusVisible: isFocusVisible2,
    isFocused,
    isHovered,
    isActive,
    isChecked: checked,
    isIndeterminate,
    getContainerProps,
    getIconProps,
    getInputProps,
    getLabelProps
  };
};
var Checkbox2 = (0, import_react89.forwardRef)(
  (props2, ref) => {
    var _a, _b, _c, _d;
    const group = useCheckboxGroupContext();
    const { value: groupValue, ...groupProps } = { ...group };
    const control = useFormControl(props2);
    const [styles2, mergedProps] = useMultiComponentStyle("Checkbox", {
      ...groupProps,
      ...props2
    });
    const {
      className,
      gap = "0.5rem",
      isRequired = (_a = groupProps.isRequired) != null ? _a : control.isRequired,
      isReadOnly = (_b = groupProps.isReadOnly) != null ? _b : control.isReadOnly,
      isDisabled: isDisabled2 = (_c = groupProps.isDisabled) != null ? _c : control.isDisabled,
      isInvalid = (_d = groupProps.isInvalid) != null ? _d : control.isInvalid,
      iconProps,
      inputProps,
      labelProps,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const isCheckedProp = groupValue && computedProps.value ? groupValue.includes(computedProps.value) : computedProps.isChecked;
    const onChange = groupProps.onChange && computedProps.value ? funcAll(groupProps.onChange, computedProps.onChange) : computedProps.onChange;
    const {
      isChecked,
      isIndeterminate,
      getContainerProps,
      getInputProps,
      getIconProps,
      getLabelProps,
      props: rest
    } = useCheckbox({
      ...computedProps,
      isRequired,
      isReadOnly,
      isDisabled: isDisabled2,
      isInvalid,
      isChecked: isCheckedProp,
      onChange
    });
    const { children: customIcon, ...resolvedIconProps } = { ...iconProps };
    const cloneIcon = (0, import_react89.cloneElement)(customIcon != null ? customIcon : (0, import_jsx_runtime61.jsx)(CheckboxIcon, {}), {
      __css: {
        opacity: isChecked || isIndeterminate ? 1 : 0,
        transform: isChecked || isIndeterminate ? "scale(1)" : "scale(0.95)",
        transitionProperty: "transform",
        transitionDuration: "normal"
      },
      isIndeterminate,
      isChecked,
      isRequired,
      isReadOnly,
      isDisabled: isDisabled2,
      isInvalid
    });
    return (0, import_jsx_runtime61.jsxs)(
      ui.label,
      {
        className: cx("ui-checkbox", className),
        ...getContainerProps(),
        __css: {
          cursor: "pointer",
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          verticalAlign: "top",
          gap,
          ...styles2.container
        },
        ...rest,
        children: [
          (0, import_jsx_runtime61.jsx)(
            ui.input,
            {
              className: "ui-checkbox__input",
              ...getInputProps(inputProps, ref)
            }
          ),
          (0, import_jsx_runtime61.jsx)(
            ui.span,
            {
              className: "ui-checkbox__icon",
              __css: {
                pointerEvents: isReadOnly ? "none" : void 0,
                position: "relative",
                display: "inline-block",
                userSelect: "none",
                ...styles2.icon
              },
              ...getIconProps(resolvedIconProps),
              children: cloneIcon
            }
          ),
          (0, import_jsx_runtime61.jsx)(
            ui.span,
            {
              className: "ui-checkbox__label",
              __css: { ...styles2.label },
              ...getLabelProps(labelProps),
              children
            }
          )
        ]
      }
    );
  }
);
Checkbox2.displayName = "Checkbox";
var CheckboxIcon = ({
  isIndeterminate,
  isChecked,
  isRequired: _isRequired,
  isReadOnly: _isReadOnly,
  isDisabled: _isDisabled,
  isInvalid: _isInvalid,
  ...rest
}) => {
  return (0, import_jsx_runtime61.jsx)(AnimatePresence, { initial: false, children: isIndeterminate || isChecked ? (0, import_jsx_runtime61.jsx)(
    ui.div,
    {
      __css: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)"
      },
      children: (0, import_jsx_runtime61.jsx)(
        ui.div,
        {
          as: motion.div,
          variants: {
            unchecked: { scale: 0.5 },
            checked: { scale: 1 }
          },
          initial: "unchecked",
          animate: "checked",
          exit: "unchecked",
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          children: isIndeterminate ? (0, import_jsx_runtime61.jsx)(IndeterminateIcon, { ...rest }) : (0, import_jsx_runtime61.jsx)(CheckIcon2, { ...rest })
        }
      )
    }
  ) : null });
};
var CheckIcon2 = (props2) => {
  return (0, import_jsx_runtime61.jsx)(
    ui.svg,
    {
      as: motion.svg,
      width: "1.2em",
      viewBox: "0 0 12 10",
      variants: {
        unchecked: {
          opacity: 0,
          strokeDashoffset: 16
        },
        checked: {
          opacity: 1,
          strokeDashoffset: 0,
          transition: { duration: 0.2 }
        }
      },
      style: {
        fill: "none",
        strokeWidth: 2,
        stroke: "currentColor",
        strokeDasharray: 16
      },
      ...props2,
      children: (0, import_jsx_runtime61.jsx)("polyline", { points: "1.5 6 4.5 9 10.5 1" })
    }
  );
};
var IndeterminateIcon = (props2) => {
  return (0, import_jsx_runtime61.jsx)(
    ui.svg,
    {
      as: motion.svg,
      width: "1.2em",
      viewBox: "0 0 24 24",
      variants: {
        unchecked: {
          scaleX: 0.65,
          opacity: 0
        },
        checked: {
          scaleX: 1,
          opacity: 1,
          transition: {
            scaleX: { duration: 0 },
            opacity: { duration: 0.02 }
          }
        }
      },
      style: { stroke: "currentColor", strokeWidth: 4 },
      ...props2,
      children: (0, import_jsx_runtime61.jsx)("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
    }
  );
};

// node_modules/@yamada-ui/use-event-listener/dist/index.mjs
var import_react91 = __toESM(require_react(), 1);
var useEventListener = (target, event, handler, options) => {
  const listener = useCallbackRef(handler);
  (0, import_react91.useEffect)(() => {
    const el = typeof target === "function" ? target() : target != null ? target : document;
    if (!handler || !el) return;
    el.addEventListener(
      event,
      listener,
      options
    );
    return () => {
      el.removeEventListener(
        event,
        listener,
        options
      );
    };
  }, [event, target, options, listener, handler]);
  return () => {
    const el = typeof target === "function" ? target() : target != null ? target : document;
    el == null ? void 0 : el.removeEventListener(
      event,
      listener,
      options
    );
  };
};
var useEventListeners = () => {
  const listeners = (0, import_react91.useRef)(/* @__PURE__ */ new Map());
  const currentListeners = listeners.current;
  const add2 = (0, import_react91.useCallback)(
    (el, event, listener, options) => {
      listeners.current.set(listener, { event, el, options });
      el.addEventListener(
        event,
        listener,
        options
      );
    },
    []
  );
  const remove = (0, import_react91.useCallback)(
    (el, event, listener, options) => {
      el.removeEventListener(
        event,
        listener,
        options
      );
      listeners.current.delete(listener);
    },
    []
  );
  (0, import_react91.useEffect)(
    () => () => {
      currentListeners.forEach(
        ({ el, event, options }, key) => remove(el, event, key, options)
      );
    },
    [remove, currentListeners]
  );
  return { add: add2, remove };
};

// node_modules/@yamada-ui/use-focus/dist/index.mjs
var import_react92 = __toESM(require_react(), 1);
var preventReturnFocus = (containerRef) => {
  const el = containerRef.current;
  if (!el) return false;
  const activeElement = getActiveElement(el);
  if (!activeElement) return false;
  if (el.contains(activeElement)) return false;
  if (isTabbable(activeElement)) return true;
  return false;
};
var useFocusOnHide = (containerRef, { shouldFocus: shouldFocusProp, visible, focusRef }) => {
  const shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(() => {
    if (!shouldFocus) return;
    if (preventReturnFocus(containerRef)) return;
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    if (el) {
      requestAnimationFrame(() => {
        el.focus();
      });
    }
  }, [shouldFocus, containerRef, focusRef]);
};
var useFocusOnShow = (target, { focusRef, preventScroll, shouldFocus, visible } = {
  preventScroll: true,
  shouldFocus: false
}) => {
  const element = isRefObject(target) ? target.current : target;
  const autoFocusValue = shouldFocus && visible;
  const autoFocusRef = (0, import_react92.useRef)(autoFocusValue);
  const lastVisibleRef = (0, import_react92.useRef)(visible);
  useSafeLayoutEffect(() => {
    if (!lastVisibleRef.current && visible)
      autoFocusRef.current = autoFocusValue;
    lastVisibleRef.current = visible;
  }, [visible, autoFocusValue]);
  const onFocus4 = (0, import_react92.useCallback)(() => {
    if (!visible || !element || !autoFocusRef.current) return;
    autoFocusRef.current = false;
    if (element.contains(document.activeElement)) return;
    if (focusRef == null ? void 0 : focusRef.current) {
      requestAnimationFrame(() => {
        var _a;
        (_a = focusRef.current) == null ? void 0 : _a.focus({ preventScroll });
      });
    } else {
      const tabbableEls = getAllFocusable(element);
      if (tabbableEls.length > 0)
        requestAnimationFrame(() => {
          tabbableEls[0].focus({ preventScroll });
        });
    }
  }, [visible, preventScroll, element, focusRef]);
  useUpdateEffect(() => {
    requestAnimationFrame(() => {
      onFocus4();
    });
  }, [onFocus4]);
  useEventListener(element, "transitionend", onFocus4);
};
var useFocusOnPointerDown = ({
  ref,
  elements,
  enabled: enabled2
}) => {
  const doc = () => {
    var _a, _b;
    return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
  };
  useEventListener(doc, "pointerdown", (ev) => {
    if (!isSafari() || !enabled2) return;
    const target = ev.target;
    const els = elements != null ? elements : [ref];
    const isValidTarget = els.some((elementOrRef) => {
      const el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;
      return (el == null ? void 0 : el.contains(target)) || el === target;
    });
    if (doc().activeElement !== target && isValidTarget) {
      ev.preventDefault();
      target.focus();
    }
  });
};

// node_modules/@yamada-ui/editable/dist/chunk-4PJUEIBU.mjs
var import_react93 = __toESM(require_react(), 1);
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var useEditable = (props2) => {
  const {
    id: id4,
    placeholder,
    value: valueProp,
    onChange: onChangeProp,
    onCancel: onCancelProp,
    onSubmit: onSubmitProp,
    onEdit: onEditProp,
    defaultValue,
    required,
    disabled,
    readOnly,
    startWithEditView,
    isPreviewFocusable = true,
    submitOnBlur = true,
    selectAllOnFocus = true,
    ...rest
  } = useFormControlProps(props2);
  const onEditRef = useCallbackRef(onEditProp);
  const formControlProps = pickObject(rest, formControlProperties);
  const [isEditing, setIsEditing] = (0, import_react93.useState)(
    !!startWithEditView && !disabled
  );
  const [value, setValue] = useControllableState({
    defaultValue: defaultValue || "",
    value: valueProp,
    onChange: onChangeProp
  });
  const isInteractive = !isEditing && !disabled;
  const isValueEmpty = value.length === 0;
  const [prevValue, setPrevValue] = (0, import_react93.useState)(value);
  const inputRef = (0, import_react93.useRef)(null);
  const previewRef = (0, import_react93.useRef)(null);
  const editRef = (0, import_react93.useRef)(null);
  const cancelRef = (0, import_react93.useRef)(null);
  const submitRef = (0, import_react93.useRef)(null);
  useFocusOnPointerDown({
    ref: inputRef,
    enabled: isEditing,
    elements: [cancelRef, submitRef]
  });
  useSafeLayoutEffect(() => {
    var _a, _b;
    if (!isEditing) return;
    (_a = inputRef.current) == null ? void 0 : _a.focus();
    if (selectAllOnFocus) (_b = inputRef.current) == null ? void 0 : _b.select();
  }, []);
  useUpdateEffect(() => {
    var _a, _b, _c;
    if (!isEditing) {
      (_a = editRef.current) == null ? void 0 : _a.focus();
      return;
    }
    (_b = inputRef.current) == null ? void 0 : _b.focus();
    if (selectAllOnFocus) (_c = inputRef.current) == null ? void 0 : _c.select();
    onEditRef();
  }, [isEditing, onEditRef, selectAllOnFocus]);
  (0, import_react93.useEffect)(() => {
    if (isEditing) return;
    const el = inputRef.current;
    const activeEl = el == null ? void 0 : el.ownerDocument.activeElement;
    if (activeEl === el) el == null ? void 0 : el.blur();
  }, [isEditing]);
  const onChange = (0, import_react93.useCallback)(
    (ev) => setValue(ev.currentTarget.value),
    [setValue]
  );
  const onUpdatePrevValue = (0, import_react93.useCallback)(() => setPrevValue(value), [value]);
  const onEdit = (0, import_react93.useCallback)(() => {
    if (isInteractive) setIsEditing(true);
  }, [isInteractive]);
  const onCancel = (0, import_react93.useCallback)(() => {
    setIsEditing(false);
    setValue(prevValue);
    onCancelProp == null ? void 0 : onCancelProp(prevValue);
  }, [prevValue, onCancelProp, setValue]);
  const onSubmit = (0, import_react93.useCallback)(() => {
    setIsEditing(false);
    setPrevValue(value);
    onSubmitProp == null ? void 0 : onSubmitProp(value);
  }, [onSubmitProp, value]);
  const onKeyDown = (0, import_react93.useCallback)(
    (ev) => {
      if (ev.key !== "Escape" && ev.key !== "Enter") return;
      ev.preventDefault();
      if (ev.key === "Escape") {
        onCancel();
      } else {
        const { shiftKey, metaKey } = ev;
        if (!shiftKey && !metaKey) onSubmit();
      }
    },
    [onCancel, onSubmit]
  );
  const onKeyDownWithoutSubmit = (0, import_react93.useCallback)(
    (ev) => {
      if (ev.key !== "Escape") return;
      ev.preventDefault();
      onCancel();
    },
    [onCancel]
  );
  const onBlur4 = (0, import_react93.useCallback)(
    (ev) => {
      var _a;
      if (!isEditing) return;
      const ownerDocument = ev.currentTarget.ownerDocument;
      const relatedTarget = (_a = ev.relatedTarget) != null ? _a : ownerDocument.activeElement;
      const targetIsCancel = isContains(cancelRef.current, relatedTarget);
      const targetIsSubmit = isContains(submitRef.current, relatedTarget);
      const isValidBlur = !targetIsCancel && !targetIsSubmit;
      if (!isValidBlur) return;
      if (submitOnBlur) {
        onSubmit();
      } else {
        onCancel();
      }
    },
    [isEditing, submitOnBlur, onSubmit, onCancel]
  );
  const getPreviewProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...props22,
      ref: mergeRefs(ref, previewRef),
      hidden: isEditing,
      tabIndex: isInteractive && isPreviewFocusable ? 0 : void 0,
      children: isValueEmpty ? placeholder : value,
      onFocus: handlerAll(props22.onFocus, onEdit, onUpdatePrevValue)
    }),
    [
      isEditing,
      isInteractive,
      isPreviewFocusable,
      isValueEmpty,
      onEdit,
      onUpdatePrevValue,
      placeholder,
      value
    ]
  );
  const getInputProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(ref, inputRef),
      id: id4,
      placeholder,
      hidden: !isEditing,
      value,
      required,
      disabled,
      readOnly,
      onBlur: handlerAll(props22.onBlur, onBlur4),
      onChange: handlerAll(props22.onChange, onChange),
      onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
      onFocus: handlerAll(props22.onFocus, onUpdatePrevValue)
    }),
    [
      disabled,
      id4,
      isEditing,
      onBlur4,
      onChange,
      onKeyDown,
      onUpdatePrevValue,
      placeholder,
      readOnly,
      required,
      formControlProps,
      value
    ]
  );
  const getTextareaProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(ref, inputRef),
      id: id4,
      placeholder,
      hidden: !isEditing,
      value,
      required,
      disabled,
      readOnly,
      onBlur: handlerAll(props22.onBlur, onBlur4),
      onChange: handlerAll(props22.onChange, onChange),
      onKeyDown: handlerAll(props22.onKeyDown, onKeyDownWithoutSubmit),
      onFocus: handlerAll(props22.onFocus, onUpdatePrevValue)
    }),
    [
      disabled,
      id4,
      isEditing,
      onBlur4,
      onChange,
      onKeyDownWithoutSubmit,
      onUpdatePrevValue,
      placeholder,
      readOnly,
      required,
      formControlProps,
      value
    ]
  );
  const getEditProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(ref, editRef),
      type: "button",
      disabled,
      readOnly,
      onClick: handlerAll(props22.onClick, onEdit)
    }),
    [disabled, onEdit, readOnly, formControlProps]
  );
  const getSubmitProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(submitRef, ref),
      type: "button",
      disabled,
      readOnly,
      onClick: handlerAll(props22.onClick, onSubmit)
    }),
    [disabled, onSubmit, readOnly, formControlProps]
  );
  const getCancelProps = (0, import_react93.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref: mergeRefs(cancelRef, ref),
      type: "button",
      disabled,
      readOnly,
      onClick: handlerAll(props22.onClick, onCancel)
    }),
    [disabled, onCancel, readOnly, formControlProps]
  );
  return {
    isEditing,
    value,
    onEdit,
    onCancel,
    onSubmit,
    getPreviewProps,
    getInputProps,
    getTextareaProps,
    getEditProps,
    getSubmitProps,
    getCancelProps
  };
};
var useEditableControl = () => {
  const { isEditing, getEditProps, getCancelProps, getSubmitProps } = useEditableContext();
  return { isEditing, getEditProps, getCancelProps, getSubmitProps };
};
var [EditableProvider, useEditableContext] = createContext2({
  name: "EditableContext",
  errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
});
var Editable2 = forwardRef22(
  ({ focusBorderColor, errorBorderColor, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Editable", {
      focusBorderColor,
      errorBorderColor,
      ...props2
    });
    const {
      className,
      children,
      isInvalid,
      isReadOnly,
      isRequired,
      isDisabled: isDisabled2,
      placeholder,
      value,
      defaultValue,
      startWithEditView,
      isPreviewFocusable,
      submitOnBlur,
      selectAllOnFocus,
      onChange,
      onCancel: onCancelProp,
      onSubmit: onSubmitProp,
      onEdit: onEditProp,
      ...rest
    } = omitThemeProps(mergedProps);
    const {
      isEditing,
      getPreviewProps,
      getInputProps,
      getTextareaProps,
      getEditProps,
      getCancelProps,
      getSubmitProps,
      onSubmit,
      onCancel,
      onEdit
    } = useEditable({
      isInvalid,
      isReadOnly,
      isRequired,
      isDisabled: isDisabled2,
      placeholder,
      value,
      defaultValue,
      startWithEditView,
      isPreviewFocusable,
      submitOnBlur,
      selectAllOnFocus,
      onChange,
      onCancel: onCancelProp,
      onSubmit: onSubmitProp,
      onEdit: onEditProp
    });
    const cloneChildren = runIfFunc(children, {
      isEditing,
      onSubmit,
      onCancel,
      onEdit
    });
    const css4 = { ...styles2.container };
    return (0, import_jsx_runtime62.jsx)(
      EditableProvider,
      {
        value: {
          isEditing,
          getPreviewProps,
          getInputProps,
          getTextareaProps,
          getEditProps,
          getCancelProps,
          getSubmitProps,
          styles: styles2
        },
        children: (0, import_jsx_runtime62.jsx)(
          ui.div,
          {
            ref,
            className: cx("ui-editable", className),
            ...rest,
            __css: css4,
            children: cloneChildren
          }
        )
      }
    );
  }
);
var EditablePreview = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, getPreviewProps } = useEditableContext();
    const css4 = {
      cursor: "text",
      display: "inline-block",
      fontSize: "inherit",
      fontWeight: "inherit",
      textAlign: "inherit",
      bg: "transparent",
      ...styles2.preview
    };
    return (0, import_jsx_runtime62.jsx)(
      ui.span,
      {
        className: cx("ui-editable__preview", className),
        ...getPreviewProps(rest, ref),
        __css: css4
      }
    );
  }
);
var EditableInput = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, getInputProps } = useEditableContext();
    const css4 = {
      outline: 0,
      fontSize: "inherit",
      fontWeight: "inherit",
      textAlign: "inherit",
      bg: "transparent",
      ...styles2.input
    };
    return (0, import_jsx_runtime62.jsx)(
      ui.input,
      {
        className: cx("ui-editable__input", className),
        ...getInputProps(rest, ref),
        __css: css4
      }
    );
  }
);
var EditableTextarea = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, getTextareaProps } = useEditableContext();
    const css4 = {
      outline: 0,
      fontSize: "inherit",
      fontWeight: "inherit",
      textAlign: "inherit",
      bg: "transparent",
      ...styles2.textarea
    };
    return (0, import_jsx_runtime62.jsx)(
      ui.textarea,
      {
        className: cx("ui-editable__textarea", className),
        ...getTextareaProps(rest, ref),
        __css: css4
      }
    );
  }
);

// node_modules/@yamada-ui/file-button/dist/chunk-SFHQYLKL.mjs
var import_react94 = __toESM(require_react(), 1);
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var FileButton2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("FileButton", props2);
  const computedProps = omitThemeProps(mergedProps);
  let {
    className,
    resetRef,
    as: As,
    children,
    id: id4,
    name,
    accept,
    multiple,
    form,
    "aria-readonly": ariaReadonly,
    onClick: onClickProp,
    onChange: onChangeProp,
    ...rest
  } = useFormControlProps(computedProps);
  const { disabled, readOnly, required, "aria-invalid": isInvalid } = rest;
  const inputRef = (0, import_react94.useRef)(null);
  const onClick2 = (0, import_react94.useCallback)(() => {
    var _a;
    if (disabled || readOnly) return;
    (_a = inputRef.current) == null ? void 0 : _a.click();
  }, [disabled, readOnly]);
  const onChange = (0, import_react94.useCallback)(
    (ev) => {
      const files = !isNull(ev.currentTarget.files) ? Array.from(ev.currentTarget.files) : void 0;
      onChangeProp == null ? void 0 : onChangeProp(files);
    },
    [onChangeProp]
  );
  const onReset = (0, import_react94.useCallback)(() => {
    if (inputRef.current) inputRef.current.value = "";
  }, []);
  if (!isFunction(children)) {
    const Component3 = As || Button2;
    children = (0, import_jsx_runtime63.jsx)(
      Component3,
      {
        className: cx("ui-file-button", className),
        __isProcessSkip: !As,
        __styles: styles2,
        ...rest,
        onClick: handlerAll(onClickProp, onClick2),
        children
      }
    );
  }
  assignRef(resetRef, onReset);
  return (0, import_jsx_runtime63.jsxs)(import_jsx_runtime63.Fragment, { children: [
    (0, import_jsx_runtime63.jsx)(
      ui.input,
      {
        ref: mergeRefs(inputRef, ref),
        type: "file",
        "aria-hidden": true,
        tabIndex: -1,
        id: id4,
        name,
        form,
        accept,
        multiple,
        style: {
          border: "0px",
          clip: "rect(0px, 0px, 0px, 0px)",
          height: "1px",
          width: "1px",
          margin: "-1px",
          padding: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          position: "absolute"
        },
        onChange,
        "aria-readonly": ariaReadonly,
        ...pickObject(rest, formControlProperties)
      }
    ),
    isFunction(children) ? children({
      onClick: onClick2,
      disabled,
      readOnly,
      required,
      isDisabled: disabled,
      isReadOnly: readOnly,
      isRequired: required,
      isInvalid
    }) : children
  ] });
});

// node_modules/@yamada-ui/focus-lock/dist/chunk-3K7OGBBO.mjs
var import_react99 = __toESM(require_react(), 1);

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (e.includes(n)) continue;
    t[n] = r2[n];
  }
  return t;
}

// node_modules/react-focus-lock/dist/es2015/Combination.js
var React24 = __toESM(require_react());

// node_modules/react-focus-lock/dist/es2015/Lock.js
var React21 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/focus-lock/dist/es2015/constants.js
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
var FOCUS_NO_AUTOFOCUS = "data-no-autofocus";

// node_modules/react-focus-lock/dist/es2015/FocusGuard.js
var React20 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
var InFocusGuard = function InFocusGuard2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? null : _ref$children;
  return React20.createElement(React20.Fragment, null, React20.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }), children, children && React20.createElement("div", {
    key: "guard-last",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }));
};
InFocusGuard.propTypes = true ? {
  children: import_prop_types.default.node
} : {};

// node_modules/react-focus-lock/dist/es2015/medium.js
var mediumFocus = createMedium({}, function(_ref2) {
  var target = _ref2.target, currentTarget = _ref2.currentTarget;
  return {
    target,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true,
  ssr: typeof document !== "undefined"
});

// node_modules/react-focus-lock/dist/es2015/scope.js
var import_react95 = __toESM(require_react());
var focusScope = (0, import_react95.createContext)(void 0);

// node_modules/react-focus-lock/dist/es2015/Lock.js
var emptyArray = [];
var FocusLock = React21.forwardRef(function FocusLockUI(props2, parentRef) {
  var _extends2;
  var _React$useState = React21.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
  var observed = React21.useRef();
  var isActive = React21.useRef(false);
  var originalFocusedElement = React21.useRef(null);
  var _React$useState2 = React21.useState({}), update = _React$useState2[1];
  var children = props2.children, _props$disabled = props2.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$noFocusGuards = props2.noFocusGuards, noFocusGuards = _props$noFocusGuards === void 0 ? false : _props$noFocusGuards, _props$persistentFocu = props2.persistentFocus, persistentFocus = _props$persistentFocu === void 0 ? false : _props$persistentFocu, _props$crossFrame = props2.crossFrame, crossFrame = _props$crossFrame === void 0 ? true : _props$crossFrame, _props$autoFocus = props2.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, allowTextSelection = props2.allowTextSelection, group = props2.group, className = props2.className, whiteList = props2.whiteList, hasPositiveIndices = props2.hasPositiveIndices, _props$shards = props2.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props2.as, Container3 = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props2.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props2.sideCar, _props$returnFocus = props2.returnFocus, shouldReturnFocus = _props$returnFocus === void 0 ? false : _props$returnFocus, focusOptions = props2.focusOptions, onActivationCallback = props2.onActivation, onDeactivationCallback = props2.onDeactivation;
  var _React$useState3 = React21.useState({}), id4 = _React$useState3[0];
  var onActivation = React21.useCallback(function(_ref2) {
    var captureFocusRestore2 = _ref2.captureFocusRestore;
    if (!originalFocusedElement.current) {
      var _document;
      var activeElement = (_document = document) == null ? void 0 : _document.activeElement;
      originalFocusedElement.current = activeElement;
      if (activeElement !== document.body) {
        originalFocusedElement.current = captureFocusRestore2(activeElement);
      }
    }
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
    update();
  }, [onActivationCallback]);
  var onDeactivation = React21.useCallback(function() {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
    update();
  }, [onDeactivationCallback]);
  var returnFocus = React21.useCallback(function(allowDefer) {
    var focusRestore = originalFocusedElement.current;
    if (focusRestore) {
      var returnFocusTo = (typeof focusRestore === "function" ? focusRestore() : focusRestore) || document.body;
      var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (howToReturnFocus) {
        var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
        originalFocusedElement.current = null;
        if (allowDefer) {
          Promise.resolve().then(function() {
            return returnFocusTo.focus(returnFocusOptions);
          });
        } else {
          returnFocusTo.focus(returnFocusOptions);
        }
      }
    }
  }, [shouldReturnFocus]);
  var onFocus4 = React21.useCallback(function(event) {
    if (isActive.current) {
      mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur4 = mediumBlur.useMedium;
  var setObserveNode = React21.useCallback(function(newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  if (true) {
    if (typeof allowTextSelection !== "undefined") {
      console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default");
    }
    React21.useEffect(function() {
      if (!observed.current && typeof Container3 !== "string") {
        console.error("FocusLock: could not obtain ref to internal node");
      }
    }, []);
  }
  var lockProps = _extends((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
  var mergedRef = useMergeRefs2([parentRef, setObserveNode]);
  var focusScopeValue = React21.useMemo(function() {
    return {
      observed,
      shards,
      enabled: !disabled,
      active: isActive.current
    };
  }, [disabled, isActive.current, shards, realObserved]);
  return React21.createElement(React21.Fragment, null, hasLeadingGuards && [
    React21.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }),
    hasPositiveIndices ? React21.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 1,
      style: hiddenGuard
    }) : null
  ], !disabled && React21.createElement(SideCar2, {
    id: id4,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled,
    persistentFocus,
    crossFrame,
    autoFocus,
    whiteList,
    shards,
    onActivation,
    onDeactivation,
    returnFocus,
    focusOptions,
    noFocusGuards
  }), React21.createElement(Container3, _extends({
    ref: mergedRef
  }, lockProps, {
    className,
    onBlur: onBlur4,
    onFocus: onFocus4
  }), React21.createElement(focusScope.Provider, {
    value: focusScopeValue
  }, children)), hasTailingGuards && React21.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
});
FocusLock.propTypes = true ? {
  children: import_prop_types2.node,
  disabled: import_prop_types2.bool,
  returnFocus: (0, import_prop_types2.oneOfType)([import_prop_types2.bool, import_prop_types2.object, import_prop_types2.func]),
  focusOptions: import_prop_types2.object,
  noFocusGuards: import_prop_types2.bool,
  hasPositiveIndices: import_prop_types2.bool,
  allowTextSelection: import_prop_types2.bool,
  autoFocus: import_prop_types2.bool,
  persistentFocus: import_prop_types2.bool,
  crossFrame: import_prop_types2.bool,
  group: import_prop_types2.string,
  className: import_prop_types2.string,
  whiteList: import_prop_types2.func,
  shards: (0, import_prop_types2.arrayOf)(import_prop_types2.any),
  as: (0, import_prop_types2.oneOfType)([import_prop_types2.string, import_prop_types2.func, import_prop_types2.object]),
  lockProps: import_prop_types2.object,
  onActivation: import_prop_types2.func,
  onDeactivation: import_prop_types2.func,
  sideCar: import_prop_types2.any.isRequired
} : {};
var Lock_default = FocusLock;

// node_modules/react-focus-lock/dist/es2015/Trap.js
var React23 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r2) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r2, t) {
  return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}

// node_modules/react-clientside-effect/lib/index.es.js
var import_react96 = __toESM(require_react());
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  if (true) {
    if (typeof reducePropsToState2 !== "function") {
      throw new Error("Expected reducePropsToState to be a function.");
    }
    if (typeof handleStateChangeOnClient2 !== "function") {
      throw new Error("Expected handleStateChangeOnClient to be a function.");
    }
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap3(WrappedComponent) {
    if (true) {
      if (typeof WrappedComponent !== "function") {
        throw new Error("Expected WrappedComponent to be a React component.");
      }
    }
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state);
    }
    var SideEffect = function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek2() {
        return state;
      };
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };
      _proto.render = function render() {
        return import_react96.default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(import_react96.PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    return SideEffect;
  };
}
var index_es_default = withSideEffect;

// node_modules/focus-lock/dist/es2015/utils/array.js
var toArray = function(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};
var asArray = function(a) {
  return Array.isArray(a) ? a : [a];
};
var getFirst = function(a) {
  return Array.isArray(a) ? a[0] : a;
};

// node_modules/focus-lock/dist/es2015/utils/is.js
var isElementHidden = function(node3) {
  if (node3.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node3, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
};
var getParentNode = function(node3) {
  return node3.parentNode && node3.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    node3.parentNode.host
  ) : node3.parentNode;
};
var isTopNode = function(node3) {
  return node3 === document || node3 && node3.nodeType === Node.DOCUMENT_NODE;
};
var isInert = function(node3) {
  return node3.hasAttribute("inert");
};
var isVisibleUncached = function(node3, checkParent) {
  return !node3 || isTopNode(node3) || !isElementHidden(node3) && !isInert(node3) && checkParent(getParentNode(node3));
};
var isVisibleCached = function(visibilityCache, node3) {
  var cached = visibilityCache.get(node3);
  if (cached !== void 0) {
    return cached;
  }
  var result = isVisibleUncached(node3, isVisibleCached.bind(void 0, visibilityCache));
  visibilityCache.set(node3, result);
  return result;
};
var isAutoFocusAllowedUncached = function(node3, checkParent) {
  return node3 && !isTopNode(node3) ? isAutoFocusAllowed(node3) ? checkParent(getParentNode(node3)) : false : true;
};
var isAutoFocusAllowedCached = function(cache2, node3) {
  var cached = cache2.get(node3);
  if (cached !== void 0) {
    return cached;
  }
  var result = isAutoFocusAllowedUncached(node3, isAutoFocusAllowedCached.bind(void 0, cache2));
  cache2.set(node3, result);
  return result;
};
var getDataset = function(node3) {
  return node3.dataset;
};
var isHTMLButtonElement = function(node3) {
  return node3.tagName === "BUTTON";
};
var isHTMLInputElement = function(node3) {
  return node3.tagName === "INPUT";
};
var isRadioElement = function(node3) {
  return isHTMLInputElement(node3) && node3.type === "radio";
};
var notHiddenInput = function(node3) {
  return !((isHTMLInputElement(node3) || isHTMLButtonElement(node3)) && (node3.type === "hidden" || node3.disabled));
};
var isAutoFocusAllowed = function(node3) {
  var attribute = node3.getAttribute(FOCUS_NO_AUTOFOCUS);
  return ![true, "true", ""].includes(attribute);
};
var isGuard = function(node3) {
  var _a;
  return Boolean(node3 && ((_a = getDataset(node3)) === null || _a === void 0 ? void 0 : _a.focusGuard));
};
var isNotAGuard = function(node3) {
  return !isGuard(node3);
};
var isDefined = function(x) {
  return Boolean(x);
};

// node_modules/focus-lock/dist/es2015/utils/tabOrder.js
var tabSort = function(a, b) {
  var aTab = Math.max(0, a.tabIndex);
  var bTab = Math.max(0, b.tabIndex);
  var tabDiff = aTab - bTab;
  var indexDiff = a.index - b.index;
  if (tabDiff) {
    if (!aTab) {
      return 1;
    }
    if (!bTab) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
var getTabIndex = function(node3) {
  if (node3.tabIndex < 0) {
    if (!node3.hasAttribute("tabindex")) {
      return 0;
    }
  }
  return node3.tabIndex;
};
var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node3, index) {
    var tabIndex = getTabIndex(node3);
    return {
      node: node3,
      index,
      tabIndex: keepGuards && tabIndex === -1 ? (node3.dataset || {}).focusGuard ? 0 : -1 : tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};

// node_modules/focus-lock/dist/es2015/utils/tabbables.js
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];

// node_modules/focus-lock/dist/es2015/utils/tabUtils.js
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function(parent, withGuards) {
  return toArray((parent.shadowRoot || parent).children).reduce(function(acc, child) {
    return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
  }, []);
};
var getFocusablesWithIFrame = function(parent, withGuards) {
  var _a;
  if (parent instanceof HTMLIFrameElement && ((_a = parent.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
    return getFocusables([parent.contentDocument.body], withGuards);
  }
  return [parent];
};
var getFocusables = function(parents, withGuards) {
  return parents.reduce(function(acc, parent) {
    var _a;
    var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
    var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function(node3) {
      return getFocusablesWithIFrame(node3, withGuards);
    }));
    return acc.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      focusableWithIframes,
      // add if node is tabbable itself
      parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function(node3) {
        return node3 === parent;
      }) : []
    );
  }, []);
};
var getParentAutofocusables = function(parent) {
  var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
  return toArray(parentFocus).map(function(node3) {
    return getFocusables([node3]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
};

// node_modules/focus-lock/dist/es2015/utils/DOMutils.js
var filterFocusable = function(nodes, visibilityCache) {
  return toArray(nodes).filter(function(node3) {
    return isVisibleCached(visibilityCache, node3);
  }).filter(function(node3) {
    return notHiddenInput(node3);
  });
};
var filterAutoFocusable = function(nodes, cache2) {
  if (cache2 === void 0) {
    cache2 = /* @__PURE__ */ new Map();
  }
  return toArray(nodes).filter(function(node3) {
    return isAutoFocusAllowedCached(cache2, node3);
  });
};
var getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
};
var getFocusableNodes = function(topNodes, visibilityCache) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
};
var parentAutofocusables = function(topNode, visibilityCache) {
  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
};
var contains = function(scope, element) {
  if (scope.shadowRoot) {
    return contains(scope.shadowRoot, element);
  } else {
    if (Object.getPrototypeOf(scope).contains !== void 0 && Object.getPrototypeOf(scope).contains.call(scope, element)) {
      return true;
    }
    return toArray(scope.children).some(function(child) {
      var _a;
      if (child instanceof HTMLIFrameElement) {
        var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
        if (iframeBody) {
          return contains(iframeBody, element);
        }
        return false;
      }
      return contains(child, element);
    });
  }
};

// node_modules/focus-lock/dist/es2015/utils/all-affected.js
var filterNested = function(nodes) {
  var contained = /* @__PURE__ */ new Set();
  var l = nodes.length;
  for (var i = 0; i < l; i += 1) {
    for (var j = i + 1; j < l; j += 1) {
      var position2 = nodes[i].compareDocumentPosition(nodes[j]);
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i);
      }
    }
  }
  return nodes.filter(function(_, index) {
    return !contained.has(index);
  });
};
var getTopParent = function(node3) {
  return node3.parentNode ? getTopParent(node3.parentNode) : node3;
};
var getAllAffectedNodes = function(node3) {
  var nodes = asArray(node3);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
    return acc;
  }, []);
};

// node_modules/focus-lock/dist/es2015/utils/safe.js
var safeProbe = function(cb) {
  try {
    return cb();
  } catch (e) {
    return void 0;
  }
};

// node_modules/focus-lock/dist/es2015/utils/getActiveElement.js
var getActiveElement2 = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  if (!inDocument || !inDocument.activeElement) {
    return void 0;
  }
  var activeElement = inDocument.activeElement;
  return activeElement.shadowRoot ? getActiveElement2(activeElement.shadowRoot) : activeElement instanceof HTMLIFrameElement && safeProbe(function() {
    return activeElement.contentWindow.document;
  }) ? getActiveElement2(activeElement.contentWindow.document) : activeElement;
};

// node_modules/focus-lock/dist/es2015/focusInside.js
var focusInFrame = function(frame3, activeElement) {
  return frame3 === activeElement;
};
var focusInsideIframe = function(topNode, activeElement) {
  return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node3) {
    return focusInFrame(node3, activeElement);
  }));
};
var focusInside = function(topNode, activeElement) {
  if (activeElement === void 0) {
    activeElement = getActiveElement2(getFirst(topNode).ownerDocument);
  }
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).some(function(node3) {
    return contains(node3, activeElement) || focusInsideIframe(node3, activeElement);
  });
};

// node_modules/focus-lock/dist/es2015/focusIsHidden.js
var focusIsHidden = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  var activeElement = getActiveElement2(inDocument);
  if (!activeElement) {
    return false;
  }
  return toArray(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node3) {
    return contains(node3, activeElement);
  });
};

// node_modules/focus-lock/dist/es2015/utils/correctFocus.js
var findSelectedRadio = function(node3, nodes) {
  return nodes.filter(isRadioElement).filter(function(el) {
    return el.name === node3.name;
  }).filter(function(el) {
    return el.checked;
  })[0] || node3;
};
var correctNode = function(node3, nodes) {
  if (isRadioElement(node3) && node3.name) {
    return findSelectedRadio(node3, nodes);
  }
  return node3;
};
var correctNodes = function(nodes) {
  var resultSet = /* @__PURE__ */ new Set();
  nodes.forEach(function(node3) {
    return resultSet.add(correctNode(node3, nodes));
  });
  return nodes.filter(function(node3) {
    return resultSet.has(node3);
  });
};

// node_modules/focus-lock/dist/es2015/utils/firstFocus.js
var pickFirstFocus = function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
};
var pickFocusable = function(nodes, node3) {
  return nodes.indexOf(correctNode(node3, nodes));
};

// node_modules/focus-lock/dist/es2015/solver.js
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = function(innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);
  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
    return void 0;
  }
  var activeIndex = activeElement !== void 0 ? outerNodes.indexOf(activeElement) : -1;
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  if (activeIndex === -1) {
    if (lastNodeInside !== -1) {
      return lastNodeInside;
    }
    return NEW_FOCUS;
  }
  if (lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = correctNodes(outerNodes);
  var correctedIndex = activeElement !== void 0 ? correctedNodes.indexOf(activeElement) : -1;
  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (innerTabbables.length === 0) {
    return lastNodeInside;
  }
  var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);
  var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
};

// node_modules/focus-lock/dist/es2015/utils/auto-focus.js
var findAutoFocused = function(autoFocusables) {
  return function(node3) {
    var _a;
    var autofocus = (_a = getDataset(node3)) === null || _a === void 0 ? void 0 : _a.autofocus;
    return (
      // @ts-expect-error
      node3.autofocus || //
      autofocus !== void 0 && autofocus !== "false" || //
      autoFocusables.indexOf(node3) >= 0
    );
  };
};
var pickAutofocus = function(nodesIndexes, orderedNodes, groups) {
  var nodes = nodesIndexes.map(function(_a) {
    var node3 = _a.node;
    return node3;
  });
  var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
  if (autoFocusable && autoFocusable.length) {
    return pickFirstFocus(autoFocusable);
  }
  return pickFirstFocus(filterAutoFocusable(orderedNodes));
};

// node_modules/focus-lock/dist/es2015/utils/parenting.js
var getParents = function(node3, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node3);
  if (node3.parentNode) {
    getParents(node3.parentNode.host || node3.parentNode, parents);
  }
  return parents;
};
var getCommonParent = function(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || contains(common, topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};
var allParentAutofocusables = function(entries, visibilityCache) {
  return entries.reduce(function(acc, node3) {
    return acc.concat(parentAutofocusables(node3, visibilityCache));
  }, []);
};

// node_modules/focus-lock/dist/es2015/focusSolver.js
var reorderNodes = function(srcNodes, dstNodes) {
  var remap = /* @__PURE__ */ new Map();
  dstNodes.forEach(function(entity) {
    return remap.set(entity.node, entity);
  });
  return srcNodes.map(function(node3) {
    return remap.get(node3);
  }).filter(isDefined);
};
var focusSolver = function(topNode, lastNode) {
  var activeElement = getActiveElement2(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
  var visibilityCache = /* @__PURE__ */ new Map();
  var anyFocusable = getFocusableNodes(entries, visibilityCache);
  var innerElements = anyFocusable.filter(function(_a) {
    var node3 = _a.node;
    return isNotAGuard(node3);
  });
  if (!innerElements[0]) {
    return void 0;
  }
  var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function(_a) {
    var node3 = _a.node;
    return node3;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerFocusables = orderedInnerElements.map(function(_a) {
    var node3 = _a.node;
    return node3;
  });
  var innerTabbable = orderedInnerElements.filter(function(_a) {
    var tabIndex = _a.tabIndex;
    return tabIndex >= 0;
  }).map(function(_a) {
    var node3 = _a.node;
    return node3;
  });
  var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);
  if (newId === NEW_FOCUS) {
    var focusNode = (
      // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
      pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) || pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache))
    );
    if (focusNode) {
      return { node: focusNode };
    } else {
      console.warn("focus-lock: cannot find any node to move focus into");
      return void 0;
    }
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
};

// node_modules/focus-lock/dist/es2015/focusables.js
var expandFocusableNodes = function(topNode) {
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries);
  var outerNodes = orderByTabIndex(getFocusables([commonParent], true), true, true);
  var innerElements = getFocusables(entries, false);
  return outerNodes.map(function(_a) {
    var node3 = _a.node, index = _a.index;
    return {
      node: node3,
      index,
      lockItem: innerElements.indexOf(node3) >= 0,
      guard: isGuard(node3)
    };
  });
};

// node_modules/focus-lock/dist/es2015/commands.js
var focusOn = function(target, focusOptions) {
  if (!target) {
    return;
  }
  if ("focus" in target) {
    target.focus(focusOptions);
  }
  if ("contentWindow" in target && target.contentWindow) {
    target.contentWindow.focus();
  }
};

// node_modules/focus-lock/dist/es2015/moveFocusInside.js
var guardCount = 0;
var lockDisabled = false;
var moveFocusInside = function(topNode, lastNode, options) {
  if (options === void 0) {
    options = {};
  }
  var focusable = focusSolver(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node, options.focusOptions);
    guardCount--;
  }
};

// node_modules/focus-lock/dist/es2015/return-focus.js
function weakRef(value) {
  if (!value)
    return null;
  if (typeof WeakRef === "undefined") {
    return function() {
      return value || null;
    };
  }
  var w = value ? new WeakRef(value) : null;
  return function() {
    return (w === null || w === void 0 ? void 0 : w.deref()) || null;
  };
}
var recordElementLocation = function(element) {
  if (!element) {
    return null;
  }
  var stack = [];
  var currentElement = element;
  while (currentElement && currentElement !== document.body) {
    stack.push({
      current: weakRef(currentElement),
      parent: weakRef(currentElement.parentElement),
      left: weakRef(currentElement.previousElementSibling),
      right: weakRef(currentElement.nextElementSibling)
    });
    currentElement = currentElement.parentElement;
  }
  return {
    element: weakRef(element),
    stack,
    ownerDocument: element.ownerDocument
  };
};
var restoreFocusTo = function(location) {
  var _a, _b, _c, _d, _e;
  if (!location) {
    return void 0;
  }
  var stack = location.stack, ownerDocument = location.ownerDocument;
  var visibilityCache = /* @__PURE__ */ new Map();
  for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {
    var line2 = stack_1[_i];
    var parent_1 = (_a = line2.parent) === null || _a === void 0 ? void 0 : _a.call(line2);
    if (parent_1 && ownerDocument.contains(parent_1)) {
      var left2 = (_b = line2.left) === null || _b === void 0 ? void 0 : _b.call(line2);
      var savedCurrent = line2.current();
      var current = parent_1.contains(savedCurrent) ? savedCurrent : void 0;
      var right2 = (_c = line2.right) === null || _c === void 0 ? void 0 : _c.call(line2);
      var focusables = getTabbableNodes([parent_1], visibilityCache);
      var aim = (
        // that is element itself
        (_e = (_d = current !== null && current !== void 0 ? current : (
          // or something in it's place
          left2 === null || left2 === void 0 ? void 0 : left2.nextElementSibling
        )) !== null && _d !== void 0 ? _d : (
          // or somebody to the right, still close enough
          right2
        )) !== null && _e !== void 0 ? _e : (
          // or somebody to the left, something?
          left2
        )
      );
      while (aim) {
        for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {
          var focusable = focusables_1[_f];
          if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {
            return focusable.node;
          }
        }
        aim = aim.nextElementSibling;
      }
      if (focusables.length) {
        return focusables[0].node;
      }
    }
  }
  return void 0;
};
var captureFocusRestore = function(targetElement) {
  var location = recordElementLocation(targetElement);
  return function() {
    return restoreFocusTo(location);
  };
};

// node_modules/focus-lock/dist/es2015/sibling.js
var getRelativeFocusable = function(element, scope, useTabbables) {
  if (!element || !scope) {
    console.error("no element or scope given");
    return {};
  }
  var shards = asArray(scope);
  if (shards.every(function(shard) {
    return !contains(shard, element);
  })) {
    console.error("Active element is not contained in the scope");
    return {};
  }
  var focusables = useTabbables ? getTabbableNodes(shards, /* @__PURE__ */ new Map()) : getFocusableNodes(shards, /* @__PURE__ */ new Map());
  var current = focusables.findIndex(function(_a) {
    var node3 = _a.node;
    return node3 === element;
  });
  if (current === -1) {
    return void 0;
  }
  return {
    prev: focusables[current - 1],
    next: focusables[current + 1],
    first: focusables[0],
    last: focusables[focusables.length - 1]
  };
};
var getBoundary = function(shards, useTabbables) {
  var set = useTabbables ? getTabbableNodes(asArray(shards), /* @__PURE__ */ new Map()) : getFocusableNodes(asArray(shards), /* @__PURE__ */ new Map());
  return {
    first: set[0],
    last: set[set.length - 1]
  };
};
var defaultOptions = function(options) {
  return Object.assign({
    scope: document.body,
    cycle: true,
    onlyTabbable: true
  }, options);
};
var moveFocus = function(fromElement, options, cb) {
  if (options === void 0) {
    options = {};
  }
  var newOptions = defaultOptions(options);
  var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);
  if (!solution) {
    return;
  }
  var target = cb(solution, newOptions.cycle);
  if (target) {
    focusOn(target.node, newOptions.focusOptions);
  }
};
var focusNextElement = function(fromElement, options) {
  if (options === void 0) {
    options = {};
  }
  moveFocus(fromElement, options, function(_a, cycle) {
    var next2 = _a.next, first = _a.first;
    return next2 || cycle && first;
  });
};
var focusPrevElement = function(fromElement, options) {
  if (options === void 0) {
    options = {};
  }
  moveFocus(fromElement, options, function(_a, cycle) {
    var prev2 = _a.prev, last = _a.last;
    return prev2 || cycle && last;
  });
};
var pickBoundary = function(scope, options, what) {
  var _a;
  var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);
  var node3 = boundary[what];
  if (node3) {
    focusOn(node3.node, options.focusOptions);
  }
};
var focusFirstElement = function(scope, options) {
  if (options === void 0) {
    options = {};
  }
  pickBoundary(scope, options, "first");
};
var focusLastElement = function(scope, options) {
  if (options === void 0) {
    options = {};
  }
  pickBoundary(scope, options, "last");
};

// node_modules/react-focus-lock/dist/es2015/util.js
function deferAction(action) {
  setTimeout(action, 1);
}
var inlineProp = function inlineProp2(name, value) {
  var obj = {};
  obj[name] = value;
  return obj;
};
var extractRef2 = function extractRef3(ref) {
  return ref && "current" in ref ? ref.current : ref;
};

// node_modules/react-focus-lock/dist/es2015/Trap.js
var focusOnBody = function focusOnBody2() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var tryRestoreFocus = function tryRestoreFocus2() {
  return null;
};
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var windowFocused = false;
var defaultWhitelist = function defaultWhitelist2() {
  return true;
};
var focusWhitelisted = function focusWhitelisted2(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};
var recordPortal = function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end2, step, allNodes) {
  var lastGuard = null;
  var i = startIndex;
  do {
    var item = allNodes[i];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end2);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var focusWasOutside = function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
};
var checkInHost = function checkInHost2(check, el, boundary) {
  return el && (el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost2(check, el.parentNode, boundary));
};
var withinHost = function withinHost2(activeElement, workingArea) {
  return workingArea.some(function(area) {
    return checkInHost(activeElement, area, area);
  });
};
var getNodeFocusables = function getNodeFocusables2(nodes) {
  return getFocusableNodes(nodes, /* @__PURE__ */ new Map());
};
var isNotFocusable = function isNotFocusable2(node3) {
  return !getNodeFocusables([node3.parentNode]).some(function(el) {
    return el.node === node3;
  });
};
var activateTrap = function activateTrap2() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions, noFocusGuards = _lastActiveTrap.noFocusGuards;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    if (focusOnBody() && lastActiveFocus) {
      if (!document.body.contains(lastActiveFocus) || isNotFocusable(lastActiveFocus)) {
        lastActiveFocus = null;
        var newTarget = tryRestoreFocus();
        if (newTarget) {
          newTarget.focus();
        }
      }
    }
    var activeElement = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef2).filter(Boolean));
      var shouldForceRestoreFocus = function shouldForceRestoreFocus2() {
        if (!focusWasOutside(crossFrame) || !noFocusGuards || !lastActiveFocus || windowFocused) {
          return false;
        }
        var nodes = getNodeFocusables(workingArea);
        var lastIndex = nodes.findIndex(function(_ref2) {
          var node3 = _ref2.node;
          return node3 === lastActiveFocus;
        });
        return lastIndex === 0 || lastIndex === nodes.length - 1;
      };
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || shouldForceRestoreFocus() || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingArea) || activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement, workingNode))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = moveFocusInside(workingArea, lastActiveFocus, {
                focusOptions
              });
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
          tryRestoreFocus = captureFocusRestore(lastActiveFocus);
        }
      }
      if (document && activeElement !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
        var newActiveElement = document && document.activeElement;
        var allNodes = expandFocusableNodes(workingArea);
        var focusedIndex = allNodes.map(function(_ref2) {
          var node3 = _ref2.node;
          return node3;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref3) {
            var guard2 = _ref3.guard, node3 = _ref3.node;
            return guard2 && node3.dataset.focusAutoGuard;
          }).forEach(function(_ref4) {
            var node3 = _ref4.node;
            return node3.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap2(event) {
  if (activateTrap() && event) {
    event.stopPropagation();
    event.preventDefault();
  }
};
var onBlur2 = function onBlur3() {
  return deferAction(activateTrap);
};
var onFocus2 = function onFocus3(event) {
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher2() {
  return null;
};
var FocusTrap = function FocusTrap2(_ref5) {
  var children = _ref5.children;
  return React23.createElement("div", {
    onBlur: onBlur2,
    onFocus: onFocus2
  }, children);
};
FocusTrap.propTypes = true ? {
  children: import_prop_types3.default.node.isRequired
} : {};
var onWindowFocus = function onWindowFocus2() {
  windowFocused = true;
};
var onWindowBlur = function onWindowBlur2() {
  windowFocused = false;
  focusWasOutsideWindow = "just";
  deferAction(function() {
    focusWasOutsideWindow = "meanwhile";
  });
};
var attachHandler = function attachHandler2() {
  document.addEventListener("focusin", onTrap);
  document.addEventListener("focusout", onBlur2);
  window.addEventListener("focus", onWindowFocus);
  window.addEventListener("blur", onWindowBlur);
};
var detachHandler = function detachHandler2() {
  document.removeEventListener("focusin", onTrap);
  document.removeEventListener("focusout", onBlur2);
  window.removeEventListener("focus", onWindowFocus);
  window.removeEventListener("blur", onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref6) {
    var disabled = _ref6.disabled;
    return !disabled;
  });
}
var focusLockAPI = {
  moveFocusInside,
  focusInside,
  focusNextElement,
  focusPrevElement,
  focusFirstElement,
  focusLastElement,
  captureFocusRestore
};
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref7) {
      var id4 = _ref7.id;
      return id4 === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation(focusLockAPI);
    }
    activateTrap(true);
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
mediumFocus.assignSyncMedium(onFocus2);
mediumBlur.assignMedium(onBlur2);
mediumEffect.assignMedium(function(cb) {
  return cb(focusLockAPI);
});
var Trap_default = index_es_default(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

// node_modules/react-focus-lock/dist/es2015/Combination.js
var FocusLockCombination = React24.forwardRef(function FocusLockUICombination(props2, ref) {
  return React24.createElement(Lock_default, _extends({
    sideCar: Trap_default,
    ref
  }, props2));
});
var _ref = Lock_default.propTypes || {};
var sideCar = _ref.sideCar;
var propTypes = _objectWithoutPropertiesLoose(_ref, ["sideCar"]);
FocusLockCombination.propTypes = true ? propTypes : {};
var Combination_default2 = FocusLockCombination;

// node_modules/react-focus-lock/dist/es2015/AutoFocusInside.js
var React25 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var AutoFocusInside = function AutoFocusInside2(_ref2) {
  var _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, children = _ref2.children, _ref$className = _ref2.className, className = _ref$className === void 0 ? void 0 : _ref$className;
  return React25.createElement("div", _extends({}, inlineProp(FOCUS_AUTO, !disabled), {
    className
  }), children);
};
AutoFocusInside.propTypes = true ? {
  children: import_prop_types4.default.node.isRequired,
  disabled: import_prop_types4.default.bool,
  className: import_prop_types4.default.string
} : {};

// node_modules/react-focus-lock/dist/es2015/MoveFocusInside.js
var React26 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var useFocusInside = function useFocusInside2(observedRef) {
  React26.useEffect(function() {
    var enabled2 = true;
    mediumEffect.useMedium(function(car) {
      var observed = observedRef && observedRef.current;
      if (enabled2 && observed) {
        if (!car.focusInside(observed)) {
          car.moveFocusInside(observed, null);
        }
      }
    });
    return function() {
      enabled2 = false;
    };
  }, [observedRef]);
};
function MoveFocusInside(_ref2) {
  var _ref$disabled = _ref2.disabled, isDisabled2 = _ref$disabled === void 0 ? false : _ref$disabled, className = _ref2.className, children = _ref2.children;
  var ref = React26.useRef(null);
  useFocusInside(isDisabled2 ? void 0 : ref);
  return React26.createElement("div", _extends({}, inlineProp(FOCUS_AUTO, !isDisabled2), {
    ref,
    className
  }), children);
}
MoveFocusInside.propTypes = true ? {
  children: import_prop_types5.default.node.isRequired,
  disabled: import_prop_types5.default.bool,
  className: import_prop_types5.default.string
} : {};

// node_modules/react-focus-lock/dist/es2015/FreeFocusInside.js
var React27 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var FreeFocusInside = function FreeFocusInside2(_ref2) {
  var children = _ref2.children, className = _ref2.className;
  return React27.createElement("div", _extends({}, inlineProp(FOCUS_ALLOW, true), {
    className
  }), children);
};
FreeFocusInside.propTypes = true ? {
  children: import_prop_types6.default.node.isRequired,
  className: import_prop_types6.default.string
} : {};

// node_modules/react-focus-lock/dist/es2015/use-focus-scope.js
var import_react97 = __toESM(require_react());

// node_modules/react-focus-lock/dist/es2015/use-focus-state.js
var import_react98 = __toESM(require_react());

// node_modules/react-focus-lock/dist/es2015/nano-events.js
var createNanoEvents = function createNanoEvents2() {
  return {
    emit: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      for (var i = 0, callbacks = this.events[event] || [], length2 = callbacks.length; i < length2; i++) {
        callbacks[i].apply(callbacks, args);
      }
    },
    events: {},
    on: function on(event, cb) {
      var _this$events, _this = this;
      ((_this$events = this.events)[event] || (_this$events[event] = [])).push(cb);
      return function() {
        var _this$events$event;
        _this.events[event] = (_this$events$event = _this.events[event]) == null ? void 0 : _this$events$event.filter(function(i) {
          return cb !== i;
        });
      };
    }
  };
};

// node_modules/react-focus-lock/dist/es2015/use-focus-state.js
var mainbus = createNanoEvents();

// node_modules/react-focus-lock/dist/es2015/index.js
var es2015_default = Combination_default2;

// node_modules/@yamada-ui/focus-lock/dist/chunk-3K7OGBBO.mjs
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var InternalFocusLock = interopDefault(es2015_default);
var FocusLock2 = ({
  initialFocusRef,
  finalFocusRef,
  contentRef,
  restoreFocus,
  children,
  isDisabled: isDisabled2,
  autoFocus,
  persistentFocus,
  lockFocusAcrossFrames
}) => {
  const onActivation = (0, import_react99.useCallback)(() => {
    if (initialFocusRef == null ? void 0 : initialFocusRef.current) {
      initialFocusRef.current.focus();
    } else if (contentRef == null ? void 0 : contentRef.current) {
      const focusables = getAllFocusable(contentRef.current);
      if (focusables.length === 0)
        requestAnimationFrame(() => {
          var _a;
          (_a = contentRef.current) == null ? void 0 : _a.focus();
        });
    }
  }, [initialFocusRef, contentRef]);
  const onDeactivation = (0, import_react99.useCallback)(() => {
    var _a;
    (_a = finalFocusRef == null ? void 0 : finalFocusRef.current) == null ? void 0 : _a.focus();
  }, [finalFocusRef]);
  const returnFocus = restoreFocus && !finalFocusRef;
  return (0, import_jsx_runtime64.jsx)(
    InternalFocusLock,
    {
      crossFrame: lockFocusAcrossFrames,
      persistentFocus,
      autoFocus,
      disabled: isDisabled2,
      onActivation,
      onDeactivation,
      returnFocus,
      children
    }
  );
};

// node_modules/@yamada-ui/typography/dist/chunk-FOUDL4AG.mjs
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var Heading2 = forwardRef22((props2, ref) => {
  const [css4, mergedProps] = useComponentStyle("Heading", props2);
  const { className, ...rest } = omitThemeProps(mergedProps);
  return (0, import_jsx_runtime65.jsx)(
    ui.h1,
    {
      ref,
      className: cx("ui-heading", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/typography/dist/chunk-QRXFNZCL.mjs
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var Text2 = forwardRef22((props2, ref) => {
  const [css4, mergedProps] = useComponentStyle("Text", props2);
  const {
    className,
    align: textAlign,
    decoration: textDecoration,
    casing: textTransform,
    ...rest
  } = omitThemeProps(mergedProps);
  const textProps = filterUndefined({
    textAlign,
    textDecoration,
    textTransform
  });
  return (0, import_jsx_runtime66.jsx)(
    ui.p,
    {
      ref,
      className: cx("ui-text", className),
      __css: css4,
      ...textProps,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/highlight/dist/chunk-HHQFRLYL.mjs
var import_react100 = __toESM(require_react(), 1);
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char2) => `\\${char2}`);
var buildRegex = (query) => {
  query = query.filter(Boolean).map((text) => escapeRegexp(text.trim()));
  if (query.length) return new RegExp(`(${query.join("|")})`, "ig");
};
var highlightWords = ({ text, query }) => {
  const regex = buildRegex(isArray(query) ? query : [query]);
  if (!regex) return [{ text, match: false }];
  return text.split(regex).filter(Boolean).map((text2) => ({ text: text2, match: regex.test(text2) }));
};
var useHighlight = ({ text, query }) => (0, import_react100.useMemo)(() => highlightWords({ text, query }), [text, query]);
var Highlight = ({
  isFragment = false,
  query,
  children: text,
  markProps,
  lineHeight = "tall",
  ...rest
}) => {
  if (typeof text !== "string")
    throw new Error("The children prop of Highlight must be a string");
  const chunks = useHighlight({ query, text });
  const Component3 = isFragment ? import_react100.Fragment : Text2;
  return (0, import_jsx_runtime67.jsx)(Component3, { ...!isFragment ? { lineHeight } : {}, ...rest, children: chunks.map(
    ({ text: text2, match: match2 }, i) => match2 ? (0, import_jsx_runtime67.jsx)(Mark2, { ...markProps, children: text2 }, i) : (0, import_jsx_runtime67.jsx)(import_react100.Fragment, { children: text2 }, i)
  ) });
};
var Mark2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("Mark", props2);
  const { className, ...rest } = omitThemeProps(mergedProps);
  const css4 = {
    bg: "transparent",
    whiteSpace: "nowrap",
    ...styles2
  };
  return (0, import_jsx_runtime67.jsx)(
    ui.mark,
    {
      ref,
      className: cx("ui-mark", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/image/dist/chunk-35V2M72K.mjs
var import_react101 = __toESM(require_react(), 1);
var shouldShowFallbackImage = (status, fallbackStrategy) => status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
var useImage = ({
  loading,
  src,
  srcSet,
  onLoad,
  onError,
  crossOrigin,
  sizes: sizes2,
  ignoreFallback
}) => {
  const [status, setStatus] = (0, import_react101.useState)("pending");
  (0, import_react101.useEffect)(() => {
    setStatus(src ? "loading" : "pending");
  }, [src]);
  const imageRef = (0, import_react101.useRef)();
  const load = (0, import_react101.useCallback)(() => {
    if (!src) return;
    flush2();
    const img = new Image();
    img.src = src;
    if (crossOrigin) img.crossOrigin = crossOrigin;
    if (srcSet) img.srcset = srcSet;
    if (sizes2) img.sizes = sizes2;
    if (loading) img.loading = loading;
    img.onload = (ev) => {
      flush2();
      setStatus("loaded");
      onLoad == null ? void 0 : onLoad(ev);
    };
    img.onerror = (error) => {
      flush2();
      setStatus("failed");
      onError == null ? void 0 : onError(error);
    };
    imageRef.current = img;
  }, [src, crossOrigin, srcSet, sizes2, onLoad, onError, loading]);
  const flush2 = () => {
    if (!imageRef.current) return;
    imageRef.current.onload = null;
    imageRef.current.onerror = null;
    imageRef.current = null;
  };
  useSafeLayoutEffect(() => {
    if (ignoreFallback) return;
    if (status === "loading") load();
    return () => {
      flush2();
    };
  }, [status, load, ignoreFallback]);
  return ignoreFallback ? "loaded" : status;
};

// node_modules/@yamada-ui/image/dist/chunk-MGTKMA54.mjs
var import_react102 = __toESM(require_react(), 1);
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var Image3 = forwardRef22((props2, ref) => {
  const [styles2, { size, ...mergedProps }] = useComponentStyle("Image", props2);
  let {
    boxSize,
    fit: objectFit,
    fallback,
    src,
    srcSet,
    loading,
    ignoreFallback,
    crossOrigin,
    className,
    fallbackStrategy = "beforeLoadOrError",
    onError,
    onLoad,
    referrerPolicy,
    ...rest
  } = omitThemeProps(mergedProps);
  boxSize != null ? boxSize : boxSize = size;
  ignoreFallback = loading != null || ignoreFallback || !fallback;
  const css4 = (0, import_react102.useMemo)(
    () => ({ ...styles2, boxSize, objectFit }),
    [styles2, boxSize, objectFit]
  );
  const status = useImage({ ...props2, ignoreFallback });
  const isFallbackImage = shouldShowFallbackImage(status, fallbackStrategy);
  if (isFallbackImage) {
    if ((0, import_react102.isValidElement)(fallback)) {
      return fallback;
    } else {
      return (0, import_jsx_runtime68.jsx)(
        ui.img,
        {
          ref,
          className: cx("ui-image--fallback", className),
          src: fallback,
          __css: css4,
          ...ignoreFallback ? { ...rest, onError, onLoad } : rest
        }
      );
    }
  }
  return (0, import_jsx_runtime68.jsx)(
    ui.img,
    {
      ref,
      src,
      srcSet,
      crossOrigin,
      loading,
      referrerPolicy,
      className: cx("ui-image", className),
      __css: css4,
      ...ignoreFallback ? rest : omitObject(rest, ["onError", "onLoad"])
    }
  );
});

// node_modules/@yamada-ui/image/dist/chunk-SZNXEYZU.mjs
var NativeImage = ui("img", {
  disableStyleProp: (prop) => ["width", "height"].includes(prop)
});

// node_modules/@yamada-ui/input/dist/chunk-PFAPK5JD.mjs
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var Input2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Input", props2);
  let { className, htmlSize, __css, ...rest } = omitThemeProps(mergedProps);
  rest = useFormControlProps(rest);
  const css4 = { ...styles2.field, ...__css };
  return (0, import_jsx_runtime69.jsx)(
    ui.input,
    {
      ref,
      className: cx("ui-input", className),
      size: htmlSize,
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/file-input/dist/chunk-CJCNFVMX.mjs
var import_react103 = __toESM(require_react(), 1);
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var defaultFormat = ({ name }) => name;
var FileInput2 = forwardRef22(
  ({ children, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("FileInput", props2);
    const {
      className,
      id: id4,
      name,
      accept,
      multiple,
      form,
      placeholder,
      value,
      defaultValue,
      component,
      format = defaultFormat,
      lineClamp = 1,
      separator = ",",
      resetRef,
      "aria-readonly": ariaReadonly,
      onChange: onChangeProp,
      onClick: onClickProp,
      ...rest
    } = useFormControlProps(omitThemeProps(mergedProps));
    const { disabled, readOnly } = rest;
    const inputRef = (0, import_react103.useRef)(null);
    const [values, setValues2] = useControllableState({
      value,
      defaultValue,
      onChange: onChangeProp
    });
    const onClick2 = (0, import_react103.useCallback)(() => {
      var _a;
      if (disabled || readOnly) return;
      (_a = inputRef.current) == null ? void 0 : _a.click();
    }, [disabled, readOnly]);
    const onChange = (0, import_react103.useCallback)(
      (ev) => {
        let files = !isNull(ev.currentTarget.files) ? Array.from(ev.currentTarget.files) : void 0;
        if (!(files == null ? void 0 : files.length)) files = void 0;
        setValues2(files);
      },
      [setValues2]
    );
    const onReset = (0, import_react103.useCallback)(() => {
      if (inputRef.current) inputRef.current.value = "";
      setValues2(void 0);
    }, [setValues2]);
    assignRef(resetRef, onReset);
    const cloneChildren = (0, import_react103.useMemo)(() => {
      if (!(values == null ? void 0 : values.length))
        return (0, import_jsx_runtime70.jsx)(ui.span, { lineClamp, children: placeholder });
      if (children) return children(values);
      if (component) {
        return (0, import_jsx_runtime70.jsx)(ui.span, { lineClamp, children: values.map((value2, index) => {
          const el = component({ value: value2, index });
          const style = {
            marginBlockStart: "0.125rem",
            marginBlockEnd: "0.125rem",
            marginInlineEnd: "0.25rem"
          };
          return el ? (0, import_react103.cloneElement)(el, { style, key: index }) : null;
        }) });
      } else {
        return (0, import_jsx_runtime70.jsx)(ui.span, { lineClamp, children: values.map((value2, index) => {
          const isLast = values.length === index + 1;
          return (0, import_jsx_runtime70.jsxs)(ui.span, { display: "inline-block", me: "0.25rem", children: [
            format(value2, index),
            !isLast ? separator : null
          ] }, index);
        }) });
      }
    }, [children, format, lineClamp, placeholder, separator, component, values]);
    const css4 = {
      display: "flex",
      alignItems: "center",
      cursor: !readOnly ? "pointer" : "auto",
      ...styles2.field
    };
    return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, { children: [
      (0, import_jsx_runtime70.jsx)(
        ui.input,
        {
          ref: mergeRefs(inputRef, ref),
          type: "file",
          "aria-hidden": true,
          tabIndex: -1,
          id: id4,
          name,
          form,
          accept,
          multiple,
          style: {
            border: "0px",
            clip: "rect(0px, 0px, 0px, 0px)",
            height: "1px",
            width: "1px",
            margin: "-1px",
            padding: "0px",
            overflow: "hidden",
            whiteSpace: "nowrap",
            position: "absolute"
          },
          onChange,
          "aria-readonly": ariaReadonly,
          ...pickObject(rest, formControlProperties)
        }
      ),
      (0, import_jsx_runtime70.jsx)(
        ui.div,
        {
          ref,
          className: cx("ui-file-input", className),
          py: (values == null ? void 0 : values.length) && component ? "0.125rem" : void 0,
          ...rest,
          __css: css4,
          tabIndex: 0,
          "data-placeholder": dataAttr(!(values == null ? void 0 : values.length)),
          onClick: handlerAll(onClickProp, onClick2),
          children: cloneChildren
        }
      )
    ] });
  }
);

// node_modules/@yamada-ui/input/dist/chunk-OCJVHG24.mjs
var import_react104 = __toESM(require_react(), 1);
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var InputAddon = forwardRef22(
  ({ className, placement = "left", ...rest }, ref) => {
    const styles2 = useInputGroup();
    const placementStyles2 = {
      left: {
        me: "-1px",
        roundedRight: 0,
        borderEndColor: "transparent"
      },
      right: {
        ms: "-1px",
        roundedLeft: 0,
        borderStartColor: "transparent"
      }
    };
    const css4 = {
      flex: "0 0 auto",
      w: "auto",
      display: "flex",
      alignItems: "center",
      whiteSpace: "nowrap",
      ...styles2.addon,
      ...placementStyles2[placement]
    };
    return (0, import_jsx_runtime71.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-input__addon", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var InputLeftAddon = forwardRef22(
  ({ className, ...rest }, ref) => {
    return (0, import_jsx_runtime71.jsx)(
      InputAddon,
      {
        ref,
        className: cx("ui-input__addon--left", className),
        placement: "left",
        ...rest
      }
    );
  }
);
var InputRightAddon = forwardRef22(
  ({ className, ...rest }, ref) => {
    return (0, import_jsx_runtime71.jsx)(
      InputAddon,
      {
        ref,
        className: cx("ui-input__addon--right", className),
        placement: "right",
        ...rest
      }
    );
  }
);
var InputElement = forwardRef22(
  ({ className, isClick = false, placement = "left", ...rest }, ref) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const styles2 = useInputGroup();
    const css4 = {
      position: "absolute",
      top: "0",
      [placement === "left" ? "insetStart" : "insetEnd"]: "0",
      zIndex: "fallback(kurillin, 9)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      w: (_g = (_e = (_c = (_a = styles2.field) == null ? void 0 : _a.height) != null ? _c : (_b = styles2.field) == null ? void 0 : _b.h) != null ? _e : (_d = styles2.field) == null ? void 0 : _d.minHeight) != null ? _g : (_f = styles2.field) == null ? void 0 : _f.minH,
      h: "100%",
      fontSize: (_h = styles2.field) == null ? void 0 : _h.fontSize,
      pointerEvents: isClick ? "auto" : "none",
      cursor: isClick ? "pointer" : "auto",
      ...styles2.element
    };
    return (0, import_jsx_runtime72.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-input__element", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var InputLeftElement = forwardRef22(
  ({ className, ...rest }, ref) => {
    return (0, import_jsx_runtime72.jsx)(
      InputElement,
      {
        ref,
        className: cx("ui-input__element--left", className),
        placement: "left",
        ...rest
      }
    );
  }
);
var InputRightElement = forwardRef22(
  ({ className, ...rest }, ref) => {
    return (0, import_jsx_runtime72.jsx)(
      InputElement,
      {
        ref,
        className: cx("ui-input__element--right", className),
        placement: "right",
        ...rest
      }
    );
  }
);
var [InputGroupProvider, useInputGroup] = createContext2({
  name: "InputGroupContext",
  errorMessage: `useInputGroup returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
});
var InputGroup = forwardRef22((props2, ref) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const [styles2] = useMultiComponentStyle("Input", props2);
  const { className, children, ...rest } = omitThemeProps(props2);
  const css4 = {
    width: "100%",
    display: "flex",
    position: "relative",
    ...styles2.container
  };
  const groupProps = {};
  const minHeight = (_g = (_e = useToken("sizes", (_c = (_a = styles2.field) == null ? void 0 : _a.minHeight) != null ? _c : (_b = styles2.field) == null ? void 0 : _b.minH)) != null ? _e : (_d = styles2.field) == null ? void 0 : _d.minHeight) != null ? _g : (_f = styles2.field) == null ? void 0 : _f.minH;
  const height = (_n = (_l = useToken("sizes", (_j = (_h = styles2.field) == null ? void 0 : _h.height) != null ? _j : (_i = styles2.field) == null ? void 0 : _i.h)) != null ? _l : (_k = styles2.field) == null ? void 0 : _k.height) != null ? _n : (_m = styles2.field) == null ? void 0 : _m.h;
  const validChildren = getValidChildren(children);
  validChildren.forEach((child) => {
    if ((minHeight || height) && child.type === InputLeftElement)
      groupProps.paddingStart = height != null ? height : minHeight;
    if ((minHeight || height) && child.type === InputRightElement)
      groupProps.paddingEnd = height != null ? height : minHeight;
    if (child.type === InputLeftAddon) groupProps.roundedLeft = 0;
    if (child.type === InputRightAddon) groupProps.roundedRight = 0;
  });
  const cloneChildren = validChildren.map((child) => {
    var _a2, _b2;
    const childProps = filterUndefined({
      size: ((_a2 = child.props) == null ? void 0 : _a2.size) || props2.size,
      variant: ((_b2 = child.props) == null ? void 0 : _b2.variant) || props2.variant,
      ...child.props
    });
    return child.type !== Input2 && child.type !== FileInput2 ? (0, import_react104.cloneElement)(child, childProps) : (0, import_react104.cloneElement)(child, Object.assign(childProps, groupProps));
  });
  return (0, import_jsx_runtime73.jsx)(InputGroupProvider, { value: styles2, children: (0, import_jsx_runtime73.jsx)(
    ui.div,
    {
      ref,
      className: cx("ui-input-group", className),
      role: "group",
      __css: css4,
      ...rest,
      children: cloneChildren
    }
  ) });
});

// node_modules/@yamada-ui/kbd/dist/chunk-YGTU56QY.mjs
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var Kbd2 = forwardRef22((props2, ref) => {
  const [css4, mergedProps] = useComponentStyle("Kbd", props2);
  const { className, ...rest } = omitThemeProps(mergedProps);
  return (0, import_jsx_runtime74.jsx)(
    ui.kbd,
    {
      ref,
      className: cx("ui-kbd", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/link/dist/chunk-6VXZCMHN.mjs
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var LinkOverlay = forwardRef22(
  ({ className, isExternal, target, rel, href, children, ...rest }, ref) => {
    const css4 = {
      position: "static",
      _before: {
        content: '""',
        cursor: "inherit",
        display: "block",
        position: "absolute",
        top: 0,
        left: 0,
        zIndex: 0,
        width: "100%",
        height: "100%"
      }
    };
    return (0, import_jsx_runtime75.jsx)(
      ui.a,
      {
        ref,
        target: isExternal ? "_blank" : target,
        rel: isExternal ? "noopener" : rel,
        className: cx("ui-link-box__overlay", className),
        href,
        __css: css4,
        ...rest,
        children
      }
    );
  }
);
var LinkBox = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("LinkBox", props2);
  const { className, children, ...rest } = omitThemeProps(mergedProps);
  const css4 = {
    "a[href]:not(.ui-link-box__overlay), abbr[title]": {
      position: "relative",
      zIndex: "fallback(yamcha, 1)"
    },
    ...styles2
  };
  return (0, import_jsx_runtime75.jsx)(
    ui.div,
    {
      ref,
      className: cx("ui-link-box", className),
      __css: css4,
      position: "relative",
      ...rest,
      children
    }
  );
});

// node_modules/@yamada-ui/link/dist/chunk-QH3AF7BW.mjs
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var Link2 = forwardRef22((props2, ref) => {
  const [css4, mergedProps] = useComponentStyle("Link", props2);
  const { className, isExternal, ...rest } = omitThemeProps(mergedProps);
  return (0, import_jsx_runtime76.jsx)(
    ui.a,
    {
      ref,
      target: isExternal ? "_blank" : void 0,
      rel: isExternal ? "noopener" : void 0,
      className: cx("ui-link", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/list/dist/chunk-ASAFATJ4.mjs
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var [ListProvider, useList] = createContext2({
  name: `ListContext`,
  errorMessage: `useList returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
});
var List2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("List", props2);
  const {
    className,
    children,
    styleType: listStyleType = "none",
    stylePosition: listStylePosition,
    gap = "fallback(2, 0.5rem)",
    ...rest
  } = omitThemeProps(mergedProps);
  const validChildren = getValidChildren(children);
  const css4 = {
    display: "flex",
    flexDirection: "column",
    gap,
    ms: listStyleType !== "none" ? "1.4em" : void 0,
    "& > li": { ps: listStyleType === "decimal" ? "0.3em" : void 0 },
    ...styles2.container
  };
  return (0, import_jsx_runtime77.jsx)(ListProvider, { value: styles2, children: (0, import_jsx_runtime77.jsx)(
    ui.ul,
    {
      ref,
      listStyleType,
      listStylePosition,
      role: "list",
      className: cx("ui-list", className),
      __css: css4,
      ...rest,
      children: validChildren
    }
  ) });
});
var DiscList = forwardRef22(({ ...rest }, ref) => {
  return (0, import_jsx_runtime77.jsx)(List2, { ref, as: "ul", styleType: "disc", ...rest });
});
var DecimalList = forwardRef22(({ ...rest }, ref) => {
  return (0, import_jsx_runtime77.jsx)(List2, { ref, as: "ol", styleType: "decimal", ms: "1.2em", ...rest });
});
var ListItem = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useList();
    const css4 = { ...styles2.item };
    return (0, import_jsx_runtime77.jsx)(
      ui.li,
      {
        ref,
        className: cx("ui-list-item", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var ListIcon = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useList();
    const css4 = { ...styles2.icon };
    return (0, import_jsx_runtime77.jsx)(
      Icon,
      {
        ref,
        className: cx("ui-list-icon", className),
        role: "presentation",
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/use-clickable/dist/index.mjs
var import_react105 = __toESM(require_react(), 1);
var isValidElement6 = (ev) => {
  const { tagName, isContentEditable: isContentEditable2 } = ev.target;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable2 !== true;
};
var useClickable = ({
  ref,
  isDisabled: isDisabled2,
  isFocusable: isFocusable2,
  clickOnEnter = true,
  clickOnSpace = true,
  focusOnClick = true,
  disableTouchBehavior = true,
  onMouseDown,
  onMouseUp,
  onClick: onClick2,
  onKeyDown,
  onKeyUp,
  tabIndex: _tabIndex,
  onMouseOver,
  onMouseLeave,
  ...props2
} = {}) => {
  const [isButton, setIsButton] = (0, import_react105.useState)(true);
  const [isPressed, setIsPressed] = (0, import_react105.useState)(false);
  const listeners = useEventListeners();
  const tabIndex = isButton ? _tabIndex : _tabIndex || 0;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  const refCb = (node3) => {
    if (!node3) return;
    if (node3.tagName !== "BUTTON") setIsButton(false);
  };
  const handleClick = (0, import_react105.useCallback)(
    (ev) => {
      if (isDisabled2) {
        ev.stopPropagation();
        ev.preventDefault();
        return;
      }
      if (focusOnClick) ev.currentTarget.focus();
      onClick2 == null ? void 0 : onClick2(ev);
    },
    [isDisabled2, focusOnClick, onClick2]
  );
  const onDocumentKeyUp = (0, import_react105.useCallback)(
    (ev) => {
      if (isPressed && isValidElement6(ev)) {
        ev.preventDefault();
        ev.stopPropagation();
        setIsPressed(false);
        listeners.remove(document, "keyup", onDocumentKeyUp, false);
      }
    },
    [isPressed, listeners]
  );
  const handleKeyDown = (0, import_react105.useCallback)(
    (ev) => {
      onKeyDown == null ? void 0 : onKeyDown(ev);
      if (isDisabled2 || ev.defaultPrevented || ev.metaKey) return;
      if (!isValidElement6(ev.nativeEvent) || isButton) return;
      if (clickOnSpace && ev.key === " ") {
        ev.preventDefault();
        setIsPressed(true);
      }
      if (clickOnEnter && ev.key === "Enter") {
        ev.preventDefault();
        ev.currentTarget.click();
      }
      listeners.add(document, "keyup", onDocumentKeyUp, false);
    },
    [
      isDisabled2,
      isButton,
      onKeyDown,
      clickOnEnter,
      clickOnSpace,
      listeners,
      onDocumentKeyUp
    ]
  );
  const handleKeyUp = (0, import_react105.useCallback)(
    (ev) => {
      onKeyUp == null ? void 0 : onKeyUp(ev);
      if (isDisabled2 || ev.defaultPrevented || ev.metaKey) return;
      if (!isValidElement6(ev.nativeEvent) || isButton) return;
      if (clickOnSpace && ev.key === " ") {
        ev.preventDefault();
        setIsPressed(false);
        ev.currentTarget.click();
      }
    },
    [clickOnSpace, isButton, isDisabled2, onKeyUp]
  );
  const onDocumentMouseUp = (0, import_react105.useCallback)(
    (ev) => {
      if (ev.button !== 0) return;
      setIsPressed(false);
      listeners.remove(document, "mouseup", onDocumentMouseUp, false);
    },
    [listeners]
  );
  const handleMouseDown = (0, import_react105.useCallback)(
    (ev) => {
      if (ev.button !== 0) return;
      if (isDisabled2) {
        ev.stopPropagation();
        ev.preventDefault();
        return;
      }
      if (!isButton) setIsPressed(true);
      ev.currentTarget.focus({ preventScroll: true });
      listeners.add(document, "mouseup", onDocumentMouseUp, false);
      onMouseDown == null ? void 0 : onMouseDown(ev);
    },
    [isDisabled2, isButton, onMouseDown, listeners, onDocumentMouseUp]
  );
  const handleMouseUp = (0, import_react105.useCallback)(
    (ev) => {
      if (ev.button !== 0) return;
      if (!isButton) setIsPressed(false);
      onMouseUp == null ? void 0 : onMouseUp(ev);
    },
    [onMouseUp, isButton]
  );
  const handleMouseOver = (0, import_react105.useCallback)(
    (ev) => {
      if (isDisabled2) {
        ev.preventDefault();
        return;
      }
      if (disableTouchBehavior && isTouchDevice()) return;
      onMouseOver == null ? void 0 : onMouseOver(ev);
    },
    [isDisabled2, onMouseOver, disableTouchBehavior]
  );
  const handleMouseLeave = (0, import_react105.useCallback)(
    (ev) => {
      if (isPressed) {
        ev.preventDefault();
        setIsPressed(false);
      }
      if (disableTouchBehavior && isTouchDevice()) return;
      onMouseLeave == null ? void 0 : onMouseLeave(ev);
    },
    [isPressed, onMouseLeave, disableTouchBehavior]
  );
  if (isButton) {
    return {
      ...props2,
      ref: mergeRefs(ref, refCb),
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled2,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  } else {
    return {
      ...props2,
      ref: mergeRefs(ref, refCb),
      role: "button",
      "data-active": dataAttr(isPressed),
      "aria-disabled": isDisabled2 ? "true" : void 0,
      tabIndex: trulyDisabled ? void 0 : tabIndex,
      onClick: handleClick,
      onMouseDown: handleMouseDown,
      onMouseUp: handleMouseUp,
      onKeyUp: handleKeyUp,
      onKeyDown: handleKeyDown,
      onMouseOver: handleMouseOver,
      onMouseLeave: handleMouseLeave
    };
  }
};

// node_modules/@yamada-ui/menu/dist/chunk-6IPLI42Z.mjs
var import_react113 = __toESM(require_react(), 1);

// node_modules/@yamada-ui/use-boolean/dist/index.mjs
var import_react106 = __toESM(require_react(), 1);
var useBoolean = (init = false) => {
  const [flg, setFlg] = (0, import_react106.useState)(init);
  const on = (0, import_react106.useCallback)(() => setFlg(true), []);
  const off = (0, import_react106.useCallback)(() => setFlg(false), []);
  const toggle = (0, import_react106.useCallback)(() => setFlg((prev2) => !prev2), []);
  return [flg, { on, off, toggle }];
};

// node_modules/@yamada-ui/use-animation/dist/index.mjs
var import_react107 = __toESM(require_react(), 1);
var useAnimation2 = (styles2) => {
  const { theme } = useTheme2();
  if (isArray(styles2)) {
    return styles2.map((style) => animation(style, theme, css3)).join(", ");
  } else {
    return animation(styles2, theme, css3);
  }
};
var useDynamicAnimation = (arrayOrObj, init) => {
  const { theme } = useTheme2();
  const keys2 = (0, import_react107.useRef)(
    !isUndefined(init) ? isArray(init) ? init.map(String) : String(init) : void 0
  );
  const cache2 = (0, import_react107.useRef)(/* @__PURE__ */ new Map());
  const [animations3, setAnimations] = (0, import_react107.useState)(() => {
    var _a;
    for (const [key, styles2] of Object.entries(arrayOrObj)) {
      if (cache2.current.has(key)) return;
      if (isArray(styles2)) {
        cache2.current.set(
          key,
          styles2.map((style) => animation(style, theme, css3)).join(", ")
        );
      } else {
        cache2.current.set(key, animation(styles2, theme, css3));
      }
    }
    if (isArray(keys2.current)) {
      return keys2.current.map((key) => cache2.current.get(key)).join(", ");
    } else {
      return cache2.current.get((_a = keys2.current) != null ? _a : "");
    }
  });
  const setAnimation = (0, import_react107.useCallback)(
    (keysOrFunc) => {
      var _a;
      const args = (() => {
        if (!isUndefined(keys2.current) && isArray(arrayOrObj)) {
          return isArray(keys2.current) ? keys2.current.map(Number) : Number(keys2.current);
        } else {
          return keys2.current;
        }
      })();
      const keyOrArray = runIfFunc(keysOrFunc, args);
      keys2.current = isArray(keyOrArray) ? keyOrArray.map(String) : String(keyOrArray);
      if (isArray(keys2.current)) {
        setAnimations(
          keys2.current.map((key) => cache2.current.get(key)).join(", ")
        );
      } else {
        setAnimations(cache2.current.get((_a = keys2.current) != null ? _a : ""));
      }
    },
    [arrayOrObj]
  );
  return [animations3, setAnimation];
};
var useAnimationObserver = ({
  isOpen,
  ref
}) => {
  const [mounted, setMounted] = (0, import_react107.useState)(isOpen);
  const [flg, { on }] = useBoolean();
  (0, import_react107.useEffect)(() => {
    if (flg) return;
    setMounted(isOpen);
    on();
  }, [isOpen, flg, on]);
  useEventListener(
    () => ref.current,
    "animationend",
    () => setMounted(isOpen)
  );
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onAnimationComplete() {
      var _a;
      const ownerWindow = getOwnerWindow(ref.current);
      const ev = new ownerWindow.CustomEvent("animationend", {
        bubbles: true
      });
      (_a = ref.current) == null ? void 0 : _a.dispatchEvent(ev);
    }
  };
};

// node_modules/@yamada-ui/use-disclosure/dist/index.mjs
var import_react108 = __toESM(require_react(), 1);
var useDisclosure = (props2 = {}) => {
  var _a, _b;
  const [defaultIsOpen, setIsOpen] = (0, import_react108.useState)(
    (_a = props2.defaultIsOpen) != null ? _a : false
  );
  const timingRef = (0, import_react108.useRef)((_b = props2.timing) != null ? _b : "after");
  const handleOpen = useCallbackRef(props2.onOpen);
  const handleClose = useCallbackRef(props2.onClose);
  const isControlled = props2.isOpen !== void 0;
  const isOpen = props2.isOpen !== void 0 ? props2.isOpen : defaultIsOpen;
  const onOpen = (0, import_react108.useCallback)(
    async (...args) => {
      if (timingRef.current === "before") await (handleOpen == null ? void 0 : handleOpen(...args));
      if (!isControlled) setIsOpen(true);
      if (timingRef.current === "after") await (handleOpen == null ? void 0 : handleOpen(...args));
    },
    [isControlled, handleOpen, timingRef]
  );
  const onClose = (0, import_react108.useCallback)(
    async (...args) => {
      if (timingRef.current === "before") await (handleClose == null ? void 0 : handleClose(...args));
      if (!isControlled) setIsOpen(false);
      if (timingRef.current === "after") await (handleClose == null ? void 0 : handleClose(...args));
    },
    [isControlled, handleClose, timingRef]
  );
  const onToggle = (0, import_react108.useCallback)(
    (...args) => !isOpen ? onOpen(...args) : onClose(...args),
    [isOpen, onOpen, onClose]
  );
  return { isOpen, onOpen, onClose, onToggle };
};
var useLazyDisclosure = ({
  wasSelected,
  enabled: enabled2,
  isSelected,
  mode: mode2 = "unmount"
}) => {
  if (!enabled2) return true;
  if (isSelected) return true;
  if (mode2 === "keepMounted" && wasSelected) return true;
  return false;
};

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto2 = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto2]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node3) {
  if (node3 == null) {
    return window;
  }
  if (node3.toString() !== "[object Window]") {
    var ownerDocument = node3.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node3;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement2(node3) {
  var OwnElement = getWindow(node3).Element;
  return node3 instanceof OwnElement || node3 instanceof Element;
}
function isHTMLElement2(node3) {
  var OwnElement = getWindow(node3).HTMLElement;
  return node3 instanceof OwnElement || node3 instanceof HTMLElement;
}
function isShadowRoot(node3) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node3).ShadowRoot;
  return node3 instanceof OwnElement || node3 instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref2) {
  var state = _ref2.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement2(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties2 = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties2.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement2(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement2(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref2 = isElement2(element) ? getWindow(element) : window, visualViewport = _ref2.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains2(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle3(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode2(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement2(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle3(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement2(element)) {
    var elementCss = getComputedStyle3(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode2(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement2(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css4 = getComputedStyle3(currentNode);
    if (css4.transform !== "none" || css4.perspective !== "none" || css4.contain === "paint" || ["transform", "perspective"].indexOf(css4.willChange) !== -1 || isFirefox && css4.willChange === "filter" || isFirefox && css4.filter && css4.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref2) {
  var _state$modifiersData$;
  var state = _ref2.state, name = _ref2.name, options = _ref2.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains2(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref2, win) {
  var x = _ref2.x, y = _ref2.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle3(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref2) {
  var state = _ref2.state, instance = _ref2.instance, options = _ref2.options;
  var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize2 = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize2) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize2) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash4 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash4[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node3) {
  var win = getWindow(node3);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle3(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node3) {
  if (["html", "body", "#document"].indexOf(getNodeName(node3)) >= 0) {
    return node3.ownerDocument.body;
  }
  if (isHTMLElement2(node3) && isScrollParent(node3)) {
    return node3;
  }
  return getScrollParent(getParentNode2(node3));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode2(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode2(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement2(element) ? getOffsetParent(element) : element;
  if (!isElement2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement2(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref2) {
  var reference2 = _ref2.reference, element = _ref2.element, placement = _ref2.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply2 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply2;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto2) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto2 ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref2[0], distance3 = _ref2[1];
  skidding = skidding || 0;
  distance3 = (distance3 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance3,
    y: skidding
  } : {
    x: skidding,
    y: distance3
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node3) {
  if (node3 === getWindow(node3) || !isHTMLElement2(node3)) {
    return getWindowScroll(node3);
  } else {
    return getHTMLElementScroll(node3);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement2(offsetParent);
  var offsetParentIsScaled = isHTMLElement2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref2) {
        var name = _ref2.name, _ref$options = _ref2.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref2.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@yamada-ui/use-popper/dist/index.mjs
var import_react109 = __toESM(require_react(), 1);
var popperProperties = [
  "enabled",
  "offset",
  "gutter",
  "preventOverflow",
  "flip",
  "matchWidth",
  "boundary",
  "eventListeners",
  "strategy",
  "placement",
  "modifiers"
];
var defaultEventListeners = {
  scroll: true,
  resize: true
};
var transforms2 = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var usePopper = ({
  enabled: enabled2 = true,
  eventListeners = true,
  matchWidth,
  offset: offset2,
  gutter: _gutter = 8,
  flip: flip2 = true,
  preventOverflow: preventOverflow2 = true,
  boundary = "clippingParents",
  strategy = "absolute",
  placement: _placement = "bottom",
  modifiers
} = {}) => {
  const reference2 = (0, import_react109.useRef)(null);
  const popper2 = (0, import_react109.useRef)(null);
  const instance = (0, import_react109.useRef)(null);
  const gutter = useValue(_gutter);
  const placement = useValue(_placement);
  const cleanup = (0, import_react109.useRef)(() => {
  });
  const setupPopper = (0, import_react109.useCallback)(() => {
    var _a;
    if (!enabled2 || !reference2.current || !popper2.current) return;
    (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
    const modifierTransformOrigin = {
      name: "transformOrigin",
      enabled: true,
      phase: "write",
      fn: ({ state }) => {
        state.elements.popper.style.setProperty(
          "--popper-transform-origin",
          transforms2[state.placement]
        );
      },
      effect: ({ state }) => () => {
        state.elements.popper.style.setProperty(
          "--popper-transform-origin",
          transforms2[state.placement]
        );
      }
    };
    const modifierEventListeners = {
      name: "eventListeners",
      ...typeof eventListeners === "object" ? {
        enabled: true,
        options: { ...defaultEventListeners, ...eventListeners }
      } : {
        enabled: eventListeners,
        options: defaultEventListeners
      }
    };
    const modifierOffset = {
      name: "offset",
      options: { offset: offset2 != null ? offset2 : [0, gutter] }
    };
    const modifierFlip = {
      name: "flip",
      enabled: !!flip2,
      options: { padding: 8 }
    };
    const modifierPreventOverflow = {
      name: "preventOverflow",
      enabled: !!preventOverflow2,
      options: { boundary }
    };
    const modifierMatchWidth = {
      name: "matchWidth",
      enabled: !!matchWidth,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: ({ state }) => {
        state.styles.popper.width = `${state.rects.reference.width}px`;
      },
      effect: ({ state }) => () => {
        state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
      }
    };
    instance.current = createPopper3(reference2.current, popper2.current, {
      placement,
      modifiers: [
        modifierTransformOrigin,
        modifierMatchWidth,
        modifierEventListeners,
        modifierOffset,
        modifierFlip,
        modifierPreventOverflow,
        ...modifiers != null ? modifiers : []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled2,
    modifiers,
    matchWidth,
    eventListeners,
    offset2,
    gutter,
    flip2,
    preventOverflow2,
    boundary,
    strategy
  ]);
  (0, import_react109.useEffect)(() => {
    return () => {
      var _a;
      if (reference2.current || popper2.current) return;
      (_a = instance.current) == null ? void 0 : _a.destroy();
      instance.current = null;
    };
  }, []);
  const referenceRef = (0, import_react109.useCallback)(
    (el) => {
      reference2.current = el;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = (0, import_react109.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = (0, import_react109.useCallback)(
    (el) => {
      popper2.current = el;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = (0, import_react109.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props2.style,
        position: strategy,
        minWidth: matchWidth ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth]
  );
  return {
    update: () => {
      var _a;
      return (_a = instance.current) == null ? void 0 : _a.update();
    },
    forceUpdate: () => {
      var _a;
      return (_a = instance.current) == null ? void 0 : _a.forceUpdate();
    },
    transformOrigin: "var(--popper-transform-origin)",
    referenceRef,
    popperRef,
    getPopperProps,
    getReferenceProps
  };
};

// node_modules/@yamada-ui/popover/dist/chunk-JKVDCAGZ.mjs
var import_react110 = __toESM(require_react(), 1);
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var popoverProperties = [
  ...popperProperties,
  "isOpen",
  "defaultIsOpen",
  "onOpen",
  "onClose",
  "initialFocusRef",
  "restoreFocus",
  "autoFocus",
  "closeOnBlur",
  "closeOnEsc",
  "closeOnButton",
  "trigger",
  "openDelay",
  "closeDelay",
  "isLazy",
  "lazyBehavior",
  "animation",
  "duration"
];
var [PopoverProvider, usePopover] = createContext2({
  strict: false,
  name: "PopoverContext"
});
var Popover2 = (props2) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Popover", props2);
  const {
    children,
    initialFocusRef,
    restoreFocus = true,
    autoFocus = true,
    closeOnBlur = true,
    closeOnEsc = true,
    closeOnButton = true,
    trigger: trigger2 = "click",
    openDelay = 200,
    closeDelay = 200,
    isLazy,
    lazyBehavior = "unmount",
    animation: animation2 = "scale",
    duration,
    relatedRef,
    ...rest
  } = omitThemeProps(mergedProps);
  const { isOpen, onOpen, onClose, onToggle } = useDisclosure(mergedProps);
  const anchorRef = (0, import_react110.useRef)(null);
  const triggerRef = (0, import_react110.useRef)(null);
  const popoverRef = (0, import_react110.useRef)(null);
  const { present, onAnimationComplete } = useAnimationObserver({
    isOpen,
    ref: popoverRef
  });
  const openTimeout = (0, import_react110.useRef)(void 0);
  const closeTimeout = (0, import_react110.useRef)(void 0);
  const isHoveringRef = (0, import_react110.useRef)(false);
  const hasBeenOpened = (0, import_react110.useRef)(false);
  if (isOpen) hasBeenOpened.current = true;
  const { referenceRef, getPopperProps, forceUpdate, transformOrigin } = usePopper({
    ...rest,
    enabled: isOpen
  });
  (0, import_react110.useEffect)(() => {
    return () => {
      if (openTimeout.current) clearTimeout(openTimeout.current);
      if (closeTimeout.current) clearTimeout(closeTimeout.current);
    };
  }, []);
  useFocusOnPointerDown({
    enabled: isOpen,
    ref: triggerRef
  });
  useFocusOnHide(popoverRef, {
    focusRef: triggerRef,
    visible: isOpen,
    shouldFocus: restoreFocus && (trigger2 === "click" || trigger2 === "contextmenu")
  });
  useFocusOnShow(popoverRef, {
    focusRef: initialFocusRef,
    visible: isOpen,
    shouldFocus: autoFocus && (trigger2 === "click" || trigger2 === "contextmenu")
  });
  const shouldRenderChildren = useLazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: present
  });
  const getPopoverProps = (0, import_react110.useCallback)(
    (props22 = {}, ref = null) => {
      const popoverProps = {
        ...props22,
        style: {
          ...props22.style,
          transformOrigin
        },
        ref: mergeRefs(popoverRef, ref),
        children: shouldRenderChildren ? props22.children : null,
        tabIndex: -1,
        onKeyDown: handlerAll(props22.onKeyDown, (ev) => {
          if (closeOnEsc && ev.key === "Escape") onClose();
        }),
        onBlur: handlerAll(props22.onBlur, (ev) => {
          const relatedTarget = getEventRelatedTarget(ev);
          const targetIsPopover = isContains(popoverRef.current, relatedTarget);
          const targetIsTrigger = isContains(triggerRef.current, relatedTarget);
          const targetIsRelated = (relatedRef == null ? void 0 : relatedRef.current) ? isContains(relatedRef.current, relatedTarget) : false;
          const isValidBlur = !targetIsPopover && !targetIsTrigger && !targetIsRelated;
          if (isOpen && closeOnBlur && isValidBlur) onClose();
        })
      };
      if (trigger2 === "hover") {
        popoverProps.onMouseEnter = handlerAll(props22.onMouseEnter, () => {
          isHoveringRef.current = true;
        });
        popoverProps.onMouseLeave = handlerAll(props22.onMouseLeave, (ev) => {
          if (ev.nativeEvent.relatedTarget === null) return;
          isHoveringRef.current = false;
          if (closeOnBlur) setTimeout(onClose, closeDelay);
        });
      }
      return popoverProps;
    },
    [
      closeDelay,
      closeOnBlur,
      closeOnEsc,
      isOpen,
      onClose,
      shouldRenderChildren,
      transformOrigin,
      trigger2,
      relatedRef
    ]
  );
  const maybeReferenceRef = (0, import_react110.useCallback)(
    (node3) => {
      if (anchorRef.current == null) referenceRef(node3);
    },
    [referenceRef]
  );
  const getTriggerProps = (0, import_react110.useCallback)(
    (props22 = {}, ref = null) => {
      const triggerProps = {
        ...props22,
        ref: mergeRefs(triggerRef, ref, maybeReferenceRef)
      };
      if (trigger2 === "click") {
        triggerProps.onClick = handlerAll(props22.onClick, onToggle);
        triggerProps.onBlur = handlerAll(props22.onBlur, (ev) => {
          const relatedTarget = getEventRelatedTarget(ev);
          const isValidBlur = !isContains(popoverRef.current, relatedTarget);
          if (isOpen && closeOnBlur && isValidBlur) onClose();
        });
      }
      if (trigger2 === "contextmenu") {
        triggerProps.onContextMenu = handlerAll(props22.onContextMenu, (ev) => {
          ev.preventDefault();
          onOpen();
        });
        triggerProps.onBlur = handlerAll(props22.onBlur, (ev) => {
          const relatedTarget = getEventRelatedTarget(ev);
          const isValidBlur = !isContains(popoverRef.current, relatedTarget);
          if (isOpen && closeOnBlur && isValidBlur) onClose();
        });
      }
      if (trigger2 === "hover") {
        triggerProps.onFocus = handlerAll(props22.onFocus, () => {
          if (openTimeout.current === void 0) onOpen();
        });
        triggerProps.onBlur = handlerAll(props22.onBlur, (ev) => {
          const relatedTarget = getEventRelatedTarget(ev);
          const isValidBlur = !isContains(popoverRef.current, relatedTarget);
          if (isOpen && closeOnBlur && isValidBlur) onClose();
        });
        triggerProps.onKeyDown = handlerAll(props22.onKeyDown, (ev) => {
          if (ev.key === "Escape") onClose();
        });
        triggerProps.onMouseEnter = handlerAll(props22.onMouseEnter, () => {
          isHoveringRef.current = true;
          openTimeout.current = window.setTimeout(onOpen, openDelay);
        });
        triggerProps.onMouseLeave = handlerAll(props22.onMouseLeave, () => {
          isHoveringRef.current = false;
          if (openTimeout.current) {
            clearTimeout(openTimeout.current);
            openTimeout.current = void 0;
          }
          closeTimeout.current = window.setTimeout(() => {
            if (!isHoveringRef.current) onClose();
          }, closeDelay);
        });
      }
      return triggerProps;
    },
    [
      closeDelay,
      closeOnBlur,
      isOpen,
      maybeReferenceRef,
      onClose,
      onOpen,
      onToggle,
      openDelay,
      trigger2
    ]
  );
  const getAnchorProps = (0, import_react110.useCallback)(
    (props22 = {}, ref = null) => {
      return {
        ...props22,
        ref: mergeRefs(ref, anchorRef, referenceRef)
      };
    },
    [anchorRef, referenceRef]
  );
  return (0, import_jsx_runtime78.jsx)(
    PopoverProvider,
    {
      value: {
        isOpen,
        onClose,
        closeOnButton,
        onAnimationComplete,
        forceUpdate,
        getTriggerProps,
        getAnchorProps,
        getPopperProps,
        getPopoverProps,
        animation: animation2,
        duration,
        styles: styles2
      },
      children: runIfFunc(children, {
        isOpen,
        onClose,
        forceUpdate
      })
    }
  );
};

// node_modules/@yamada-ui/popover/dist/chunk-QVHOMF6R.mjs
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var PopoverCloseButton = forwardRef22(
  ({ onClick: onClick2, ...rest }, ref) => {
    const { styles: styles2, onClose } = usePopover();
    const css4 = {
      position: "absolute",
      ...styles2.closeButton
    };
    return (0, import_jsx_runtime79.jsx)(
      CloseButton,
      {
        ref,
        className: cx("ui-popover__close-button"),
        __css: css4,
        onClick: handlerAll(onClick2, (ev) => {
          ev.stopPropagation();
          onClose == null ? void 0 : onClose();
        }),
        size: "sm",
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/popover/dist/chunk-42NNHREJ.mjs
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var getPopoverContentProps = (animation2 = "scale", duration) => {
  const custom = {
    reverse: true,
    duration,
    enter: { visibility: "visible" },
    transitionEnd: { exit: { visibility: "hidden" } }
  };
  switch (animation2) {
    case "scale":
      return {
        ...scaleFadeProps,
        custom: { ...custom, scale: 0.95 }
      };
    case "top":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: 0, offsetY: -16 }
      };
    case "right":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: 16, offsetY: 0 }
      };
    case "left":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: -16, offsetY: 0 }
      };
    case "bottom":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: 0, offsetY: 16 }
      };
  }
};
var PopoverContent = motionForwardRef(
  ({
    className,
    containerProps,
    children,
    w,
    width,
    minW,
    minWidth,
    z,
    zIndex,
    __css,
    ...rest
  }, ref) => {
    var _a, _b, _c, _d;
    const {
      isOpen,
      closeOnButton,
      getPopperProps,
      getPopoverProps,
      onAnimationComplete,
      animation: animation2,
      duration,
      styles: styles2
    } = usePopover();
    const validChildren = getValidChildren(children);
    const [customPopoverCloseButton, ...cloneChildren] = findChildren(
      validChildren,
      PopoverCloseButton
    );
    const resolvedChildren = () => {
      return (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, { children: [
        customPopoverCloseButton != null ? customPopoverCloseButton : closeOnButton ? (0, import_jsx_runtime80.jsx)(PopoverCloseButton, {}) : null,
        cloneChildren
      ] });
    };
    const popoverProps = { ...rest, children: resolvedChildren() };
    const css4 = (_a = __css != null ? __css : styles2.container) != null ? _a : {};
    const computedCSS = {
      position: "relative",
      w: "100%",
      display: "flex",
      flexDirection: "column",
      outline: 0,
      ...css4
    };
    width != null ? width : width = w;
    width != null ? width : width = (_b = css4 == null ? void 0 : css4.width) != null ? _b : css4 == null ? void 0 : css4.w;
    minWidth != null ? minWidth : minWidth = minW;
    minWidth != null ? minWidth : minWidth = (_c = css4 == null ? void 0 : css4.minWidth) != null ? _c : css4 == null ? void 0 : css4.minW;
    zIndex != null ? zIndex : zIndex = z;
    zIndex != null ? zIndex : zIndex = (_d = css4 == null ? void 0 : css4.zIndex) != null ? _d : css4 == null ? void 0 : css4.z;
    return (0, import_jsx_runtime80.jsx)(
      ui.div,
      {
        ...getPopperProps({
          style: { visibility: isOpen ? "visible" : "hidden" }
        }),
        className: "ui-popover",
        width,
        minWidth,
        zIndex,
        ...containerProps,
        children: (0, import_jsx_runtime80.jsx)(
          Motion,
          {
            as: "section",
            className: cx("ui-popover__content", className),
            ...animation2 !== "none" ? getPopoverContentProps(animation2, duration) : {},
            ...getPopoverProps(popoverProps, ref),
            initial: "exit",
            animate: isOpen ? "enter" : "exit",
            exit: "exit",
            onAnimationComplete: funcAll(
              onAnimationComplete,
              rest.onAnimationComplete
            ),
            __css: computedCSS
          }
        )
      }
    );
  }
);

// node_modules/@yamada-ui/popover/dist/chunk-S34RXSKT.mjs
var import_react111 = __toESM(require_react(), 1);
var PopoverAnchor = ({ children }) => {
  const child = import_react111.Children.only(children);
  const { getAnchorProps } = usePopover();
  return (0, import_react111.cloneElement)(child, getAnchorProps(child.props, child.ref));
};

// node_modules/@yamada-ui/popover/dist/chunk-AIYOSWPJ.mjs
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var PopoverBody = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = usePopover();
    const css4 = {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      ...styles2.body
    };
    return (0, import_jsx_runtime81.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-popover__body", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/popover/dist/chunk-4VQXGMUW.mjs
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var PopoverFooter = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = usePopover();
    const css4 = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      ...styles2.footer
    };
    return (0, import_jsx_runtime82.jsx)(
      ui.footer,
      {
        ref,
        className: cx("ui-popover__footer", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/popover/dist/chunk-YVPBG4J2.mjs
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var PopoverHeader = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = usePopover();
    const css4 = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      ...styles2.header
    };
    return (0, import_jsx_runtime83.jsx)(
      ui.header,
      {
        ref,
        className: cx("ui-popover__header", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/popover/dist/chunk-5MQZCOH5.mjs
var import_react112 = __toESM(require_react(), 1);
var PopoverTrigger = ({ children }) => {
  const child = import_react112.Children.only(children);
  const { getTriggerProps } = usePopover();
  return (0, import_react112.cloneElement)(child, getTriggerProps(child.props, child.ref));
};

// node_modules/@yamada-ui/menu/dist/chunk-6IPLI42Z.mjs
var import_react114 = __toESM(require_react(), 1);
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var [ContextMenuProvider, useContextMenu] = createContext2(
  {
    strict: false,
    name: "ContextMenuContext"
  }
);
var ContextMenu2 = (props2) => {
  const [styles2, mergedProps] = useMultiComponentStyle("ContextMenu", props2);
  const { ...rest } = omitThemeProps(mergedProps);
  return (0, import_jsx_runtime84.jsx)(ContextMenuProvider, { value: { styles: styles2 }, children: (0, import_jsx_runtime84.jsx)(Menu2, { trigger: "contextmenu", ...rest }) });
};
var {
  DescendantsContextProvider: DescendantsContextProvider3,
  useDescendantsContext: useMenuDescendantsContext,
  useDescendants: useDescendants3,
  useDescendant: useMenuDescendant
} = createDescendant();
var [MenuProvider, useMenu] = createContext2({
  name: "MenuContext",
  errorMessage: `useMenu returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />"`
});
var [UpstreamMenuProvider, useUpstreamMenu] = createContext2({
  strict: false,
  name: "UpstreamMenuContext"
});
var Menu2 = (props2) => {
  var _a, _b, _c;
  const { styles: contextMenuStyles } = (_a = useContextMenu()) != null ? _a : {};
  const [styles2, mergedProps] = useMultiComponentStyle("Menu", props2, {
    isProcessSkip: !!contextMenuStyles,
    styles: contextMenuStyles
  });
  let {
    initialFocusRef,
    closeOnSelect = true,
    closeOnBlur,
    placement,
    duration = 0.2,
    offset: offset2,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    ...rest
  } = omitThemeProps(mergedProps);
  const { relatedRef, onUpstreamClose, onDownstreamCloseMapRef } = (_b = useUpstreamMenu()) != null ? _b : {};
  const { setDownstreamOpen, hasDownstreamRef } = (_c = useUpstreamMenuItem()) != null ? _c : {};
  const isNested = !!relatedRef;
  if (isNested) {
    placement != null ? placement : placement = "right-start";
    offset2 != null ? offset2 : offset2 = [-8, 8];
    closeOnBlur != null ? closeOnBlur : closeOnBlur = false;
  } else {
    placement != null ? placement : placement = "bottom-start";
  }
  const descendants = useDescendants3();
  const [focusedIndex, setFocusedIndex] = (0, import_react114.useState)(-1);
  const menuRef = (0, import_react114.useRef)(null);
  const timeoutIds = (0, import_react114.useRef)(/* @__PURE__ */ new Set([]));
  const requestAnimationFrameId = (0, import_react114.useRef)(null);
  const onCloseMapRef = (0, import_react114.useRef)(/* @__PURE__ */ new Map());
  const onFocusMenu = (0, import_react114.useCallback)(() => {
    requestAnimationFrame(
      () => {
        var _a2;
        return (_a2 = menuRef.current) == null ? void 0 : _a2.focus({ preventScroll: false });
      }
    );
  }, []);
  const onFocusFirstItem = (0, import_react114.useCallback)(() => {
    const id22 = setTimeout(() => {
      if (initialFocusRef) return;
      const first = descendants.enabledFirstValue();
      if (first) setFocusedIndex(first.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const onFocusLastItem = (0, import_react114.useCallback)(() => {
    const id22 = setTimeout(() => {
      if (initialFocusRef) return;
      const last = descendants.enabledLastValue();
      if (last) setFocusedIndex(last.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const onOpenInternal = (0, import_react114.useCallback)(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (!isNested) onFocusMenu();
  }, [onOpenProp, isNested, onFocusMenu]);
  const onCloseInternal = (0, import_react114.useCallback)(() => {
    onCloseProp == null ? void 0 : onCloseProp();
    for (const onClose2 of onCloseMapRef.current.values()) {
      onClose2();
    }
  }, [onCloseProp]);
  const id4 = (0, import_react114.useId)();
  const { isOpen, onOpen, onClose } = useDisclosure({
    ...props2,
    onOpen: onOpenInternal,
    onClose: onCloseInternal
  });
  (0, import_react114.useEffect)(() => {
    const onCloseMap = onDownstreamCloseMapRef == null ? void 0 : onDownstreamCloseMapRef.current;
    onCloseMap == null ? void 0 : onCloseMap.set(id4, onClose);
    return () => {
      onCloseMap == null ? void 0 : onCloseMap.delete(id4);
    };
  }, [id4, onClose, onDownstreamCloseMapRef]);
  (0, import_react114.useEffect)(() => {
    if (setDownstreamOpen) setDownstreamOpen(isOpen);
  }, [setDownstreamOpen, isOpen]);
  (0, import_react114.useEffect)(() => {
    if (hasDownstreamRef) hasDownstreamRef.current = true;
    return () => {
      if (hasDownstreamRef) hasDownstreamRef.current = false;
    };
  });
  useUpdateEffect(() => {
    if (!isOpen) setFocusedIndex(-1);
  }, [isOpen]);
  useUnmountEffect(() => {
    timeoutIds.current.forEach((id22) => clearTimeout(id22));
    timeoutIds.current.clear();
  });
  return (0, import_jsx_runtime85.jsx)(DescendantsContextProvider3, { value: descendants, children: (0, import_jsx_runtime85.jsx)(
    UpstreamMenuProvider,
    {
      value: {
        relatedRef: menuRef,
        onDownstreamCloseMapRef: onCloseMapRef,
        onUpstreamClose: funcAll(onUpstreamClose, onClose)
      },
      children: (0, import_jsx_runtime85.jsx)(
        MenuProvider,
        {
          value: {
            isOpen,
            onOpen,
            onClose,
            onUpstreamClose,
            onFocusFirstItem,
            onFocusLastItem,
            closeOnSelect,
            focusedIndex,
            setFocusedIndex,
            menuRef,
            requestAnimationFrameId,
            isNested,
            styles: styles2
          },
          children: (0, import_jsx_runtime85.jsx)(
            Popover2,
            {
              ...{
                trigger: isNested ? "hover" : "click",
                ...rest,
                isOpen,
                onOpen,
                onClose,
                placement,
                offset: offset2,
                duration,
                initialFocusRef,
                relatedRef,
                closeOnButton: false,
                closeOnBlur
              }
            }
          )
        }
      )
    }
  ) });
};
var [UpstreamMenuItemProvider, useUpstreamMenuItem] = createContext2({
  strict: false,
  name: "UpstreamMenuItemContext"
});
var isTargetMenuItem = (target) => {
  var _a;
  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem"));
};
var MenuItem = forwardRef22(
  ({
    className,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect: customCloseOnSelect,
    icon,
    command,
    children,
    ...props2
  }, ref) => {
    var _a;
    const {
      focusedIndex,
      setFocusedIndex,
      isOpen,
      onClose,
      onUpstreamClose,
      closeOnSelect: generalCloseOnSelect,
      menuRef,
      requestAnimationFrameId,
      isNested,
      styles: styles2
    } = useMenu();
    const { onUpstreamRestoreFocus } = (_a = useUpstreamMenuItem()) != null ? _a : {};
    const trulyDisabled = isDisabled2 && !isFocusable2;
    const itemRef = (0, import_react113.useRef)(null);
    const hasDownstreamRef = (0, import_react113.useRef)(false);
    const onKeyDownRef = (0, import_react113.useRef)(
      () => void 0
    );
    const { index, register } = useMenuDescendant({ disabled: trulyDisabled });
    const [isDownstreamOpen, setDownstreamOpen] = (0, import_react113.useState)(false);
    const isFocused = index === focusedIndex;
    const onMouseOver = (0, import_react113.useCallback)(() => {
      if (isDisabled2) return;
      setFocusedIndex(index);
    }, [index, isDisabled2, setFocusedIndex]);
    const onMouseLeave = (0, import_react113.useCallback)(() => {
      if (isDisabled2) return;
      setFocusedIndex(-1);
    }, [setFocusedIndex, isDisabled2]);
    const onClick2 = (0, import_react113.useCallback)(
      (ev) => {
        if (!isTargetMenuItem(ev.currentTarget)) return;
        const hasDownstream = hasDownstreamRef.current;
        if (customCloseOnSelect != null ? customCloseOnSelect : !hasDownstream && generalCloseOnSelect) {
          onClose();
          onUpstreamClose == null ? void 0 : onUpstreamClose();
        }
      },
      [customCloseOnSelect, generalCloseOnSelect, onClose, onUpstreamClose]
    );
    const onFocus4 = (0, import_react113.useCallback)(() => {
      setFocusedIndex(index);
    }, [setFocusedIndex, index]);
    const onRestoreFocus = (0, import_react113.useCallback)(() => {
      var _a2;
      (_a2 = itemRef.current) == null ? void 0 : _a2.focus();
      setFocusedIndex(index);
    }, [setFocusedIndex, index]);
    const onKeyDown = (0, import_react113.useCallback)(
      (ev) => {
        const actions = {
          ArrowLeft: isNested ? funcAll(onUpstreamRestoreFocus, onClose) : void 0
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        ev.stopPropagation();
        action();
      },
      [onUpstreamRestoreFocus, onClose, isNested]
    );
    const rest = useClickable({
      focusOnClick: false,
      ...props2,
      onClick: handlerAll(props2.onClick, onClick2),
      onFocus: handlerAll(props2.onFocus, onFocus4),
      onMouseOver: handlerAll(props2.onMouseOver, onMouseOver),
      onMouseLeave: handlerAll(props2.onMouseLeave, onMouseLeave),
      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown, onKeyDownRef.current),
      ref: mergeRefs(register, itemRef, ref),
      isDisabled: isDisabled2,
      isFocusable: isFocusable2
    });
    useUpdateEffect(() => {
      if (!isOpen) return;
      const id4 = requestAnimationFrameId.current;
      if (isFocused && !trulyDisabled && itemRef.current) {
        if (id4) cancelAnimationFrame(id4);
        requestAnimationFrameId.current = requestAnimationFrame(() => {
          var _a2;
          (_a2 = itemRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
          requestAnimationFrameId.current = null;
        });
      } else if (menuRef.current && !isActiveElement(menuRef.current)) {
        menuRef.current.focus({ preventScroll: true });
      }
      return () => {
        if (id4) cancelAnimationFrame(id4);
      };
    }, [isFocused, trulyDisabled, menuRef, isOpen]);
    children = icon || command ? (0, import_jsx_runtime86.jsx)(ui.span, { style: { flex: 1 }, children }) : children;
    const css4 = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      ...styles2.item
    };
    return (0, import_jsx_runtime86.jsx)(
      UpstreamMenuItemProvider,
      {
        value: {
          onKeyDownRef,
          onUpstreamRestoreFocus: onRestoreFocus,
          setDownstreamOpen,
          hasDownstreamRef
        },
        children: (0, import_jsx_runtime86.jsxs)(
          ui.li,
          {
            ...rest,
            ...isDownstreamOpen ? { "data-active": "" } : {},
            role: "menuitem",
            tabIndex: isFocused ? 0 : -1,
            className: cx("ui-menu__item", className),
            __css: css4,
            children: [
              icon ? (0, import_jsx_runtime86.jsx)(MenuIcon, { children: icon }) : null,
              children,
              command ? (0, import_jsx_runtime86.jsx)(MenuCommand, { children: command }) : null
            ]
          }
        )
      }
    );
  }
);
var MenuOptionItem = forwardRef22(
  ({ className, icon, isChecked, closeOnSelect = false, children, ...rest }, ref) => {
    return (0, import_jsx_runtime86.jsxs)(
      MenuItem,
      {
        ref,
        className: cx("ui-menu__item--option", className),
        "aria-checked": ariaAttr(isChecked),
        closeOnSelect,
        ...rest,
        children: [
          icon !== null ? (0, import_jsx_runtime86.jsx)(MenuIcon, { opacity: isChecked ? 1 : 0, children: icon || (0, import_jsx_runtime86.jsx)(CheckIcon3, {}) }) : null,
          children
        ]
      }
    );
  }
);
var MenuIcon = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useMenu();
    const css4 = {
      flexShrink: 0,
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "0.85em",
      ...styles2.icon
    };
    return (0, import_jsx_runtime86.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-menu__item__icon", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var MenuCommand = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useMenu();
    const css4 = { ...styles2.command };
    return (0, import_jsx_runtime86.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-menu__item__command", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var CheckIcon3 = () => (0, import_jsx_runtime86.jsx)("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", children: (0, import_jsx_runtime86.jsx)(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) });

// node_modules/@yamada-ui/menu/dist/chunk-5E4WVWFT.mjs
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var MenuGroup = forwardRef22(
  ({ className, label, children, ...rest }, ref) => {
    const { styles: styles2 } = useMenu();
    const css4 = { ...styles2.group };
    return (0, import_jsx_runtime87.jsxs)(
      ui.li,
      {
        ref,
        className: cx("ui-menu__item", "ui-menu__item--group", className),
        role: "group",
        __css: css4,
        ...rest,
        children: [
          label ? (0, import_jsx_runtime87.jsx)(
            ui.span,
            {
              className: cx("ui-menu__item--group-label"),
              __css: styles2.groupLabel,
              children: label
            }
          ) : null,
          (0, import_jsx_runtime87.jsx)(ui.ul, { className: "ui-menu__item__group", children })
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/menu/dist/chunk-CYTPEUZL.mjs
var import_react115 = __toESM(require_react(), 1);
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var MenuOptionGroup = (0, import_react115.forwardRef)(
  ({
    className,
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    type,
    children,
    ...rest
  }, ref) => {
    const isRadio = type === "radio";
    defaultValue != null ? defaultValue : defaultValue = isRadio ? "" : [];
    const [value, setValue] = useControllableState({
      value: valueProp,
      defaultValue,
      onChange: onChangeProp
    });
    const onChange = (0, import_react115.useCallback)(
      (selectedValue) => {
        if (isRadio && typeof value === "string") setValue(selectedValue);
        if (!isRadio && isArray(value)) {
          const nextValue = value.includes(selectedValue) ? value.filter((item) => item !== selectedValue) : value.concat(selectedValue);
          setValue(nextValue);
        }
      },
      [isRadio, value, setValue]
    );
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map((child) => {
      if (child.type !== MenuOptionItem) return child;
      const onClick2 = (ev) => {
        var _a, _b;
        onChange(child.props.value);
        (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, ev);
      };
      const isChecked = !isRadio && isArray(value) ? value.includes(child.props.value) : child.props.value === value;
      return (0, import_react115.cloneElement)(child, { type, onClick: onClick2, isChecked });
    });
    return (0, import_jsx_runtime88.jsx)(
      MenuGroup,
      {
        ref,
        className: cx("ui-menu__item--group--option", className),
        ...rest,
        children: cloneChildren
      }
    );
  }
);
MenuOptionGroup.displayName = "MenuOptionGroup";

// node_modules/@yamada-ui/menu/dist/chunk-5ZWRZF6M.mjs
var import_react116 = __toESM(require_react(), 1);
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var ContextMenuTrigger = forwardRef22(
  ({ children, className, ...rest }, ref) => {
    const { styles: styles2 } = useContextMenu();
    const [position2, setPosition] = (0, import_react116.useState)({ top: 0, left: 0 });
    const css4 = { ...styles2.container };
    const onContextMenu = (ev) => {
      setPosition({ top: ev.clientY, left: ev.clientX });
    };
    return (0, import_jsx_runtime89.jsxs)(import_jsx_runtime89.Fragment, { children: [
      (0, import_jsx_runtime89.jsx)(PopoverAnchor, { children: (0, import_jsx_runtime89.jsx)(
        ui.div,
        {
          className: "ui-context-menu__anchor",
          style: { position: "absolute", ...position2 }
        }
      ) }),
      (0, import_jsx_runtime89.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime89.jsx)(
        ui.div,
        {
          ref,
          className: cx("ui-context-menu", className),
          __css: css4,
          ...rest,
          onContextMenu: handlerAll(rest.onContextMenu, onContextMenu),
          children
        }
      ) })
    ] });
  }
);

// node_modules/@yamada-ui/menu/dist/chunk-MDR7ZMJH.mjs
var import_react117 = __toESM(require_react(), 1);
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var MenuButton = forwardRef22(
  ({ className, children, as: As, ...rest }, ref) => {
    var _a;
    const { onKeyDownRef, onUpstreamRestoreFocus } = (_a = useUpstreamMenuItem()) != null ? _a : {};
    const { isOpen, onOpen, onClose, onFocusFirstItem, onFocusLastItem } = useMenu();
    const onKeyDown = (0, import_react117.useCallback)(
      (ev) => {
        const actions = {
          Enter: funcAll(onOpen, onFocusFirstItem),
          ArrowDown: funcAll(onOpen, onFocusFirstItem),
          ArrowUp: funcAll(onOpen, onFocusLastItem)
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        action();
      },
      [onFocusFirstItem, onFocusLastItem, onOpen]
    );
    const onItemKeyDown = (0, import_react117.useCallback)(
      (ev) => {
        const actions = {
          ArrowRight: !isOpen ? funcAll(onOpen, onFocusFirstItem) : void 0,
          ArrowLeft: isOpen ? funcAll(onUpstreamRestoreFocus, onClose) : void 0
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        action();
      },
      [isOpen, onOpen, onFocusFirstItem, onUpstreamRestoreFocus, onClose]
    );
    assignRef(onKeyDownRef, onItemKeyDown);
    const Component3 = (0, import_react117.useMemo)(() => As ? ui(As) : Button3, [As]);
    return (0, import_jsx_runtime90.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime90.jsx)(
      Component3,
      {
        ref,
        className: cx("ui-menu", className),
        "aria-haspopup": "menu",
        "aria-expanded": isOpen,
        ...rest,
        "data-active": dataAttr(isOpen),
        onKeyDown: handlerAll(rest.onKeyDown, onKeyDown),
        children
      }
    ) });
  }
);
var Button3 = forwardRef22((rest, ref) => {
  const { styles: styles2 } = useMenu();
  const css4 = {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    outline: 0,
    ...styles2.button
  };
  return (0, import_jsx_runtime90.jsx)(ui.button, { ref, __css: css4, ...rest });
});
var MenuItemButton = forwardRef22(
  ({ className, children, innerProps, icon, iconProps, ...rest }, ref) => {
    return (0, import_jsx_runtime90.jsxs)(
      MenuButton,
      {
        ref,
        className: cx("ui-menu__item-button", className),
        flex: "1",
        ...rest,
        children: [
          (0, import_jsx_runtime90.jsx)(ui.span, { as: "span", flex: "1", ...innerProps, children }),
          (0, import_jsx_runtime90.jsx)(MenuIcon, { ...iconProps, children: icon != null ? icon : (0, import_jsx_runtime90.jsx)(ChevronIcon, { fontSize: "1.5em", transform: "rotate(-90deg)" }) })
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/menu/dist/chunk-ZOUBZWDN.mjs
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var MenuDivider = forwardRef22(({ className, ...rest }, ref) => {
  const { styles: styles2 } = useMenu();
  const css4 = { ...styles2.divider };
  return (0, import_jsx_runtime91.jsx)(
    ui.hr,
    {
      ref,
      className: cx("ui-menu__divider", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/menu/dist/chunk-73KHS3JD.mjs
var import_react118 = __toESM(require_react(), 1);
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var MenuList = forwardRef22(
  ({ className, contentProps, children, ...rest }, ref) => {
    const { menuRef, focusedIndex, setFocusedIndex, onClose, styles: styles2 } = useMenu();
    const descendants = useMenuDescendantsContext();
    const onNext = (0, import_react118.useCallback)(() => {
      const next2 = descendants.enabledNextValue(focusedIndex);
      if (next2) setFocusedIndex(next2.index);
    }, [descendants, focusedIndex, setFocusedIndex]);
    const onPrev = (0, import_react118.useCallback)(() => {
      const prev2 = descendants.enabledPrevValue(focusedIndex);
      if (prev2) setFocusedIndex(prev2.index);
    }, [descendants, focusedIndex, setFocusedIndex]);
    const onFirst = (0, import_react118.useCallback)(() => {
      const first = descendants.enabledFirstValue();
      if (first) setFocusedIndex(first.index);
    }, [descendants, setFocusedIndex]);
    const onLast = (0, import_react118.useCallback)(() => {
      const last = descendants.enabledLastValue();
      if (last) setFocusedIndex(last.index);
    }, [descendants, setFocusedIndex]);
    const onKeyDown = (0, import_react118.useCallback)(
      (ev) => {
        const actions = {
          Tab: (ev2) => ev2.preventDefault(),
          Escape: onClose,
          ArrowDown: focusedIndex === -1 ? onFirst : onNext,
          ArrowUp: focusedIndex === -1 ? onLast : onPrev,
          Home: onFirst,
          End: onLast
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        action(ev);
      },
      [focusedIndex, onClose, onFirst, onLast, onNext, onPrev]
    );
    return (0, import_jsx_runtime92.jsx)(
      PopoverContent,
      {
        as: "div",
        className: "ui-menu__content",
        __css: { ...styles2.content },
        ...contentProps,
        onKeyDown: handlerAll(contentProps == null ? void 0 : contentProps.onKeyDown, onKeyDown),
        children: (0, import_jsx_runtime92.jsx)(
          ui.ul,
          {
            ref: mergeRefs(menuRef, ref),
            role: "menu",
            className: cx("ui-menu__list", className),
            tabIndex: -1,
            __css: { ...styles2.list },
            ...rest,
            children
          }
        )
      }
    );
  }
);

// node_modules/@yamada-ui/modal/dist/chunk-XA7WZEKS.mjs
var import_react119 = __toESM(require_react(), 1);
var import_react120 = __toESM(require_react(), 1);
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var ModalOverlay = motionForwardRef(
  ({ className, __css, onClick: onClick2, ...rest }, ref) => {
    const {
      styles: styles2,
      closeOnOverlay,
      onOverlayClick,
      onClose,
      animation: animation2,
      duration
    } = useModal();
    const css4 = {
      position: "fixed",
      top: 0,
      left: 0,
      w: "100vw",
      h: "100vh",
      ...__css ? __css : styles2.overlay
    };
    const props2 = animation2 !== "none" ? fadeProps : {};
    return (0, import_jsx_runtime93.jsx)(
      Motion,
      {
        ref,
        className: cx("ui-modal__overlay", className),
        custom: { duration },
        __css: css4,
        onClick: handlerAll(onClick2, onOverlayClick, (ev) => {
          ev.stopPropagation();
          if (closeOnOverlay) onClose == null ? void 0 : onClose();
        }),
        ...props2,
        ...rest
      }
    );
  }
);
var ModalCloseButton = forwardRef22(
  ({ onClick: onClick2, __css, ...rest }, ref) => {
    const { styles: styles2, onClose } = useModal();
    const css4 = {
      position: "absolute",
      ...__css ? __css : styles2.closeButton
    };
    return (0, import_jsx_runtime94.jsx)(
      CloseButton,
      {
        ref,
        className: cx("ui-modal__close-button"),
        __css: css4,
        onClick: handlerAll(onClick2, (ev) => {
          ev.stopPropagation();
          onClose == null ? void 0 : onClose();
        }),
        ...rest
      }
    );
  }
);
var ModalHeader = forwardRef22(
  ({ className, __css, ...rest }, ref) => {
    const { styles: styles2 } = useModal();
    const css4 = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      ...__css ? __css : styles2.header
    };
    return (0, import_jsx_runtime95.jsx)(
      ui.header,
      {
        ref,
        className: cx("ui-modal__header", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var ModalBody = forwardRef22(
  ({ className, __css, ...rest }, ref) => {
    const { styles: styles2, scrollBehavior } = useModal();
    const css4 = {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      overflow: scrollBehavior === "inside" ? "auto" : void 0,
      ...__css ? __css : styles2.body
    };
    return (0, import_jsx_runtime96.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-modal__body", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var ModalFooter = forwardRef22(
  ({ className, __css, ...rest }, ref) => {
    const { styles: styles2 } = useModal();
    const css4 = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      ...__css ? __css : styles2.footer
    };
    return (0, import_jsx_runtime97.jsx)(
      ui.footer,
      {
        ref,
        className: cx("ui-modal__footer", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var [DialogProvider, useDialog] = createContext2({
  name: `DialogContext`,
  errorMessage: `useDialog returned is 'undefined'. Seems you forgot to wrap the components in "<Dialog />" `
});
var Dialog2 = motionForwardRef(
  ({ size, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Dialog", {
      size,
      ...props2
    });
    const {
      className,
      children,
      withOverlay = true,
      withCloseButton = true,
      header,
      footer,
      cancel,
      other,
      success,
      onClose,
      onCancel,
      onOther,
      onSuccess,
      ...rest
    } = omitThemeProps(mergedProps);
    const validChildren = getValidChildren(children);
    const [customDialogOverlay] = findChildren(validChildren, DialogOverlay);
    const [customDialogCloseButton] = findChildren(
      validChildren,
      DialogCloseButton
    );
    const [customDialogHeader] = findChildren(validChildren, DialogHeader);
    const [customDialogBody] = findChildren(validChildren, DialogBody);
    const [customDialogFooter] = findChildren(validChildren, DialogFooter);
    const cloneChildren = !isEmpty(validChildren) ? omitChildren(
      validChildren,
      DialogOverlay,
      DialogCloseButton,
      DialogHeader,
      DialogBody,
      DialogFooter
    ) : children;
    const css4 = { ...styles2.container };
    const cancelButtonProps = isValidElement2(cancel) ? { children: cancel } : cancel;
    const otherButtonProps = isValidElement2(other) ? { children: other } : other;
    const successButtonProps = isValidElement2(success) ? { children: success } : success;
    if (cancelButtonProps && !cancelButtonProps.variant)
      cancelButtonProps.variant = "ghost";
    if (otherButtonProps && !otherButtonProps.colorScheme)
      otherButtonProps.colorScheme = "secondary";
    if (successButtonProps && !successButtonProps.colorScheme)
      successButtonProps.colorScheme = "primary";
    return (0, import_jsx_runtime98.jsx)(DialogProvider, { value: styles2, children: (0, import_jsx_runtime98.jsxs)(
      Modal2,
      {
        ref,
        className: cx("ui-dialog", className),
        __css: css4,
        ...{
          onClose,
          withOverlay: false,
          withCloseButton: false,
          ...rest,
          size
        },
        children: [
          customDialogOverlay != null ? customDialogOverlay : withOverlay && size !== "full" ? (0, import_jsx_runtime98.jsx)(DialogOverlay, {}) : null,
          customDialogCloseButton != null ? customDialogCloseButton : withCloseButton && onClose ? (0, import_jsx_runtime98.jsx)(DialogCloseButton, {}) : null,
          customDialogHeader != null ? customDialogHeader : header ? (0, import_jsx_runtime98.jsx)(DialogHeader, { children: header }) : null,
          customDialogBody != null ? customDialogBody : cloneChildren ? (0, import_jsx_runtime98.jsx)(DialogBody, { children: cloneChildren }) : null,
          customDialogFooter != null ? customDialogFooter : footer || cancelButtonProps || otherButtonProps || successButtonProps ? (0, import_jsx_runtime98.jsx)(DialogFooter, { children: footer != null ? footer : (0, import_jsx_runtime98.jsxs)(import_jsx_runtime98.Fragment, { children: [
            cancelButtonProps ? (0, import_jsx_runtime98.jsx)(
              Button2,
              {
                onClick: () => onCancel == null ? void 0 : onCancel(onClose),
                ...cancelButtonProps
              }
            ) : null,
            otherButtonProps ? (0, import_jsx_runtime98.jsx)(
              Button2,
              {
                onClick: () => onOther == null ? void 0 : onOther(onClose),
                ...otherButtonProps
              }
            ) : null,
            successButtonProps ? (0, import_jsx_runtime98.jsx)(
              Button2,
              {
                onClick: () => onSuccess == null ? void 0 : onSuccess(onClose),
                ...successButtonProps
              }
            ) : null
          ] }) }) : null
        ]
      }
    ) });
  }
);
var DialogOverlay = motionForwardRef(
  ({ className, ...rest }, ref) => {
    const styles2 = useDialog();
    const css4 = { ...styles2.overlay };
    return (0, import_jsx_runtime98.jsx)(
      ModalOverlay,
      {
        ref,
        className: cx("ui-dialog__overlay", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DialogCloseButton = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDialog();
    const css4 = { ...styles2.closeButton };
    return (0, import_jsx_runtime98.jsx)(
      ModalCloseButton,
      {
        ref,
        className: cx("ui-dialog__close-button", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DialogHeader = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDialog();
    const css4 = { ...styles2.header };
    return (0, import_jsx_runtime98.jsx)(
      ModalHeader,
      {
        ref,
        className: cx("ui-dialog__header", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DialogBody = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDialog();
    const css4 = { ...styles2.body };
    return (0, import_jsx_runtime98.jsx)(
      ModalBody,
      {
        ref,
        className: cx("ui-dialog__body", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DialogFooter = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDialog();
    const css4 = { ...styles2.footer };
    return (0, import_jsx_runtime98.jsx)(
      ModalFooter,
      {
        ref,
        className: cx("ui-dialog__footer", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var [ModalProvider, useModal] = createContext2({
  name: `ModalContext`,
  errorMessage: `useModal returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
});
var Modal2 = motionForwardRef(
  ({ size, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Modal", {
      size,
      ...props2
    });
    const {
      className,
      children,
      isOpen,
      onClose,
      onOverlayClick,
      onEsc,
      onCloseComplete,
      placement: _placement = "center",
      outside = "fallback(4, 1rem)",
      withCloseButton = true,
      withOverlay = true,
      allowPinchZoom = false,
      scrollBehavior = "inside",
      autoFocus,
      restoreFocus,
      initialFocusRef,
      finalFocusRef,
      blockScrollOnMount = true,
      closeOnOverlay = true,
      closeOnEsc = true,
      lockFocusAcrossFrames = true,
      animation: animation2 = "scale",
      duration,
      portalProps,
      ...rest
    } = omitThemeProps(mergedProps);
    const onKeyDown = (0, import_react120.useCallback)(
      (ev) => {
        if (ev.key !== "Escape") return;
        ev.stopPropagation();
        if (closeOnEsc) onClose == null ? void 0 : onClose();
        onEsc == null ? void 0 : onEsc();
      },
      [closeOnEsc, onClose, onEsc]
    );
    const validChildren = getValidChildren(children);
    const [customModalOverlay, ...cloneChildren] = findChildren(
      validChildren,
      ModalOverlay,
      DialogOverlay,
      DrawerOverlay
    );
    let [drawerContent] = findChildren(validChildren, DrawerContent);
    if (drawerContent)
      drawerContent = (0, import_react120.cloneElement)(drawerContent, { onKeyDown });
    const placement = useValue(_placement);
    const css4 = {
      position: "fixed",
      top: 0,
      left: 0,
      zIndex: "fallback(jeice, 110)",
      w: "100vw",
      h: "100dvh",
      p: size !== "full" ? outside : void 0,
      display: "flex",
      justifyContent: placement.includes("left") ? "flex-start" : placement.includes("right") ? "flex-end" : "center",
      alignItems: placement.includes("top") ? "flex-start" : placement.includes("bottom") ? "flex-end" : "center"
    };
    return (0, import_jsx_runtime99.jsx)(
      ModalProvider,
      {
        value: {
          isOpen,
          onClose,
          onOverlayClick,
          withCloseButton,
          scrollBehavior,
          closeOnOverlay,
          animation: animation2,
          duration,
          styles: styles2
        },
        children: (0, import_jsx_runtime99.jsx)(AnimatePresence, { onExitComplete: onCloseComplete, children: isOpen ? (0, import_jsx_runtime99.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime99.jsx)(
          FocusLock2,
          {
            autoFocus,
            initialFocusRef,
            finalFocusRef,
            restoreFocus,
            lockFocusAcrossFrames,
            children: (0, import_jsx_runtime99.jsx)(
              Combination_default,
              {
                allowPinchZoom,
                enabled: blockScrollOnMount,
                forwardProps: true,
                children: (0, import_jsx_runtime99.jsxs)(ui.div, { __css: css4, children: [
                  customModalOverlay != null ? customModalOverlay : withOverlay && size !== "full" ? (0, import_jsx_runtime99.jsx)(ModalOverlay, {}) : null,
                  drawerContent != null ? drawerContent : (0, import_jsx_runtime99.jsx)(
                    ModalContent,
                    {
                      ref,
                      className,
                      onKeyDown,
                      ...rest,
                      children: cloneChildren
                    }
                  )
                ] })
              }
            )
          }
        ) }) : null })
      }
    );
  }
);
var getModalContentProps = (animation2 = "scale", duration) => {
  switch (animation2) {
    case "scale":
      return {
        ...scaleFadeProps,
        custom: { scale: 0.95, reverse: true, duration }
      };
    case "top":
      return {
        ...slideFadeProps,
        custom: { offsetY: -16, reverse: true, duration }
      };
    case "right":
      return {
        ...slideFadeProps,
        custom: { offsetX: 16, reverse: true, duration }
      };
    case "left":
      return {
        ...slideFadeProps,
        custom: { offsetX: -16, reverse: true, duration }
      };
    case "bottom":
      return {
        ...slideFadeProps,
        custom: { offsetY: 16, reverse: true, duration }
      };
  }
};
var ModalContent = motionForwardRef(
  ({ className, children, __css, ...rest }, ref) => {
    const {
      styles: styles2,
      scrollBehavior,
      withCloseButton,
      onClose,
      animation: animation2,
      duration
    } = useModal();
    const validChildren = getValidChildren(children);
    const [customModalCloseButton, ...cloneChildren] = findChildren(
      validChildren,
      ModalCloseButton,
      DialogCloseButton
    );
    const props2 = animation2 !== "none" ? getModalContentProps(animation2, duration) : {};
    const css4 = {
      position: "relative",
      maxH: "100%",
      display: "flex",
      flexDirection: "column",
      overflow: scrollBehavior === "inside" ? "hidden" : "auto",
      outline: 0,
      ...__css ? __css : styles2.container
    };
    return (0, import_jsx_runtime99.jsxs)(
      Motion,
      {
        as: "section",
        role: "dialog",
        "aria-modal": "true",
        ref,
        className: cx("ui-modal", className),
        tabIndex: -1,
        __css: css4,
        ...props2,
        ...rest,
        children: [
          customModalCloseButton != null ? customModalCloseButton : withCloseButton && onClose ? (0, import_jsx_runtime99.jsx)(ModalCloseButton, {}) : null,
          cloneChildren
        ]
      }
    );
  }
);
var [DrawerProvider, useDrawer] = createContext2({
  name: `DrawerContext`,
  errorMessage: `useDrawer returned is 'undefined'. Seems you forgot to wrap the components in "<Drawer />" `
});
var Drawer2 = motionForwardRef(
  ({ size, placement = "right", closeOnDrag = false, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Drawer", {
      size,
      placement,
      closeOnDrag,
      ...props2
    });
    const {
      children,
      isOpen,
      onClose,
      onOverlayClick,
      onEsc,
      onCloseComplete,
      withCloseButton = !closeOnDrag,
      withOverlay = true,
      withDragBar = true,
      allowPinchZoom,
      autoFocus,
      restoreFocus,
      initialFocusRef,
      finalFocusRef,
      blockScrollOnMount,
      closeOnOverlay,
      closeOnEsc,
      lockFocusAcrossFrames,
      duration = { enter: 0.4, exit: 0.3 },
      dragConstraints = 0,
      dragElastic = 0.1,
      dragOffset = 80,
      dragVelocity = 100,
      blankForDragProps,
      portalProps,
      ...rest
    } = omitThemeProps(mergedProps, ["isFullHeight"]);
    const validChildren = getValidChildren(children);
    const [customDrawerOverlay, ...cloneChildren] = findChildren(
      validChildren,
      DrawerOverlay
    );
    return (0, import_jsx_runtime100.jsx)(DrawerProvider, { value: styles2, children: (0, import_jsx_runtime100.jsxs)(
      Modal2,
      {
        ref,
        ...{
          isOpen,
          onClose,
          onOverlayClick,
          onEsc,
          onCloseComplete,
          withCloseButton: false,
          withOverlay: false,
          allowPinchZoom,
          autoFocus,
          restoreFocus,
          initialFocusRef,
          finalFocusRef,
          blockScrollOnMount,
          closeOnOverlay,
          closeOnEsc,
          lockFocusAcrossFrames,
          duration,
          portalProps
        },
        children: [
          customDrawerOverlay != null ? customDrawerOverlay : withOverlay ? (0, import_jsx_runtime100.jsx)(DrawerOverlay, {}) : null,
          (0, import_jsx_runtime100.jsx)(
            DrawerContent,
            {
              ...{
                dragConstraints,
                dragElastic,
                dragOffset,
                dragVelocity,
                withCloseButton,
                withDragBar,
                blankForDragProps,
                ...rest,
                placement,
                closeOnDrag
              },
              children: cloneChildren
            }
          )
        ]
      }
    ) });
  }
);
var DrawerContent = motionForwardRef(
  ({
    className,
    children,
    placement: _placement,
    withCloseButton,
    withDragBar,
    closeOnDrag,
    dragConstraints,
    dragElastic,
    dragOffset,
    dragVelocity,
    blankForDragProps,
    ...rest
  }, ref) => {
    const { isOpen, onClose, duration } = useModal();
    const styles2 = useDrawer();
    const placement = useValue(_placement);
    const validChildren = getValidChildren(children);
    const [customDrawerCloseButton, ...cloneChildren] = findChildren(
      validChildren,
      DrawerCloseButton
    );
    const blankForDragBg = (0, import_react119.useMemo)(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const propBg = (_c = (_b = (_a = rest.backgroundColor) != null ? _a : rest.bgColor) != null ? _b : rest.background) != null ? _c : rest.bg;
      const styleBg = (_j = (_h = (_f = (_d = styles2.container) == null ? void 0 : _d.backgroundColor) != null ? _f : (_e = styles2.container) == null ? void 0 : _e.bgColor) != null ? _h : (_g = styles2.container) == null ? void 0 : _g.background) != null ? _j : (_i = styles2.container) == null ? void 0 : _i.bg;
      const computedBg = propBg != null ? propBg : styleBg;
      return isArray(computedBg) ? computedBg : [computedBg];
    }, [rest, styles2]);
    const blankForDrag = (0, import_react119.useMemo)(() => {
      let position2 = {};
      switch (placement) {
        case "top":
          position2 = { top: "calc(-100dvh + 1px)", left: 0, right: 0 };
          break;
        case "bottom":
          position2 = { bottom: "calc(-100dvh + 1px)", left: 0, right: 0 };
          break;
        case "left":
          position2 = { left: "calc(-100% + 1px)", top: 0, bottom: 0 };
          break;
        case "right":
          position2 = { right: "calc(-100% + 1px)", top: 0, bottom: 0 };
          break;
      }
      const [lightBg, darkBg] = blankForDragBg;
      return {
        _after: {
          content: '""',
          display: "block",
          w: "100%",
          h: "100dvh",
          bg: lightBg,
          position: "absolute",
          ...position2,
          ...blankForDragProps
        },
        _dark: {
          _after: {
            bg: darkBg
          }
        }
      };
    }, [placement, blankForDragBg, blankForDragProps]);
    const css4 = (0, import_react119.useMemo)(
      () => ({
        display: "flex",
        flexDirection: placement === "top" || placement === "bottom" ? "column" : "row",
        outline: 0,
        ...closeOnDrag ? blankForDrag : {},
        ...styles2.container
      }),
      [blankForDrag, closeOnDrag, placement, styles2]
    );
    const getDragDirectionRestriction = (0, import_react119.useCallback)(
      (value) => {
        switch (placement) {
          case "top":
            return { bottom: value };
          case "bottom":
            return { top: value };
          case "left":
            return { right: value };
          case "right":
            return { left: value };
        }
      },
      [placement]
    );
    const getDragDirection = (0, import_react119.useCallback)(() => {
      switch (placement) {
        case "top":
        case "bottom":
          return "y";
        case "left":
        case "right":
          return "x";
      }
    }, [placement]);
    const isCloseByDragInfo = (0, import_react119.useCallback)(
      (info) => {
        switch (placement) {
          case "top":
            return info.velocity.y <= dragVelocity * -1 || info.offset.y <= dragOffset * -1;
          case "bottom":
            return info.velocity.y >= dragVelocity || info.offset.y >= dragOffset;
          case "left":
            return info.velocity.x <= dragVelocity * -1 || info.offset.x <= dragOffset * -1;
          case "right":
            return info.velocity.x >= dragVelocity || info.offset.x >= dragOffset;
        }
      },
      [placement, dragVelocity, dragOffset]
    );
    return (0, import_jsx_runtime100.jsxs)(
      Slide2,
      {
        ref,
        className: cx("ui-drawer", className),
        isOpen,
        placement,
        duration,
        drag: closeOnDrag ? getDragDirection() : false,
        dragConstraints: getDragDirectionRestriction(dragConstraints),
        dragElastic: getDragDirectionRestriction(dragElastic),
        dragSnapToOrigin: true,
        dragMomentum: false,
        onDragEnd: (_, info) => {
          if (isCloseByDragInfo(info)) onClose == null ? void 0 : onClose();
        },
        tabIndex: -1,
        __css: css4,
        ...rest,
        children: [
          customDrawerCloseButton != null ? customDrawerCloseButton : withCloseButton && onClose ? (0, import_jsx_runtime100.jsx)(DrawerCloseButton, {}) : null,
          withDragBar && closeOnDrag && (placement === "bottom" || placement === "right") ? (0, import_jsx_runtime100.jsx)(DrawerDragBar, {}) : null,
          (0, import_jsx_runtime100.jsx)(
            ui.div,
            {
              className: "ui-drawer__inner",
              __css: { display: "flex", flexDirection: "column", ...styles2.inner },
              children: cloneChildren
            }
          ),
          withDragBar && closeOnDrag && (placement === "top" || placement === "left") ? (0, import_jsx_runtime100.jsx)(DrawerDragBar, {}) : null
        ]
      }
    );
  }
);
var DrawerOverlay = motionForwardRef(
  ({ className, ...rest }, ref) => {
    const styles2 = useDrawer();
    const css4 = { ...styles2.overlay };
    return (0, import_jsx_runtime100.jsx)(
      ModalOverlay,
      {
        ref,
        className: cx("ui-drawer__overlay", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DrawerDragBar = ({
  className,
  ...rest
}) => {
  const styles2 = useDrawer();
  const css4 = { ...styles2.dragBar };
  return (0, import_jsx_runtime100.jsx)(
    ui.div,
    {
      className: cx("ui-drawer__drag-bar", className),
      __css: css4,
      ...rest
    }
  );
};
var DrawerCloseButton = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDrawer();
    const css4 = { ...styles2.closeButton };
    return (0, import_jsx_runtime100.jsx)(
      ModalCloseButton,
      {
        ref,
        className: cx("ui-drawer__close-button", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DrawerHeader = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDrawer();
    const css4 = { ...styles2.header };
    return (0, import_jsx_runtime100.jsx)(
      ModalHeader,
      {
        ref,
        className: cx("ui-drawer__header", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DrawerBody = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDrawer();
    const css4 = { ...styles2.body };
    return (0, import_jsx_runtime100.jsx)(
      ModalBody,
      {
        ref,
        className: cx("ui-drawer__body", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var DrawerFooter = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useDrawer();
    const css4 = { ...styles2.footer };
    return (0, import_jsx_runtime100.jsx)(
      ModalFooter,
      {
        ref,
        className: cx("ui-drawer__footer", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-select/dist/chunk-CIF2ZN57.mjs
var import_react121 = __toESM(require_react(), 1);
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var [NativeSelectProvider, useNativeSelect] = createContext2({
  name: "NativeSelectContext",
  errorMessage: `useNativeSelect returned is 'undefined'. Seems you forgot to wrap the components in "<NativeSelect />"`
});
var NativeSelect2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("NativeSelect", props2);
    let {
      className,
      children,
      placeholderInOptions = true,
      color: color2,
      h,
      height,
      minH,
      minHeight,
      items = [],
      placeholder,
      containerProps,
      iconProps,
      ...rest
    } = omitThemeProps(mergedProps);
    rest = useFormControlProps(rest);
    const { "aria-readonly": _ariaReadonly, ...formControlProps } = pickObject(
      rest,
      formControlProperties
    );
    const [layoutProps, selectProps] = splitObject(
      omitObject(rest, ["aria-readonly"]),
      layoutStyleProperties
    );
    let computedChildren = [];
    if (!children && items.length) {
      computedChildren = items.map((item, i) => {
        if ("value" in item) {
          const { label, value, ...props22 } = item;
          return (0, import_jsx_runtime101.jsx)(NativeOption, { value, ...props22, children: label }, i);
        } else if ("items" in item) {
          const { label, items: items2 = [], ...props22 } = item;
          return (0, import_jsx_runtime101.jsx)(NativeOptionGroup, { label, ...props22, children: items2.map(({ label: label2, value, ...props3 }, i2) => (0, import_jsx_runtime101.jsx)(NativeOption, { value, ...props3, children: label2 }, i2)) }, i);
        }
      }).filter(Boolean);
    }
    return (0, import_jsx_runtime101.jsx)(NativeSelectProvider, { value: styles2, children: (0, import_jsx_runtime101.jsxs)(
      ui.div,
      {
        className: "ui-select",
        __css: {
          position: "relative",
          w: "100%",
          h: "fit-content",
          color: color2,
          ...styles2.container
        },
        ...layoutProps,
        ...containerProps,
        ...formControlProps,
        children: [
          (0, import_jsx_runtime101.jsxs)(
            ui.select,
            {
              ref,
              className: cx("ui-select__field", className),
              __css: {
                pe: "2rem",
                h: h != null ? h : height,
                minH: minH != null ? minH : minHeight,
                ...styles2.field
              },
              ...selectProps,
              children: [
                placeholder ? (0, import_jsx_runtime101.jsx)(NativeOption, { value: "", hidden: !placeholderInOptions, children: placeholder }) : null,
                children != null ? children : computedChildren
              ]
            }
          ),
          (0, import_jsx_runtime101.jsx)(NativeSelectIcon, { ...iconProps, ...formControlProps })
        ]
      }
    ) });
  }
);
var NativeSelectIcon = ({
  className,
  children,
  ...rest
}) => {
  const styles2 = useNativeSelect();
  const css4 = {
    position: "absolute",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    pointerEvents: "none",
    top: "50%",
    transform: "translateY(-50%)",
    ...styles2.icon
  };
  const validChildren = getValidChildren(children);
  const cloneChildren = validChildren.map(
    (child) => (0, import_react121.cloneElement)(child, {
      focusable: false,
      "aria-hidden": true,
      style: {
        width: "1em",
        height: "1em",
        color: "currentColor"
      }
    })
  );
  return (0, import_jsx_runtime101.jsx)(ui.div, { className: cx("ui-select__icon", className), __css: css4, ...rest, children: isValidElement2(children) ? cloneChildren : (0, import_jsx_runtime101.jsx)(ChevronIcon, {}) });
};
var NativeOptionGroup = forwardRef22(
  (props2, ref) => (0, import_jsx_runtime101.jsx)(ui.optgroup, { ref, ...props2 })
);
var NativeOption = forwardRef22(
  (props2, ref) => (0, import_jsx_runtime101.jsx)(ui.option, { ref, ...props2 })
);

// node_modules/@yamada-ui/use-counter/dist/index.mjs
var import_react122 = __toESM(require_react(), 1);
var useCounter = ({
  min: min2 = Number.MIN_SAFE_INTEGER,
  max: max2 = Number.MAX_SAFE_INTEGER,
  keepWithinRange = true,
  ...props2
} = {}) => {
  var _a, _b;
  const onChange = useCallbackRef(props2.onChange);
  const [defaultValue, setValue] = (0, import_react122.useState)(() => {
    var _a2, _b2;
    if (props2.defaultValue == null) return "";
    return (_b2 = casting(props2.defaultValue, (_a2 = props2.step) != null ? _a2 : 1, props2.precision)) != null ? _b2 : "";
  });
  const isControlled = typeof props2.value !== "undefined";
  const value = isControlled ? props2.value : defaultValue;
  const countDecimal2 = getCountDecimal(parse3(value), (_a = props2.step) != null ? _a : 1);
  const precision = (_b = props2.precision) != null ? _b : countDecimal2;
  const update = (0, import_react122.useCallback)(
    (next2) => {
      if (next2 === value) return;
      if (!isControlled) setValue(next2.toString());
      onChange(next2.toString(), parse3(next2));
    },
    [onChange, isControlled, value]
  );
  const clamp3 = (0, import_react122.useCallback)(
    (value2) => {
      let nextValue = value2;
      if (keepWithinRange) nextValue = clampNumber(nextValue, min2, max2);
      return toPrecision(nextValue, precision);
    },
    [precision, keepWithinRange, max2, min2]
  );
  const increment = (0, import_react122.useCallback)(
    (step = ((_c) => (_c = props2.step) != null ? _c : 1)()) => {
      let next2;
      if (value === "") {
        next2 = parse3(step);
      } else {
        next2 = parse3(value) + step;
      }
      next2 = clamp3(next2);
      update(next2);
    },
    [clamp3, props2.step, update, value]
  );
  const decrement = (0, import_react122.useCallback)(
    (step = ((_d) => (_d = props2.step) != null ? _d : 1)()) => {
      let next2;
      if (value === "") {
        next2 = parse3(-step);
      } else {
        next2 = parse3(value) - step;
      }
      next2 = clamp3(next2);
      update(next2);
    },
    [clamp3, props2.step, update, value]
  );
  const reset = (0, import_react122.useCallback)(() => {
    var _a2, _b2;
    let next2;
    if (props2.defaultValue == null) {
      next2 = "";
    } else {
      next2 = (_b2 = casting(props2.defaultValue, (_a2 = props2.step) != null ? _a2 : 1, props2.precision)) != null ? _b2 : min2;
    }
    update(next2);
  }, [props2.defaultValue, props2.precision, props2.step, update, min2]);
  const cast2 = (0, import_react122.useCallback)(
    (value2) => {
      var _a2, _b2;
      const nextValue = (_b2 = casting(value2, (_a2 = props2.step) != null ? _a2 : 1, precision)) != null ? _b2 : min2;
      update(nextValue);
    },
    [precision, props2.step, update, min2]
  );
  const valueAsNumber = parse3(value);
  const isOut = valueAsNumber < min2 || max2 < valueAsNumber;
  const isMax = valueAsNumber === max2;
  const isMin = valueAsNumber === min2;
  return {
    isOut,
    isMax,
    isMin,
    precision,
    value,
    valueAsNumber,
    update,
    reset,
    increment,
    decrement,
    clamp: clamp3,
    cast: cast2,
    setValue
  };
};
var parse3 = (value) => parseFloat(value.toString().replace(/[^\w.-]+/g, ""));
var getCountDecimal = (value, step) => Math.max(countDecimal(step), countDecimal(value));
var casting = (value, step, precision) => {
  value = parse3(value);
  return !Number.isNaN(value) ? toPrecision(value, precision != null ? precision : getCountDecimal(value, step)) : void 0;
};

// node_modules/@yamada-ui/use-interval/dist/index.mjs
var import_react123 = __toESM(require_react(), 1);
var useInterval = (callback, delay2) => {
  const func2 = useCallbackRef(callback);
  (0, import_react123.useEffect)(() => {
    let timeoutId = null;
    if (delay2 !== null) timeoutId = window.setInterval(() => func2(), delay2);
    return () => {
      if (timeoutId) window.clearInterval(timeoutId);
    };
  }, [delay2, func2]);
};

// node_modules/@yamada-ui/number-input/dist/chunk-GLR53SQE.mjs
var import_react124 = __toESM(require_react(), 1);
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var isDefaultValidCharacter = (character2) => /^[Ee0-9+\-.]$/.test(character2);
var isValidNumericKeyboardEvent = ({ key, ctrlKey, altKey, metaKey }, isValid) => {
  if (key == null) return true;
  const isModifierKey = ctrlKey || altKey || metaKey;
  const isSingleCharacterKey = key.length === 1;
  if (!isSingleCharacterKey || isModifierKey) return true;
  return isValid(key);
};
var getStep = ({
  ctrlKey,
  shiftKey,
  metaKey
}) => {
  let ratio = 1;
  if (metaKey || ctrlKey) ratio = 0.1;
  if (shiftKey) ratio = 10;
  return ratio;
};
var useNumberInput = (props2 = {}) => {
  const {
    id: id4,
    name,
    value: valueProp,
    defaultValue,
    inputMode = "decimal",
    pattern = "[0-9]*(.[0-9]+)?",
    required,
    disabled,
    readOnly,
    focusInputOnChange = true,
    clampValueOnBlur = true,
    keepWithinRange = true,
    allowMouseWheel,
    min: min2 = Number.MIN_SAFE_INTEGER,
    max: max2 = Number.MAX_SAFE_INTEGER,
    step: stepProp,
    precision,
    parse: parseProp,
    format: formatProp,
    onInvalid: onInvalidProp,
    isValidCharacter: isValidCharacterProp,
    getAriaValueText: getAriaValueTextProp,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    "aria-invalid": isInvalid,
    ...rest
  } = useFormControlProps(props2);
  const formControlProps = pickObject(rest, formControlProperties);
  const isRequired = required;
  const isReadOnly = readOnly;
  const isDisabled2 = disabled;
  const [isFocused, setFocused] = (0, import_react124.useState)(false);
  const isInteractive = !(readOnly || disabled);
  const inputRef = (0, import_react124.useRef)(null);
  const inputSelectionRef = (0, import_react124.useRef)(null);
  const incrementRef = (0, import_react124.useRef)(null);
  const decrementRef = (0, import_react124.useRef)(null);
  const onFocus4 = useCallbackRef(
    handlerAll(onFocusProp, (ev) => {
      var _a, _b, _c;
      setFocused(true);
      if (!inputSelectionRef.current) return;
      ev.target.selectionStart = (_b = inputSelectionRef.current.start) != null ? _b : (_a = ev.currentTarget.value) == null ? void 0 : _a.length;
      ev.currentTarget.selectionEnd = (_c = inputSelectionRef.current.end) != null ? _c : ev.currentTarget.selectionStart;
    })
  );
  const onBlur4 = useCallbackRef(
    handlerAll(onBlurProp, () => {
      setFocused(false);
      if (clampValueOnBlur) validateAndClamp();
    })
  );
  const onInvalid = useCallbackRef(onInvalidProp);
  const getAriaValueText = useCallbackRef(getAriaValueTextProp);
  const isValidCharacter = useCallbackRef(
    isValidCharacterProp != null ? isValidCharacterProp : isDefaultValidCharacter
  );
  const {
    isMin,
    isMax,
    isOut,
    value,
    valueAsNumber,
    setValue,
    update,
    cast: cast2,
    ...counter4
  } = useCounter({
    value: valueProp,
    defaultValue,
    step: stepProp,
    min: min2,
    max: max2,
    precision,
    keepWithinRange,
    onChange: onChangeProp
  });
  const valueText = (0, import_react124.useMemo)(() => {
    let text = getAriaValueText == null ? void 0 : getAriaValueText(value);
    if (text != null) return text;
    text = value.toString();
    return !text ? void 0 : text;
  }, [value, getAriaValueText]);
  const sanitize2 = (0, import_react124.useCallback)(
    (value2) => value2.split("").filter(isValidCharacter).join(""),
    [isValidCharacter]
  );
  const parse4 = (0, import_react124.useCallback)(
    (value2) => {
      var _a;
      return (_a = parseProp == null ? void 0 : parseProp(value2)) != null ? _a : value2;
    },
    [parseProp]
  );
  const format = (0, import_react124.useCallback)(
    (value2) => {
      var _a;
      return ((_a = formatProp == null ? void 0 : formatProp(value2)) != null ? _a : value2).toString();
    },
    [formatProp]
  );
  const increment = (0, import_react124.useCallback)(
    (step = stepProp != null ? stepProp : 1) => {
      if (isInteractive) counter4.increment(step);
    },
    [isInteractive, counter4, stepProp]
  );
  const decrement = (0, import_react124.useCallback)(
    (step = stepProp != null ? stepProp : 1) => {
      if (isInteractive) counter4.decrement(step);
    },
    [isInteractive, counter4, stepProp]
  );
  const validateAndClamp = (0, import_react124.useCallback)(() => {
    let next2 = value;
    if (value === "") return;
    const valueStartsWithE = /^[eE]/.test(value.toString());
    if (valueStartsWithE) {
      setValue("");
    } else {
      if (valueAsNumber < min2) next2 = min2;
      if (valueAsNumber > max2) next2 = max2;
      cast2(next2);
    }
  }, [cast2, max2, min2, setValue, value, valueAsNumber]);
  const onChange = (0, import_react124.useCallback)(
    (ev) => {
      if (ev.nativeEvent.isComposing) return;
      const parsedInput = parse4(ev.currentTarget.value);
      update(sanitize2(parsedInput));
      inputSelectionRef.current = {
        start: ev.currentTarget.selectionStart,
        end: ev.currentTarget.selectionEnd
      };
    },
    [parse4, update, sanitize2]
  );
  const onKeyDown = (0, import_react124.useCallback)(
    (ev) => {
      if (ev.nativeEvent.isComposing) return;
      if (!isValidNumericKeyboardEvent(ev, isValidCharacter))
        ev.preventDefault();
      const step = getStep(ev) * (stepProp != null ? stepProp : 1);
      const keyMap = {
        ArrowUp: () => increment(step),
        ArrowDown: () => decrement(step),
        Home: () => update(min2),
        End: () => update(max2)
      };
      const action = keyMap[ev.key];
      if (!action) return;
      ev.preventDefault();
      action(ev);
    },
    [decrement, increment, isValidCharacter, max2, min2, stepProp, update]
  );
  const { up, down, stop, isSpinning } = useSpinner(increment, decrement);
  useAttributeObserver(incrementRef, ["disabled"], isSpinning, stop);
  useAttributeObserver(decrementRef, ["disabled"], isSpinning, stop);
  const focusInput = (0, import_react124.useCallback)(() => {
    if (focusInputOnChange)
      requestAnimationFrame(() => {
        var _a;
        (_a = inputRef.current) == null ? void 0 : _a.focus();
      });
  }, [focusInputOnChange]);
  const eventUp = (0, import_react124.useCallback)(
    (ev) => {
      ev.preventDefault();
      up();
      focusInput();
    },
    [focusInput, up]
  );
  const eventDown = (0, import_react124.useCallback)(
    (ev) => {
      ev.preventDefault();
      down();
      focusInput();
    },
    [focusInput, down]
  );
  useUpdateEffect(() => {
    if (valueAsNumber > max2) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(value), valueAsNumber);
    } else if (valueAsNumber < min2) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(value), valueAsNumber);
    }
  }, [valueAsNumber, value, format, onInvalid]);
  useSafeLayoutEffect(() => {
    if (!inputRef.current) return;
    const notInSync = inputRef.current.value != value;
    if (!notInSync) return;
    const parsedInput = parse4(inputRef.current.value);
    setValue(sanitize2(parsedInput));
  }, [parse4, sanitize2]);
  useEventListener(
    () => inputRef.current,
    "wheel",
    (ev) => {
      var _a, _b;
      const ownerDocument = (_b = (_a = inputRef.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
      const isFocused2 = ownerDocument.activeElement === inputRef.current;
      if (!allowMouseWheel || !isFocused2) return;
      ev.preventDefault();
      const step = getStep(ev) * (stepProp != null ? stepProp : 1);
      const direction = Math.sign(ev.deltaY);
      if (direction === -1) {
        increment(step);
      } else if (direction === 1) {
        decrement(step);
      }
    },
    { passive: false }
  );
  const getInputProps = (0, import_react124.useCallback)(
    (props22 = {}, ref = null) => ({
      id: id4,
      name,
      type: "text",
      role: "spinbutton",
      inputMode,
      pattern,
      required,
      disabled,
      readOnly,
      ...formControlProps,
      ...props22,
      min: min2,
      max: max2,
      step: stepProp,
      ref: mergeRefs(inputRef, ref),
      value: format(value),
      "aria-valuemin": min2,
      "aria-valuemax": max2,
      "aria-valuenow": Number.isNaN(valueAsNumber) ? void 0 : valueAsNumber,
      "aria-valuetext": valueText,
      "aria-invalid": ariaAttr(isInvalid != null ? isInvalid : isOut),
      autoComplete: "off",
      autoCorrect: "off",
      onChange: handlerAll(props22.onChange, onChange),
      onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
      onFocus: handlerAll(props22.onFocus, onFocus4),
      onBlur: handlerAll(props22.onBlur, onBlur4)
    }),
    [
      id4,
      name,
      inputMode,
      pattern,
      required,
      disabled,
      readOnly,
      formControlProps,
      min2,
      max2,
      stepProp,
      format,
      value,
      valueAsNumber,
      valueText,
      isInvalid,
      isOut,
      onChange,
      onKeyDown,
      onFocus4,
      onBlur4
    ]
  );
  const getIncrementProps = (0, import_react124.useCallback)(
    (props22 = {}, ref = null) => {
      var _a;
      const trulyDisabled = disabled || keepWithinRange && isMax;
      return {
        required,
        readOnly,
        disabled: trulyDisabled,
        ...formControlProps,
        ...props22,
        style: {
          ...props22.style,
          cursor: readOnly ? "not-allowed" : (_a = props22.style) == null ? void 0 : _a.cursor
        },
        ref: mergeRefs(ref, incrementRef),
        role: "button",
        tabIndex: -1,
        onPointerDown: handlerAll(props22.onPointerDown, (ev) => {
          if (ev.button === 0 && !trulyDisabled) eventUp(ev);
        }),
        onPointerLeave: handlerAll(props22.onPointerLeave, stop),
        onPointerUp: handlerAll(props22.onPointerUp, stop)
      };
    },
    [
      disabled,
      keepWithinRange,
      isMax,
      required,
      readOnly,
      formControlProps,
      stop,
      eventUp
    ]
  );
  const getDecrementProps = (0, import_react124.useCallback)(
    (props22 = {}, ref = null) => {
      var _a;
      const trulyDisabled = disabled || keepWithinRange && isMin;
      return {
        required,
        readOnly,
        disabled: trulyDisabled,
        ...formControlProps,
        ...props22,
        style: {
          ...props22.style,
          cursor: readOnly ? "not-allowed" : (_a = props22.style) == null ? void 0 : _a.cursor
        },
        ref: mergeRefs(ref, decrementRef),
        role: "button",
        tabIndex: -1,
        onPointerDown: handlerAll(props22.onPointerDown, (ev) => {
          if (ev.button === 0 && !trulyDisabled) eventDown(ev);
        }),
        onPointerLeave: handlerAll(props22.onPointerLeave, stop),
        onPointerUp: handlerAll(props22.onPointerUp, stop)
      };
    },
    [
      disabled,
      keepWithinRange,
      isMin,
      required,
      readOnly,
      formControlProps,
      stop,
      eventDown
    ]
  );
  return {
    props: rest,
    value: format(value),
    valueAsNumber,
    isFocused,
    isRequired,
    isReadOnly,
    isDisabled: isDisabled2,
    getInputProps,
    getIncrementProps,
    getDecrementProps
  };
};
var INTERVAL = 50;
var DELAY = 300;
var useSpinner = (increment, decrement) => {
  const [isSpinning, setIsSpinning] = (0, import_react124.useState)(false);
  const [action, setAction] = (0, import_react124.useState)(null);
  const [isOnce, setIsOnce] = (0, import_react124.useState)(true);
  const timeoutRef = (0, import_react124.useRef)(null);
  const removeTimeout = () => clearTimeout(timeoutRef.current);
  useInterval(
    () => {
      if (action === "increment") increment();
      if (action === "decrement") decrement();
    },
    isSpinning ? INTERVAL : null
  );
  const up = (0, import_react124.useCallback)(() => {
    if (isOnce) increment();
    timeoutRef.current = setTimeout(() => {
      setIsOnce(false);
      setIsSpinning(true);
      setAction("increment");
    }, DELAY);
  }, [increment, isOnce]);
  const down = (0, import_react124.useCallback)(() => {
    if (isOnce) decrement();
    timeoutRef.current = setTimeout(() => {
      setIsOnce(false);
      setIsSpinning(true);
      setAction("decrement");
    }, DELAY);
  }, [decrement, isOnce]);
  const stop = (0, import_react124.useCallback)(() => {
    setIsOnce(true);
    setIsSpinning(false);
    removeTimeout();
  }, []);
  (0, import_react124.useEffect)(() => {
    return () => removeTimeout();
  }, []);
  return { up, down, stop, isSpinning };
};
var useAttributeObserver = (ref, attributeFilter, enabled2, func2) => {
  (0, import_react124.useEffect)(() => {
    var _a;
    if (!ref.current || !enabled2) return;
    const ownerDocument = (_a = ref.current.ownerDocument.defaultView) != null ? _a : window;
    const observer2 = new ownerDocument.MutationObserver((changes) => {
      for (const { type, attributeName } of changes) {
        if (type === "attributes" && attributeName && attributeFilter.includes(attributeName))
          func2();
      }
    });
    observer2.observe(ref.current, { attributes: true, attributeFilter });
    return () => observer2.disconnect();
  });
};
var [NumberInputContextProvider, useNumberInputContext] = createContext2({
  strict: false,
  name: "NumberInputContext"
});
var NumberInput2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("NumberInput", props2);
    const {
      className,
      isStepper = true,
      containerProps,
      addonProps,
      incrementProps,
      decrementProps,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      getInputProps,
      getIncrementProps,
      getDecrementProps,
      props: rest
    } = useNumberInput(computedProps);
    const css4 = {
      position: "relative",
      zIndex: 0,
      ...styles2.container
    };
    return (0, import_jsx_runtime102.jsx)(
      NumberInputContextProvider,
      {
        value: { getInputProps, getIncrementProps, getDecrementProps, styles: styles2 },
        children: (0, import_jsx_runtime102.jsxs)(
          ui.div,
          {
            className: cx("ui-number-input", className),
            __css: css4,
            ...containerProps,
            children: [
              (0, import_jsx_runtime102.jsx)(
                NumberInputField,
                {
                  ...getInputProps(rest, ref)
                }
              ),
              isStepper ? (0, import_jsx_runtime102.jsxs)(NumberInputAddon, { ...addonProps, children: [
                (0, import_jsx_runtime102.jsx)(NumberIncrementStepper, { ...incrementProps }),
                (0, import_jsx_runtime102.jsx)(NumberDecrementStepper, { ...decrementProps })
              ] }) : null
            ]
          }
        )
      }
    );
  }
);
var NumberInputField = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useNumberInputContext();
    const css4 = {
      width: "100%",
      ...styles2.field
    };
    return (0, import_jsx_runtime102.jsx)(
      ui.input,
      {
        ref,
        className: cx("ui-number-input__field", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var NumberInputAddon = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useNumberInputContext();
    const css4 = {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      height: "calc(100% - 2px)",
      zIndex: "fallback(yamcha, 1)",
      ...styles2.addon
    };
    return (0, import_jsx_runtime102.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-number-input__addon", className),
        "aria-hidden": true,
        __css: css4,
        ...rest
      }
    );
  }
);
var Stepper2 = ui("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
});
var NumberIncrementStepper = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { getIncrementProps, styles: styles2 } = useNumberInputContext();
    const css4 = { ...styles2.stepper };
    return (0, import_jsx_runtime102.jsx)(
      Stepper2,
      {
        className: cx("ui-number-input__stepper--up", className),
        ...getIncrementProps(rest, ref),
        __css: css4,
        children: children != null ? children : (0, import_jsx_runtime102.jsx)(ChevronIcon, { __css: { transform: "rotate(180deg)" } })
      }
    );
  }
);
var NumberDecrementStepper = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { getDecrementProps, styles: styles2 } = useNumberInputContext();
    const css4 = { ...styles2.stepper };
    return (0, import_jsx_runtime102.jsx)(
      Stepper2,
      {
        className: cx("ui-number-input__stepper--down", className),
        ...getDecrementProps(rest, ref),
        __css: css4,
        children: children != null ? children : (0, import_jsx_runtime102.jsx)(ChevronIcon, {})
      }
    );
  }
);

// node_modules/@yamada-ui/pin-input/dist/chunk-FSK2DY7Q.mjs
var import_react125 = __toESM(require_react(), 1);
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var toArray2 = (value) => value == null ? void 0 : value.split("");
var validate = (value, type) => {
  const NUMERIC_REGEX = /^[0-9]+$/;
  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;
  const regex = type === "alphanumeric" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;
  return regex.test(value);
};
var [PinInputProvider, usePinInputContext] = createContext2({
  strict: false,
  name: "PinInputContext"
});
var { DescendantsContextProvider: DescendantsContextProvider4, useDescendants: useDescendants4, useDescendant: useDescendant2 } = createDescendant();
var PinInput2 = forwardRef22(
  ({ focusBorderColor, errorBorderColor, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("PinInput", {
      focusBorderColor,
      errorBorderColor,
      ...props2
    });
    let {
      id: id4,
      className,
      type = "number",
      placeholder = "",
      value,
      defaultValue,
      autoFocus,
      manageFocus = true,
      otp = false,
      mask,
      readOnly,
      "aria-readonly": ariaReadonly,
      onChange: onChangeProp,
      onComplete,
      items = 4,
      children,
      ...rest
    } = useFormControlProps(omitThemeProps(mergedProps));
    const formControlProps = (0, import_react125.useMemo)(
      () => ({
        ...pickObject(rest, formControlProperties),
        readOnly,
        "aria-readonly": ariaReadonly
      }),
      [ariaReadonly, readOnly, rest]
    );
    id4 != null ? id4 : id4 = (0, import_react125.useId)();
    const descendants = useDescendants4();
    const [moveFocus2, setMoveFocus] = (0, import_react125.useState)(true);
    const [focusedIndex, setFocusedIndex] = (0, import_react125.useState)(-1);
    (0, import_react125.useEffect)(() => {
      if (!autoFocus) return;
      const firstValue = descendants.firstValue();
      if (!firstValue) return;
      requestAnimationFrame(() => firstValue.node.focus());
    }, [autoFocus, descendants]);
    const [values, setValues2] = useControllableState({
      value: toArray2(value),
      defaultValue: toArray2(defaultValue) || [],
      onChange: (values2) => onChangeProp == null ? void 0 : onChangeProp(values2.join(""))
    });
    const focusNext = (0, import_react125.useCallback)(
      (index) => {
        if (!moveFocus2 || !manageFocus) return;
        const next2 = descendants.nextValue(index, void 0, false);
        if (!next2) return;
        requestAnimationFrame(() => next2.node.focus());
      },
      [descendants, moveFocus2, manageFocus]
    );
    const setValue = (0, import_react125.useCallback)(
      (value2, index, isFocus = true) => {
        var _a;
        let nextValues = [...values];
        nextValues[index] = value2;
        setValues2(nextValues);
        nextValues = nextValues.filter(Boolean);
        const isComplete = value2 !== "" && nextValues.length === descendants.count() && nextValues.every((value3) => value3 != null && value3 !== "");
        if (isComplete) {
          onComplete == null ? void 0 : onComplete(nextValues.join(""));
          (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();
        } else if (isFocus) {
          focusNext(index);
        }
      },
      [values, setValues2, descendants, onComplete, focusNext]
    );
    const getNextValue = (0, import_react125.useCallback)(
      (value2, eventValue) => {
        let nextValue = eventValue;
        if (!(value2 == null ? void 0 : value2.length)) return nextValue;
        if (value2[0] === eventValue.charAt(0)) {
          nextValue = eventValue.charAt(1);
        } else if (value2[0] === eventValue.charAt(1)) {
          nextValue = eventValue.charAt(0);
        }
        return nextValue;
      },
      []
    );
    const onChange = (0, import_react125.useCallback)(
      (index) => ({ target }) => {
        var _a;
        const eventValue = target.value;
        const currentValue = values[index];
        const nextValue = getNextValue(currentValue, eventValue);
        if (nextValue === "") {
          setValue("", index);
          return;
        }
        if (eventValue.length > 2) {
          if (!validate(eventValue, type)) return;
          const nextValue2 = eventValue.split("").filter((_, index2) => index2 < descendants.count());
          setValues2(nextValue2);
          if (nextValue2.length === descendants.count()) {
            onComplete == null ? void 0 : onComplete(nextValue2.join(""));
            (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();
          }
        } else {
          if (validate(nextValue, type)) setValue(nextValue, index);
          setMoveFocus(true);
        }
      },
      [
        descendants,
        getNextValue,
        onComplete,
        setValue,
        setValues2,
        type,
        values
      ]
    );
    const onKeyDown = (0, import_react125.useCallback)(
      (index) => ({ key, target }) => {
        var _a;
        if (key !== "Backspace" || !manageFocus) return;
        if (target.value === "") {
          const prevInput = descendants.prevValue(index, void 0, false);
          if (!prevInput) return;
          setValue("", index - 1, false);
          (_a = prevInput.node) == null ? void 0 : _a.focus();
          setMoveFocus(true);
        } else {
          setMoveFocus(false);
        }
      },
      [descendants, manageFocus, setValue]
    );
    const onFocus4 = (0, import_react125.useCallback)(
      (index) => () => setFocusedIndex(index),
      []
    );
    const onBlur4 = (0, import_react125.useCallback)(() => setFocusedIndex(-1), []);
    const getInputProps = (0, import_react125.useCallback)(
      ({
        index,
        ...props22
      }) => ({
        inputMode: type === "number" ? "numeric" : "text",
        type: mask ? "password" : type === "number" ? "tel" : "text",
        ...formControlProps,
        ...filterUndefined(props22),
        id: `${id4}-${index}`,
        value: values[index] || "",
        onChange: handlerAll(props22.onChange, onChange(index)),
        onKeyDown: handlerAll(props22.onKeyDown, onKeyDown(index)),
        onFocus: handlerAll(props22.onFocus, onFocus4(index)),
        onBlur: handlerAll(props22.onBlur, onBlur4),
        autoComplete: otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index && !readOnly && !props22.readOnly ? "" : placeholder
      }),
      [
        type,
        mask,
        formControlProps,
        id4,
        values,
        onChange,
        onKeyDown,
        onFocus4,
        onBlur4,
        otp,
        focusedIndex,
        readOnly,
        placeholder
      ]
    );
    const css4 = {
      display: "flex",
      alignItems: "center",
      ...styles2.container
    };
    let cloneChildren = getValidChildren(children);
    if (!cloneChildren.length)
      for (let i = 0; i < items; i++) {
        cloneChildren.push((0, import_jsx_runtime103.jsx)(PinInputField, {}, i));
      }
    return (0, import_jsx_runtime103.jsx)(DescendantsContextProvider4, { value: descendants, children: (0, import_jsx_runtime103.jsx)(PinInputProvider, { value: { getInputProps, styles: styles2 }, children: (0, import_jsx_runtime103.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-pin-input", className),
        __css: css4,
        ...rest,
        children: cloneChildren
      }
    ) }) });
  }
);
var PinInputField = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { getInputProps, styles: styles2 } = usePinInputContext();
    const { index, register } = useDescendant2();
    rest = useFormControlProps(rest);
    const css4 = { ...styles2.field };
    return (0, import_jsx_runtime103.jsx)(
      ui.input,
      {
        className: cx("ui-pin-input__field", className),
        ...getInputProps({ ...rest, ref: mergeRefs(register, ref), index }),
        __css: css4
      }
    );
  }
);

// node_modules/@yamada-ui/progress/dist/chunk-I3YVVCGV.mjs
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var CircleProgress2 = forwardRef22(
  (props2, ref) => {
    const [styles2, { size = "6em", ...mergedProps }] = useComponentStyle(
      "CircleProgress",
      props2
    );
    let {
      className,
      children,
      boxSize,
      thickness = "0.625rem",
      color: color2 = "primary",
      trackColor = "border",
      value = 0,
      min: min2 = 0,
      max: max2 = 100,
      isAnimation = false,
      isRounded,
      speed = ["1.4s", "2s"],
      ...rest
    } = omitThemeProps(mergedProps);
    boxSize != null ? boxSize : boxSize = replaceObject(
      size,
      (value2) => !isUnit(value2) ? useToken("sizes", value2) : value2
    );
    thickness = replaceObject(
      thickness,
      (value2) => !isUnit(value2) ? useToken("sizes", value2) : value2
    );
    const isTransparent = value === 0 && !isAnimation;
    const percent2 = valueToPercent(value, min2, max2);
    const interval = !isAnimation ? percent2 * 2.64 : void 0;
    const animation2 = useAnimation2({
      keyframes: {
        "0%": {
          strokeDasharray: "1, 400",
          strokeDashoffset: "0"
        },
        "50%": {
          strokeDasharray: "400, 400",
          strokeDashoffset: "-100"
        },
        "100%": {
          strokeDasharray: "400, 400",
          strokeDashoffset: "-260"
        }
      },
      duration: typeof speed[0] === "string" ? speed[0] : `${speed[0]}s`,
      iterationCount: "infinite",
      timingFunction: "linear"
    });
    const css4 = {
      ...styles2,
      fontSize: boxSize
    };
    const circleProps = isAnimation ? {
      animation: animation2
    } : {
      strokeDashoffset: 66,
      strokeDasharray: interval == null ? void 0 : `${interval} ${264 - interval}`,
      transitionProperty: "stroke-dasharray, stroke",
      transitionDuration: "0.6s",
      transitionTimingFunction: "ease"
    };
    return (0, import_jsx_runtime104.jsxs)(
      ui.div,
      {
        ref,
        className: cx("ui-circle-progress", className),
        __css: css4,
        ...rest,
        children: [
          (0, import_jsx_runtime104.jsxs)(Shape, { boxSize, isAnimation, speed, children: [
            (0, import_jsx_runtime104.jsx)(Circle, { stroke: trackColor, strokeWidth: thickness }),
            (0, import_jsx_runtime104.jsx)(
              Circle,
              {
                stroke: color2,
                strokeWidth: thickness,
                strokeLinecap: isRounded ? "round" : void 0,
                opacity: isTransparent ? 0 : void 0,
                ...circleProps
              }
            )
          ] }),
          children
        ]
      }
    );
  }
);
var Circle = ({ ...rest }) => (0, import_jsx_runtime104.jsx)(ui.circle, { cx: 50, cy: 50, r: 42, fill: "transparent", ...rest });
var Shape = ({ boxSize, isAnimation, speed, ...rest }) => {
  const animation2 = useAnimation2({
    keyframes: {
      "0%": {
        transform: "rotate(0deg)"
      },
      "100%": {
        transform: "rotate(360deg)"
      }
    },
    duration: typeof speed[1] === "string" ? speed[1] : `${speed[1]}s`,
    iterationCount: "infinite",
    timingFunction: "linear"
  });
  const css4 = {
    display: "block",
    boxSize,
    ...isAnimation ? { animation: animation2 } : {}
  };
  return (0, import_jsx_runtime104.jsx)(ui.svg, { viewBox: "0 0 100 100", __css: css4, ...rest });
};
var CircleProgressLabel = ui("span", {
  baseStyle: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "100%",
    fontSize: "0.25em",
    textAlign: "center"
  }
});

// node_modules/@yamada-ui/progress/dist/chunk-JKDRLJJ6.mjs
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var [ProgressProvider, useProgress] = createContext2({
  name: `ProgressStylesContext`,
  errorMessage: `useProgress returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
});
var Progress2 = forwardRef22((props2, ref) => {
  var _a, _b;
  const [styles2, mergedProps] = useMultiComponentStyle("Progress", props2);
  const {
    className,
    children,
    value,
    min: min2,
    max: max2,
    hasStripe,
    isStripeAnimation,
    isAnimation,
    speed,
    borderRadius: _borderRadius,
    rounded,
    ...rest
  } = omitThemeProps(mergedProps, ["filledTrackColor"]);
  const borderRadius = (_b = _borderRadius != null ? _borderRadius : rounded) != null ? _b : (_a = styles2.track) == null ? void 0 : _a.borderRadius;
  const css4 = {
    w: "100%",
    overflow: "hidden",
    pos: "relative",
    ...styles2.track
  };
  return (0, import_jsx_runtime105.jsx)(ProgressProvider, { value: styles2, children: (0, import_jsx_runtime105.jsxs)(
    ui.div,
    {
      ref,
      className: cx("ui-progress", className),
      __css: css4,
      borderRadius,
      ...rest,
      children: [
        (0, import_jsx_runtime105.jsx)(
          ProgressFilledTrack,
          {
            min: min2,
            max: max2,
            value,
            hasStripe,
            isStripeAnimation,
            isAnimation,
            speed,
            borderRadius
          }
        ),
        children
      ]
    }
  ) });
});
var ProgressFilledTrack = ({
  value = 0,
  min: min2 = 0,
  max: max2 = 100,
  hasStripe,
  isStripeAnimation,
  isAnimation,
  speed = "1.4s",
  ...rest
}) => {
  const percent2 = valueToPercent(value, min2, max2);
  const styles2 = useProgress();
  const stripeAnimation = useAnimation2({
    keyframes: {
      "0%": { bgPosition: "1rem 0" },
      "100%": { bgPosition: "0 0" }
    },
    duration: typeof speed === "string" ? speed : `${speed}s`,
    iterationCount: "infinite",
    timingFunction: "linear"
  });
  const interpolationAnimation = useAnimation2({
    keyframes: {
      "0%": { left: "-40%" },
      "100%": { left: "100%" }
    },
    duration: typeof speed === "string" ? speed : `${speed}s`,
    iterationCount: "infinite",
    timingFunction: "ease"
  });
  isStripeAnimation = !isAnimation && hasStripe && isStripeAnimation;
  const css4 = {
    ...isStripeAnimation ? {
      animation: stripeAnimation
    } : {},
    ...isAnimation ? {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: interpolationAnimation
    } : {}
  };
  const __css = {
    w: `${percent2}%`,
    h: "100%",
    ...styles2.filledTrack
  };
  return (0, import_jsx_runtime105.jsx)(ui.div, { css: css4, __css, ...rest });
};

// node_modules/@yamada-ui/radio/dist/chunk-AVG2WSQK.mjs
var import_react126 = __toESM(require_react(), 1);
var import_react127 = __toESM(require_react(), 1);
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var useRadio = ({
  id: id4,
  ...props2
}) => {
  id4 != null ? id4 : id4 = (0, import_react127.useId)();
  const {
    id: _id,
    name,
    value,
    isChecked: isCheckedProp,
    defaultIsChecked,
    required,
    disabled,
    readOnly,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    ...computedProps
  } = useFormControlProps({ id: id4, ...props2 });
  const [{ "aria-readonly": _ariaReadonly, ...formControlProps }, rest] = splitObject(computedProps, formControlProperties);
  const [isFocusVisible2, setIsFocusVisible] = (0, import_react127.useState)(false);
  const [isFocused, setFocused] = (0, import_react127.useState)(false);
  const [isHovered, setHovered] = (0, import_react127.useState)(false);
  const [isActive, setActive] = (0, import_react127.useState)(false);
  const [isChecked, setIsChecked] = (0, import_react127.useState)(!!defaultIsChecked);
  const isControlled = isCheckedProp !== void 0;
  const checked = isControlled ? isCheckedProp : isChecked;
  (0, import_react127.useEffect)(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  const onChange = useCallbackRef(
    (ev) => {
      if (readOnly || disabled) {
        ev.preventDefault();
        return;
      }
      if (!isControlled) setIsChecked(ev.target.checked);
      onChangeProp == null ? void 0 : onChangeProp(ev);
    },
    [readOnly, disabled, isControlled]
  );
  const onFocus4 = useCallbackRef(onFocusProp);
  const onBlur4 = useCallbackRef(onBlurProp);
  const onKeyDown = (0, import_react127.useCallback)(
    ({ key }) => {
      if (key === " ") setActive(true);
    },
    [setActive]
  );
  const onKeyUp = (0, import_react127.useCallback)(
    ({ key }) => {
      if (key === " ") setActive(false);
    },
    [setActive]
  );
  const getContainerProps = (0, import_react127.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      "data-checked": dataAttr(checked)
    }),
    [checked, formControlProps]
  );
  const getIconProps = (0, import_react127.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(checked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible2),
      "aria-hidden": true,
      onMouseDown: handlerAll(props22.onMouseDown, () => setActive(true)),
      onMouseUp: handlerAll(props22.onMouseUp, () => setActive(false)),
      onMouseEnter: handlerAll(props22.onMouseEnter, () => setHovered(true)),
      onMouseLeave: handlerAll(props22.onMouseLeave, () => setHovered(false))
    }),
    [checked, isActive, isFocused, isFocusVisible2, isHovered, formControlProps]
  );
  const getInputProps = (0, import_react127.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      id: id4,
      type: "radio",
      name,
      value,
      required,
      disabled,
      readOnly,
      checked,
      "aria-checked": checked,
      style: {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      },
      onChange: handlerAll(props22.onChange, onChange),
      onBlur: handlerAll(props22.onBlur, onBlur4, () => setFocused(false)),
      onFocus: handlerAll(props22.onFocus, onFocus4, () => setFocused(true)),
      onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
      onKeyUp: handlerAll(props22.onKeyUp, onKeyUp)
    }),
    [
      formControlProps,
      id4,
      name,
      value,
      required,
      disabled,
      readOnly,
      checked,
      onChange,
      onBlur4,
      onFocus4,
      onKeyDown,
      onKeyUp
    ]
  );
  const getLabelProps = (0, import_react127.useCallback)(
    (props22 = {}, ref = null) => ({
      ...formControlProps,
      ...props22,
      ref,
      onMouseDown: handlerAll(props22.onMouseDown, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      onTouchStart: handlerAll(props22.onTouchStart, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      "data-checked": dataAttr(checked)
    }),
    [checked, formControlProps]
  );
  return {
    props: rest,
    isFocusVisible: isFocusVisible2,
    isFocused,
    isHovered,
    isActive,
    isChecked: checked,
    getContainerProps,
    getInputProps,
    getIconProps,
    getLabelProps
  };
};
var Radio2 = (0, import_react127.forwardRef)(
  (props2, ref) => {
    var _a, _b, _c, _d;
    const group = useRadioGroupContext();
    const { value: groupValue, ...groupProps } = { ...group };
    const control = useFormControl(props2);
    const [styles2, mergedProps] = useMultiComponentStyle("Radio", {
      ...groupProps,
      ...props2
    });
    const {
      className,
      gap = "0.5rem",
      isRequired = (_a = groupProps.isRequired) != null ? _a : control.isRequired,
      isReadOnly = (_b = groupProps.isReadOnly) != null ? _b : control.isReadOnly,
      isDisabled: isDisabled2 = (_c = groupProps.isDisabled) != null ? _c : control.isDisabled,
      isInvalid = (_d = groupProps.isInvalid) != null ? _d : control.isInvalid,
      iconProps,
      inputProps,
      labelProps,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const isCheckedProp = groupValue && computedProps.value ? groupValue === computedProps.value : computedProps.isChecked;
    const onChange = groupProps.onChange && computedProps.value ? funcAll(groupProps.onChange, computedProps.onChange) : computedProps.onChange;
    const {
      isChecked,
      getContainerProps,
      getInputProps,
      getIconProps,
      getLabelProps,
      props: rest
    } = useRadio({
      ...computedProps,
      isRequired,
      isReadOnly,
      isDisabled: isDisabled2,
      isInvalid,
      isChecked: isCheckedProp,
      onChange
    });
    const tabIndex = !groupValue ? 0 : isChecked ? 0 : -1;
    return (0, import_jsx_runtime106.jsxs)(
      ui.label,
      {
        className: cx("ui-radio", className),
        ...getContainerProps(rest),
        __css: {
          cursor: "pointer",
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          verticalAlign: "top",
          gap,
          ...styles2.container
        },
        children: [
          (0, import_jsx_runtime106.jsx)(
            ui.input,
            {
              className: "ui-radio__input",
              ...getInputProps(
                {
                  ...inputProps,
                  tabIndex
                },
                ref
              )
            }
          ),
          (0, import_jsx_runtime106.jsx)(
            ui.span,
            {
              className: "ui-radio__icon",
              ...getIconProps(iconProps),
              __css: {
                position: "relative",
                display: "inline-block",
                userSelect: "none",
                ...styles2.icon
              }
            }
          ),
          (0, import_jsx_runtime106.jsx)(
            ui.span,
            {
              className: "ui-radio__label",
              ...getLabelProps(labelProps),
              __css: { ...styles2.label },
              children
            }
          )
        ]
      }
    );
  }
);
Radio2.displayName = "Radio";
var isEvent2 = (value) => value && isObject(value) && isObject(value.target);
var useRadioGroup = ({
  id: id4,
  name,
  isNative,
  value: valueProp,
  defaultValue,
  onChange: onChangeProp,
  ...props2
}) => {
  id4 != null ? id4 : id4 = (0, import_react126.useId)();
  name != null ? name : name = `radio-${id4}`;
  const onChangeRef = useCallbackRef(onChangeProp);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeRef
  });
  const containerRef = (0, import_react126.useRef)(null);
  const onFocus4 = (0, import_react126.useCallback)(() => {
    const container = containerRef.current;
    if (!container) return;
    let query = `input:not(:disabled):checked`;
    let firstInput = container.querySelector(query);
    if (firstInput) {
      firstInput.focus();
    } else {
      query = `input:not(:disabled)`;
      firstInput = container.querySelector(query);
      firstInput == null ? void 0 : firstInput.focus();
    }
  }, []);
  const onChange = (0, import_react126.useCallback)(
    (evOrValue) => {
      const nextValue = isEvent2(evOrValue) ? evOrValue.target.value : evOrValue;
      setValue(nextValue);
    },
    [setValue]
  );
  const getContainerProps = (0, import_react126.useCallback)(
    (props22 = {}, ref = null) => ({
      role: "radiogroup",
      ...props22,
      ref: mergeRefs(ref, containerRef)
    }),
    []
  );
  const getRadioProps = (0, import_react126.useCallback)(
    (props22 = {}, ref = null) => {
      const isChecked = props22.value === value;
      return {
        ...props22,
        ref,
        name,
        [isNative ? "checked" : "isChecked"]: value != null ? isChecked : void 0,
        "aria-checked": isChecked,
        onChange
      };
    },
    [name, value, onChange, isNative]
  );
  return {
    props: props2,
    id: id4,
    name,
    value,
    setValue,
    onChange,
    onFocus: onFocus4,
    getContainerProps,
    getRadioProps
  };
};
var [RadioGroupProvider, useRadioGroupContext] = createContext2({
  strict: false,
  name: "RadioGroupContext"
});
var RadioGroup = (0, import_react126.forwardRef)(
  ({
    id: idProp,
    className,
    size,
    variant,
    colorScheme,
    children,
    items = [],
    direction = "column",
    gap,
    ...props2
  }, ref) => {
    const {
      labelId,
      isRequired,
      isReadOnly,
      isDisabled: isDisabled2,
      isInvalid,
      ...computedProps
    } = useFormControl({
      id: idProp,
      ...props2
    });
    const {
      id: id4,
      name,
      value,
      onChange,
      getContainerProps,
      props: rest
    } = useRadioGroup(computedProps);
    const validChildren = getValidChildren(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props22 }, i) => (0, import_jsx_runtime107.jsx)(Radio2, { value: value2, ...props22, children: label }, i));
    }
    return (0, import_jsx_runtime107.jsx)(
      RadioGroupProvider,
      {
        value: {
          size,
          variant,
          colorScheme,
          isRequired,
          isReadOnly,
          isDisabled: isDisabled2,
          isInvalid,
          name,
          value,
          onChange
        },
        children: (0, import_jsx_runtime107.jsx)(
          Flex,
          {
            ref,
            className: cx("ui-radio-group", className),
            gap: gap != null ? gap : direction === "row" ? "1rem" : void 0,
            ...getContainerProps({
              id: id4,
              "aria-labelledby": labelId,
              ...rest
            }),
            direction,
            children: children != null ? children : computedChildren
          }
        )
      }
    );
  }
);
RadioGroup.displayName = "RadioGroup";

// node_modules/@yamada-ui/segmented-control/dist/chunk-SU5UXSLN.mjs
var import_react128 = __toESM(require_react(), 1);
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var { DescendantsContextProvider: DescendantsContextProvider5, useDescendants: useDescendants5, useDescendant: useDescendant3 } = createDescendant();
var [SegmentedControlProvider, useSegmentedControl] = createContext2({
  strict: false,
  name: "SegmentedControlContext"
});
var SegmentedControl2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle(
      "SegmentedControl",
      props2
    );
    let {
      className,
      id: id4,
      name,
      isReadOnly,
      isDisabled: isDisabled2,
      children,
      items = [],
      value,
      defaultValue,
      onChange: onChangeProp,
      ...rest
    } = omitThemeProps(mergedProps);
    id4 != null ? id4 : id4 = (0, import_react128.useId)();
    name != null ? name : name = `segmented-control-${(0, import_react128.useId)()}`;
    const onChangeRef = useCallbackRef(onChangeProp);
    const descendants = useDescendants5();
    const [focusedIndex, setFocusedIndex] = (0, import_react128.useState)(-1);
    const [isFocusVisible2, setIsFocusVisible] = (0, import_react128.useState)(false);
    const containerRef = (0, import_react128.useRef)(null);
    const [selectedValue, setSelectedValue] = useControllableState({
      value,
      defaultValue,
      onChange: onChangeRef
    });
    const onChange = (0, import_react128.useCallback)(
      (ev) => {
        if (isDisabled2 || isReadOnly) {
          ev.preventDefault();
          return;
        }
        setSelectedValue(ev.target.value);
      },
      [isDisabled2, isReadOnly, setSelectedValue]
    );
    const onFocus4 = (0, import_react128.useCallback)(
      (index, skip) => {
        if (isDisabled2) return;
        if (skip) {
          const next2 = descendants.enabledNextValue(index);
          if (next2) setFocusedIndex(next2.index);
        } else {
          setFocusedIndex(index);
        }
      },
      [descendants, isDisabled2]
    );
    const onBlur4 = (0, import_react128.useCallback)(() => setFocusedIndex(-1), []);
    const getContainerProps = (0, import_react128.useCallback)(
      (props22 = {}, ref2 = null) => ({
        ...rest,
        ...props22,
        ref: mergeRefs(containerRef, ref2),
        id: id4,
        "aria-disabled": ariaAttr(isDisabled2),
        "data-readonly": dataAttr(isReadOnly),
        onBlur: handlerAll(props22.onBlur, onBlur4)
      }),
      [id4, isDisabled2, isReadOnly, onBlur4, rest]
    );
    const getInputProps = (0, import_react128.useCallback)(
      ({
        index,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        ...props22
      }, ref2 = null) => {
        var _a, _b, _c, _d;
        const disabled = (_b = (_a = props22.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled2;
        const readOnly = (_d = (_c = props22.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;
        const checked = props22.value === selectedValue;
        return {
          ...props22,
          ref: ref2,
          id: `${id4}-${index}`,
          type: "radio",
          name,
          disabled: disabled || readOnly,
          readOnly,
          checked,
          "aria-disabled": ariaAttr(disabled),
          "data-readonly": dataAttr(readOnly),
          "data-checked": dataAttr(checked),
          "data-focus": dataAttr(index === focusedIndex),
          style: {
            border: "0px",
            clip: "rect(0px, 0px, 0px, 0px)",
            height: "1px",
            width: "1px",
            margin: "-1px",
            padding: "0px",
            overflow: "hidden",
            whiteSpace: "nowrap",
            position: "absolute"
          },
          onChange: handlerAll(
            props22.onChange,
            (ev) => !disabled && !readOnly ? onChange(ev) : {}
          )
        };
      },
      [isDisabled2, isReadOnly, selectedValue, id4, name, focusedIndex, onChange]
    );
    const getLabelProps = (0, import_react128.useCallback)(
      ({
        index,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        ...props22
      }, ref2 = null) => {
        var _a, _b, _c, _d;
        const disabled = (_b = (_a = props22.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled2;
        const readOnly = (_d = (_c = props22.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;
        const checked = props22.value === selectedValue;
        const focused = index === focusedIndex;
        return {
          ...props22,
          ref: ref2,
          "aria-disabled": ariaAttr(disabled),
          "data-readonly": dataAttr(readOnly),
          "data-checked": dataAttr(checked),
          "data-focus": dataAttr(focused),
          "data-focus-visible": dataAttr(focused && isFocusVisible2),
          onFocus: handlerAll(
            props22.onFocus,
            () => onFocus4(index, disabled || readOnly || false)
          ),
          ...disabled || readOnly ? {
            _hover: {},
            _active: {},
            _focus: {},
            _invalid: {},
            _focusVisible: {}
          } : {}
        };
      },
      [
        focusedIndex,
        isDisabled2,
        isFocusVisible2,
        isReadOnly,
        onFocus4,
        selectedValue
      ]
    );
    (0, import_react128.useEffect)(() => {
      return trackFocusVisible(setIsFocusVisible);
    }, []);
    const css4 = {
      display: "inline-flex",
      alignItems: "center",
      ...styles2.container
    };
    const validChildren = getValidChildren(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props22 }, i) => (0, import_jsx_runtime108.jsx)(SegmentedControlButton, { value: value2, ...props22, children: label }, i));
    } else {
      computedChildren = validChildren;
    }
    if (selectedValue == null && defaultValue == null) {
      for (const child of computedChildren) {
        if (child.type !== SegmentedControlButton) {
          if (child.type.displayName !== SegmentedControlButton.displayName)
            continue;
        }
        const value2 = child.props.value;
        setSelectedValue(value2);
        break;
      }
    }
    return (0, import_jsx_runtime108.jsx)(DescendantsContextProvider5, { value: descendants, children: (0, import_jsx_runtime108.jsx)(
      SegmentedControlProvider,
      {
        value: { getInputProps, getLabelProps, styles: styles2, selectedValue },
        children: (0, import_jsx_runtime108.jsx)(LayoutGroup, { id: id4, children: (0, import_jsx_runtime108.jsx)(
          ui.div,
          {
            ...getContainerProps({}, ref),
            className: cx("ui-segmented-control", className),
            __css: css4,
            children: computedChildren
          }
        ) })
      }
    ) });
  }
);
var SegmentedControlButton = forwardRef22(
  ({
    className,
    disabled,
    readOnly,
    isDisabled: isDisabled2,
    isReadOnly,
    value,
    onChange,
    children,
    motionProps,
    ...rest
  }, ref) => {
    const [, isMounted] = useIsMounted({ rerender: true });
    const { selectedValue, getInputProps, getLabelProps, styles: styles2 } = useSegmentedControl();
    const { index, register } = useDescendant3({
      disabled: isDisabled2 || isReadOnly
    });
    const props2 = {
      index,
      value,
      disabled,
      readOnly,
      isDisabled: isDisabled2,
      isReadOnly
    };
    const css4 = {
      position: "relative",
      cursor: "pointer",
      flex: "1 1 0%",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      ...styles2.button
    };
    const isSelected = selectedValue === value;
    return (0, import_jsx_runtime108.jsxs)(
      ui.label,
      {
        ...getLabelProps(props2),
        className: cx("ui-segmented-control__button", className),
        __css: css4,
        ...rest,
        children: [
          (0, import_jsx_runtime108.jsx)(
            ui.input,
            {
              ...getInputProps({ onChange, ...props2 }, mergeRefs(register, ref))
            }
          ),
          isSelected && isMounted ? (0, import_jsx_runtime108.jsx)(SegmentedControlCursor, { ...motionProps }) : null,
          (0, import_jsx_runtime108.jsx)(ui.span, { zIndex: "1", children })
        ]
      }
    );
  }
);
SegmentedControlButton.displayName = "SegmentedControlButton";
var SegmentedControlCursor = ({
  className,
  transition,
  ...rest
}) => {
  const { styles: styles2 } = useSegmentedControl();
  const css4 = {
    position: "absolute",
    w: "100%",
    h: "100%",
    ...styles2.cursor
  };
  return (0, import_jsx_runtime108.jsx)(
    Motion,
    {
      className: cx("ui-segmented-control__cursor", className),
      layoutDependency: false,
      layoutId: "cursor",
      transition: {
        type: "spring",
        bounce: 0.15,
        duration: 0.4,
        ...transition
      },
      __css: css4,
      ...rest
    }
  );
};

// node_modules/@yamada-ui/use-outside-click/dist/index.mjs
var import_react129 = __toESM(require_react(), 1);
var useOutsideClick = ({
  ref,
  handler,
  enabled: enabled2 = true
}) => {
  const handlerRef = useCallbackRef(handler);
  const state = (0, import_react129.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  (0, import_react129.useEffect)(() => {
    if (!enabled2) return;
    const onPointerDown = (ev) => {
      if (isValidEvent(ev, ref)) state.current.isPointerDown = true;
    };
    const onMouseUp = (ev) => {
      if (state.current.ignoreEmulatedMouseEvents) {
        state.current.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state.current.isPointerDown && handler && isValidEvent(ev, ref)) {
        state.current.isPointerDown = false;
        handlerRef(ev);
      }
    };
    const onTouchEnd = (ev) => {
      state.current.ignoreEmulatedMouseEvents = true;
      if (handler && state.current.isPointerDown && isValidEvent(ev, ref)) {
        state.current.isPointerDown = false;
        handlerRef(ev);
      }
    };
    const doc = getOwnerDocument(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, handlerRef, state, enabled2]);
};
var isValidEvent = (ev, ref) => {
  var _a;
  const target = ev.target;
  if ("button" in ev && ev.button > 0) return false;
  if (target) {
    if (!getOwnerDocument(target).contains(target)) return false;
  }
  return !((_a = ref.current) == null ? void 0 : _a.contains(target));
};

// node_modules/@yamada-ui/select/dist/chunk-TJRPNWXC.mjs
var import_react130 = __toESM(require_react(), 1);
var isTargetOption = (target) => {
  var _a;
  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("option"));
};
var {
  DescendantsContextProvider: SelectDescendantsContextProvider,
  useDescendantsContext: useSelectDescendantsContext,
  useDescendants: useSelectDescendants,
  useDescendant: useSelectDescendant
} = createDescendant();
var [SelectProvider, useSelectContext] = createContext2({
  strict: false,
  name: "SelectContext"
});
var useSelect = ({
  placeholder,
  closeOnBlur = true,
  closeOnEsc = true,
  closeOnSelect = true,
  placeholderInOptions = true,
  omitSelectedValues = false,
  maxSelectValues,
  isEmpty: isEmpty2,
  placement = "bottom-start",
  duration = 0.2,
  isOpen: isOpenProp,
  defaultIsOpen,
  onOpen: onOpenProp,
  onClose: onCloseProp,
  optionProps,
  ...rest
}) => {
  rest = useFormControlProps(rest);
  const { "aria-readonly": _ariaReadonly, ...formControlProps } = pickObject(
    rest,
    formControlProperties
  );
  const [containerProps, fieldProps] = splitObject(
    omitObject(rest, ["value", "defaultValue", "onChange", "aria-readonly"]),
    layoutStyleProperties
  );
  const descendants = useSelectDescendants();
  const [focusedIndex, setFocusedIndex] = (0, import_react130.useState)(-1);
  const [isAllSelected, setIsAllSelected] = (0, import_react130.useState)(false);
  const containerRef = (0, import_react130.useRef)(null);
  const fieldRef = (0, import_react130.useRef)(null);
  const listRef = (0, import_react130.useRef)(null);
  const timeoutIds = (0, import_react130.useRef)(/* @__PURE__ */ new Set([]));
  const [value, setValue] = useControllableState({
    value: rest.value,
    defaultValue: rest.defaultValue,
    onChange: rest.onChange
  });
  const [label, setLabel] = (0, import_react130.useState)(void 0);
  const isFocused = focusedIndex > -1;
  const isMulti = isArray(value);
  const isEmptyValue = (!isMulti ? !value : !value.length) && !(placeholder && placeholderInOptions);
  const selectedValues = descendants.values(
    ({ node: node3 }) => {
      var _a;
      return isMulti && value.includes((_a = node3.dataset.value) != null ? _a : "");
    }
  );
  const selectedIndexes = selectedValues.map(({ index }) => index);
  const enabledValues = descendants.enabledValues(
    ({ index }) => !selectedIndexes.includes(index)
  );
  const onFocusFirst = (0, import_react130.useCallback)(() => {
    const id4 = setTimeout(() => {
      const first = descendants.enabledFirstValue();
      if (!first) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(first.index);
      } else {
        if (selectedIndexes.includes(first.index)) {
          const enabledFirst = enabledValues[0];
          setFocusedIndex(enabledFirst.index);
        } else {
          setFocusedIndex(first.index);
        }
      }
    });
    timeoutIds.current.add(id4);
  }, [descendants, enabledValues, isMulti, omitSelectedValues, selectedIndexes]);
  const onFocusLast = (0, import_react130.useCallback)(() => {
    const id4 = setTimeout(() => {
      const last = descendants.enabledLastValue();
      if (!last) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(last.index);
      } else {
        if (selectedIndexes.includes(last.index)) {
          const enabledLast = enabledValues.reverse()[0];
          setFocusedIndex(enabledLast.index);
        } else {
          setFocusedIndex(last.index);
        }
      }
    });
    timeoutIds.current.add(id4);
  }, [descendants, enabledValues, isMulti, omitSelectedValues, selectedIndexes]);
  const onFocusSelected = (0, import_react130.useCallback)(() => {
    const id4 = setTimeout(() => {
      const values = descendants.enabledValues();
      const selected = values.find(
        ({ node: node3 }) => {
          var _a;
          return !isMulti ? node3.dataset.value === value : value.includes((_a = node3.dataset.value) != null ? _a : "");
        }
      );
      if (selected) setFocusedIndex(selected.index);
    });
    timeoutIds.current.add(id4);
  }, [descendants, isMulti, value]);
  const onFocusNext = (0, import_react130.useCallback)(() => {
    const id4 = setTimeout(() => {
      var _a;
      const next2 = descendants.enabledNextValue(focusedIndex);
      if (!next2) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(next2.index);
      } else {
        if (selectedIndexes.includes(next2.index)) {
          const enabledNext = (_a = enabledValues.find(({ index }) => next2.index < index)) != null ? _a : enabledValues[0];
          setFocusedIndex(enabledNext.index);
        } else {
          setFocusedIndex(next2.index);
        }
      }
    });
    timeoutIds.current.add(id4);
  }, [
    descendants,
    enabledValues,
    focusedIndex,
    isMulti,
    omitSelectedValues,
    selectedIndexes,
    setFocusedIndex
  ]);
  const onFocusPrev = (0, import_react130.useCallback)(() => {
    const id4 = setTimeout(() => {
      var _a;
      const prev2 = descendants.enabledPrevValue(focusedIndex);
      if (!prev2) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(prev2.index);
      } else {
        if (selectedIndexes.includes(prev2.index)) {
          const enabledPrev = (_a = enabledValues.reverse().find(({ index }) => index < prev2.index)) != null ? _a : enabledValues[0];
          setFocusedIndex(enabledPrev.index);
        } else {
          setFocusedIndex(prev2.index);
        }
      }
    });
    timeoutIds.current.add(id4);
  }, [
    descendants,
    enabledValues,
    focusedIndex,
    isMulti,
    omitSelectedValues,
    selectedIndexes,
    setFocusedIndex
  ]);
  const onFocusFirstOrSelected = isEmptyValue || omitSelectedValues ? onFocusFirst : onFocusSelected;
  const onFocusLastOrSelected = isEmptyValue || omitSelectedValues ? onFocusLast : onFocusSelected;
  const onChangeLabel = (0, import_react130.useCallback)(
    (newValue, runOmit = true) => {
      const values = descendants.values();
      if (!values.length) return;
      const selectedValues2 = values.filter(({ node: node3 }) => node3.dataset.value === newValue).map(({ node: node3, index }) => {
        var _a;
        if (!(!!placeholder && placeholderInOptions) || index !== 0) {
          const el = Array.from(node3.children).find(
            (child) => child.getAttribute("data-label") !== null
          );
          return (_a = el == null ? void 0 : el.innerHTML) != null ? _a : "";
        } else {
          return void 0;
        }
      });
      setLabel((prev2) => {
        if (!isMulti) {
          return selectedValues2[0];
        } else {
          selectedValues2.forEach((selectedValue) => {
            const isSelected = isArray(prev2) && prev2.includes(selectedValue != null ? selectedValue : "");
            if (!isSelected) {
              prev2 = [...isArray(prev2) ? prev2 : [], selectedValue];
            } else if (runOmit) {
              prev2 = isArray(prev2) ? prev2.filter((value2) => value2 !== selectedValue) : void 0;
            }
          });
          return prev2;
        }
      });
    },
    [descendants, isMulti, placeholder, placeholderInOptions]
  );
  const onChange = (0, import_react130.useCallback)(
    (newValue) => {
      setValue((prev2) => {
        if (!isArray(prev2)) {
          return newValue;
        } else {
          const isSelected = prev2.includes(newValue);
          if (!isSelected) {
            return [...prev2, newValue];
          } else {
            return prev2.filter((value2) => value2 !== newValue);
          }
        }
      });
      onChangeLabel(newValue);
    },
    [onChangeLabel, setValue]
  );
  const onClear = (0, import_react130.useCallback)(
    (ev) => {
      ev.stopPropagation();
      setValue([]);
      setLabel(void 0);
    },
    [setLabel, setValue]
  );
  const {
    isOpen,
    onOpen: onInternalOpen,
    onClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const onOpen = (0, import_react130.useCallback)(() => {
    if (formControlProps.disabled || formControlProps.readOnly) return;
    if (isEmpty2 || isAllSelected) return;
    onInternalOpen();
  }, [formControlProps, isEmpty2, isAllSelected, onInternalOpen]);
  const onSelect = (0, import_react130.useCallback)(() => {
    var _a, _b;
    let enabledValue = descendants.value(focusedIndex);
    if ("disabled" in ((_a = enabledValue == null ? void 0 : enabledValue.node.dataset) != null ? _a : {}))
      enabledValue = void 0;
    if (!enabledValue) return;
    const value2 = (_b = enabledValue.node.dataset.value) != null ? _b : "";
    onChange(value2);
    if (closeOnSelect) onClose();
    if (omitSelectedValues) onFocusNext();
  }, [
    closeOnSelect,
    descendants,
    focusedIndex,
    omitSelectedValues,
    onChange,
    onClose,
    onFocusNext
  ]);
  const onClick2 = (0, import_react130.useCallback)(() => {
    if (isOpen) return;
    onOpen();
    onFocusFirstOrSelected();
  }, [isOpen, onFocusFirstOrSelected, onOpen]);
  const onFocus4 = (0, import_react130.useCallback)(() => {
    if (isOpen) return;
    onOpen();
    onFocusFirstOrSelected();
  }, [isOpen, onFocusFirstOrSelected, onOpen]);
  const onBlur4 = (0, import_react130.useCallback)(
    (ev) => {
      const relatedTarget = getEventRelatedTarget(ev);
      if (isContains(containerRef.current, relatedTarget)) return;
      if (!closeOnBlur) return;
      if (isOpen) onClose();
    },
    [closeOnBlur, isOpen, onClose]
  );
  const onKeyDown = (0, import_react130.useCallback)(
    (ev) => {
      if (ev.key === " ") ev.key = ev.code;
      if (formControlProps.disabled || formControlProps.readOnly) return;
      const actions = {
        ArrowDown: isFocused ? () => onFocusNext() : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : void 0,
        ArrowUp: isFocused ? () => onFocusPrev() : !isOpen ? funcAll(onOpen, onFocusLastOrSelected) : void 0,
        Space: isFocused ? onSelect : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : void 0,
        Enter: isFocused ? onSelect : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : void 0,
        Home: isOpen ? onFocusFirst : void 0,
        End: isOpen ? onFocusLast : void 0,
        Escape: closeOnEsc ? onClose : void 0
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action();
    },
    [
      formControlProps.disabled,
      formControlProps.readOnly,
      isFocused,
      isOpen,
      onOpen,
      onFocusFirstOrSelected,
      onFocusLastOrSelected,
      onSelect,
      onFocusFirst,
      onFocusLast,
      closeOnEsc,
      onClose,
      onFocusNext,
      onFocusPrev
    ]
  );
  useOutsideClick({
    ref: containerRef,
    handler: onClose,
    enabled: isOpen && closeOnBlur
  });
  (0, import_react130.useEffect)(() => {
    if (!isMulti) return;
    if (!omitSelectedValues && isUndefined(maxSelectValues)) return;
    const isAll = value.length > 0 && value.length === descendants.count();
    const isMax = value.length === maxSelectValues;
    if (isAll || isMax) {
      onClose();
      setIsAllSelected(true);
    } else {
      setIsAllSelected(false);
    }
  }, [
    omitSelectedValues,
    value,
    descendants,
    isMulti,
    onClose,
    maxSelectValues
  ]);
  useUpdateEffect(() => {
    if (!isOpen) setFocusedIndex(-1);
  }, [isOpen]);
  useUnmountEffect(() => {
    timeoutIds.current.forEach((id4) => clearTimeout(id4));
    timeoutIds.current.clear();
  });
  const getPopoverProps = (0, import_react130.useCallback)(
    (props2) => ({
      matchWidth: true,
      ...rest,
      ...props2,
      isOpen,
      onOpen,
      onClose,
      placement,
      duration,
      trigger: "never",
      closeOnButton: false,
      closeOnBlur
    }),
    [duration, closeOnBlur, onClose, onOpen, placement, rest, isOpen]
  );
  const getContainerProps = (0, import_react130.useCallback)(
    (props2 = {}, ref = null) => ({
      ref: mergeRefs(containerRef, ref),
      ...containerProps,
      ...props2,
      ...formControlProps,
      onClick: handlerAll(props2.onClick, rest.onClick, onClick2),
      onBlur: handlerAll(props2.onBlur, rest.onBlur, onBlur4)
    }),
    [containerProps, formControlProps, onBlur4, onClick2, rest]
  );
  const getFieldProps = (0, import_react130.useCallback)(
    ({ "aria-label": ariaLabel, ...props2 } = {}, ref = null) => {
      var _a, _b;
      ariaLabel != null ? ariaLabel : ariaLabel = placeholder != null ? placeholder : `Select ${isMulti ? "one or more options." : "an option."}`;
      return {
        "aria-label": ariaLabel,
        role: "combobox",
        ref: mergeRefs(fieldRef, ref),
        tabIndex: 0,
        ...fieldProps,
        ...props2,
        "data-active": dataAttr(isOpen),
        "data-placeholder": dataAttr(
          !isMulti ? label === void 0 : !(label == null ? void 0 : label.length)
        ),
        "aria-controls": (_a = listRef.current) == null ? void 0 : _a.id,
        "aria-activedescendant": (_b = descendants.value(focusedIndex)) == null ? void 0 : _b.node.id,
        "aria-expanded": isOpen,
        onFocus: handlerAll(props2.onFocus, rest.onFocus, onFocus4),
        onKeyDown: handlerAll(props2.onKeyDown, rest.onKeyDown, onKeyDown)
      };
    },
    [
      descendants,
      fieldProps,
      focusedIndex,
      isOpen,
      isMulti,
      label,
      placeholder,
      rest,
      onFocus4,
      onKeyDown
    ]
  );
  return {
    descendants,
    value,
    label,
    focusedIndex,
    placeholder,
    placeholderInOptions,
    omitSelectedValues,
    closeOnSelect,
    isOpen,
    containerRef,
    fieldRef,
    listRef,
    optionProps,
    formControlProps,
    onChangeLabel,
    onChange,
    onClear,
    onOpen,
    onClose,
    onFocusFirst,
    onFocusLast,
    onFocusSelected,
    onFocusNext,
    onFocusPrev,
    setFocusedIndex,
    getPopoverProps,
    getContainerProps,
    getFieldProps
  };
};
var useSelectList = () => {
  const { listRef, focusedIndex } = useSelectContext();
  const descendants = useSelectDescendantsContext();
  const beforeFocusedIndex = (0, import_react130.useRef)(-1);
  const selectedValue = descendants.value(focusedIndex);
  (0, import_react130.useEffect)(() => {
    if (!listRef.current || !selectedValue) return;
    if (beforeFocusedIndex.current === selectedValue.index) return;
    const parent = listRef.current;
    const child = selectedValue.node;
    const parentHeight = parent.clientHeight;
    const viewTop = parent.scrollTop;
    const viewBottom = viewTop + parentHeight;
    const childHeight = child.clientHeight;
    const childTop = child.offsetTop;
    const childBottom = childTop + childHeight;
    const isInView = viewTop <= childTop && childBottom <= viewBottom;
    const isScrollBottom = beforeFocusedIndex.current < selectedValue.index;
    if (!isInView) {
      if (childBottom <= parentHeight) {
        listRef.current.scrollTo({ top: 0 });
      } else {
        if (!isScrollBottom) {
          listRef.current.scrollTo({ top: childTop + 1 });
        } else {
          listRef.current.scrollTo({ top: childBottom - parentHeight });
        }
      }
    }
    beforeFocusedIndex.current = selectedValue.index;
  }, [listRef, selectedValue]);
  const id4 = (0, import_react130.useId)();
  const getListProps = (0, import_react130.useCallback)(
    (props2 = {}, ref = null) => ({
      id: id4,
      ref: mergeRefs(listRef, ref),
      role: "listbox",
      tabIndex: -1,
      position: "relative",
      ...props2
    }),
    [id4, listRef]
  );
  return {
    getListProps
  };
};
var useSelectOptionGroup = ({
  label,
  ...rest
}) => {
  const { value, omitSelectedValues } = useSelectContext();
  const isMulti = isArray(value);
  const descendants = useSelectDescendantsContext();
  const values = descendants.values();
  const selectedValues = isMulti && omitSelectedValues ? descendants.values(
    ({ node: node3 }) => {
      var _a;
      return value.includes((_a = node3.dataset.value) != null ? _a : "");
    }
  ) : [];
  const selectedIndexes = selectedValues.map(({ index }) => index);
  const childValues = values.filter(
    ({ node: node3, index }) => {
      var _a;
      return ((_a = node3.parentElement) == null ? void 0 : _a.dataset.label) === label && !selectedIndexes.includes(index);
    }
  );
  const isEmpty2 = !childValues.length;
  const computedRest = splitObject(rest, layoutStyleProperties);
  const getContainerProps = (0, import_react130.useCallback)(
    (props2 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref,
        ...props2,
        ...computedRest[0],
        style: isEmpty2 ? style : void 0
      };
    },
    [computedRest, isEmpty2]
  );
  const getGroupProps = (0, import_react130.useCallback)(
    ({ "aria-label": ariaLabel, ...props2 } = {}, ref = null) => {
      ariaLabel != null ? ariaLabel : ariaLabel = label;
      return {
        "aria-label": ariaLabel,
        ref,
        role: "group",
        ...props2,
        ...computedRest[1],
        "data-label": label
      };
    },
    [computedRest, label]
  );
  return {
    label,
    getContainerProps,
    getGroupProps
  };
};
var useSelectOption = (ref, props2) => {
  const {
    fieldRef,
    value,
    placeholder,
    placeholderInOptions,
    omitSelectedValues,
    closeOnSelect: generalCloseOnSelect,
    focusedIndex,
    optionProps,
    onChange,
    onChangeLabel,
    onFocusNext,
    onClose,
    setFocusedIndex
  } = useSelectContext();
  let {
    icon: customIcon,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect: customCloseOnSelect,
    children,
    value: optionValue,
    ...computedProps
  } = { ...optionProps, ...props2 };
  const trulyDisabled = !!isDisabled2 && !isFocusable2;
  const itemRef = (0, import_react130.useRef)(null);
  const { index, register, descendants } = useSelectDescendant({
    disabled: trulyDisabled
  });
  const values = descendants.values();
  const frontValues = values.slice(0, index);
  const isMulti = isArray(value);
  const isDuplicated = !isMulti ? frontValues.some(({ node: node3 }) => node3.dataset.value === (optionValue != null ? optionValue : "")) : false;
  const isSelected = !isDuplicated && (!isMulti ? (optionValue != null ? optionValue : "") === value : value.includes(optionValue != null ? optionValue : ""));
  const isFocused = index === focusedIndex;
  if (!!placeholder && index > 0 && placeholderInOptions && !optionValue) {
    console.warn(
      `${!isMulti ? "Select" : "MultiSelect"}: If placeholders are present, All options must be set value. If want to set an empty value, either don't set the placeholder or set 'placeholderInOptions' to false.`
    );
  }
  const onClick2 = (0, import_react130.useCallback)(
    (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (isDisabled2) {
        if (fieldRef.current) fieldRef.current.focus();
        return;
      }
      if (!isTargetOption(ev.currentTarget)) {
        if (fieldRef.current) fieldRef.current.focus();
        return;
      }
      setFocusedIndex(index);
      onChange(optionValue != null ? optionValue : "");
      if (fieldRef.current) fieldRef.current.focus();
      if (customCloseOnSelect != null ? customCloseOnSelect : generalCloseOnSelect) onClose();
      if (omitSelectedValues) onFocusNext();
    },
    [
      isDisabled2,
      setFocusedIndex,
      index,
      onChange,
      optionValue,
      fieldRef,
      customCloseOnSelect,
      generalCloseOnSelect,
      onClose,
      omitSelectedValues,
      onFocusNext
    ]
  );
  (0, import_react130.useEffect)(() => {
    if (isSelected) onChangeLabel(optionValue != null ? optionValue : "", false);
  }, [optionValue, isSelected, onChangeLabel]);
  const getOptionProps = (0, import_react130.useCallback)(
    (props22 = {}) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        role: "option",
        ref: mergeRefs(itemRef, ref, register),
        ...computedProps,
        ...props22,
        tabIndex: -1,
        style: omitSelectedValues && isSelected ? style : void 0,
        "data-value": optionValue != null ? optionValue : "",
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled2),
        "aria-checked": ariaAttr(isSelected),
        "aria-disabled": ariaAttr(isDisabled2),
        onClick: handlerAll(computedProps.onClick, props22.onClick, onClick2)
      };
    },
    [
      optionValue,
      computedProps,
      isDisabled2,
      isFocused,
      isSelected,
      omitSelectedValues,
      onClick2,
      ref,
      register
    ]
  );
  return {
    isSelected,
    isFocused,
    customIcon,
    children,
    getOptionProps
  };
};

// node_modules/@yamada-ui/select/dist/chunk-QVMELLEI.mjs
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var OptionGroup = forwardRef22(
  ({ className, color: color2, h, height, minH, minHeight, children, ...rest }, ref) => {
    const { styles: styles2 } = useSelectContext();
    const { label, getContainerProps, getGroupProps } = useSelectOptionGroup(rest);
    h != null ? h : h = height;
    minH != null ? minH : minH = minHeight;
    return (0, import_jsx_runtime109.jsxs)(
      ui.li,
      {
        className: cx("ui-select__item", "ui-select__item--group", className),
        __css: { w: "100%", h: "fit-content", color: color2 },
        ...getContainerProps(),
        children: [
          (0, import_jsx_runtime109.jsx)(
            ui.span,
            {
              className: "ui-select__item__group-label",
              __css: styles2.groupLabel,
              lineClamp: 1,
              children: label
            }
          ),
          (0, import_jsx_runtime109.jsx)(
            ui.ul,
            {
              ...getGroupProps({}, ref),
              className: "ui-select__item__group",
              __css: { h, minH, ...styles2.group },
              children
            }
          )
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/select/dist/chunk-IBDF22MF.mjs
var import_react131 = __toESM(require_react(), 1);
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var Option = forwardRef22(
  ({ id: id4, className, icon, ...rest }, ref) => {
    const { styles: styles2 } = useSelectContext();
    const { isSelected, customIcon, children, getOptionProps } = useSelectOption(ref, rest);
    id4 != null ? id4 : id4 = (0, import_react131.useId)();
    icon != null ? icon : icon = customIcon;
    const css4 = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      ...styles2.item
    };
    return (0, import_jsx_runtime110.jsxs)(
      ui.li,
      {
        id: id4,
        className: cx("ui-select__item", className),
        __css: css4,
        ...getOptionProps(),
        children: [
          icon !== null ? (0, import_jsx_runtime110.jsx)(OptionIcon, { opacity: isSelected ? 1 : 0, children: icon || (0, import_jsx_runtime110.jsx)(CheckIcon4, {}) }) : null,
          (0, import_jsx_runtime110.jsx)(ui.span, { style: { flex: 1 }, "data-label": true, children })
        ]
      }
    );
  }
);
var OptionIcon = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useSelectContext();
    const css4 = {
      flexShrink: 0,
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "0.85em",
      ...styles2.itemIcon
    };
    return (0, import_jsx_runtime110.jsx)(
      ui.span,
      {
        ref,
        className: cx("ui-select__item__icon", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var CheckIcon4 = () => (0, import_jsx_runtime110.jsx)("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", children: (0, import_jsx_runtime110.jsx)(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) });

// node_modules/@yamada-ui/select/dist/chunk-WZ25UY4S.mjs
var import_react132 = __toESM(require_react(), 1);
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var SelectIcon = forwardRef22(
  ({ className, children, __css, ...rest }, ref) => {
    const { styles: styles2 } = useSelectContext();
    const css4 = {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      cursor: "pointer",
      ...styles2.icon,
      ...__css
    };
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map(
      (child) => (0, import_react132.cloneElement)(child, {
        focusable: false,
        "aria-hidden": true,
        style: {
          maxWidth: "1em",
          maxHeight: "1em",
          color: "currentColor"
        }
      })
    );
    return (0, import_jsx_runtime111.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-select__icon", className),
        __css: css4,
        ...rest,
        children: isValidElement2(children) ? cloneChildren : (0, import_jsx_runtime111.jsx)(ChevronIcon, {})
      }
    );
  }
);
var SelectClearIcon = ({
  className,
  children,
  ...props2
}) => {
  const ref = (0, import_react132.useRef)(null);
  const { styles: styles2 } = useSelectContext();
  const isDisabled2 = props2.disabled;
  const rest = useClickable({
    ref,
    isDisabled: isDisabled2,
    ...props2
  });
  return (0, import_jsx_runtime111.jsx)(
    SelectIcon,
    {
      "aria-label": "Clear value",
      className: cx("ui-select__clear-icon", className),
      __css: styles2.clearIcon,
      ...rest,
      children: children != null ? children : (0, import_jsx_runtime111.jsx)(CloseIcon, { w: "0.5em", h: "0.5em" })
    }
  );
};

// node_modules/@yamada-ui/select/dist/chunk-MBNF2BPR.mjs
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var SelectList = forwardRef22(
  ({
    className,
    w,
    width,
    minW,
    minWidth,
    contentProps,
    header,
    footer,
    children,
    ...rest
  }, ref) => {
    var _a, _b, _c, _d, _e, _f;
    const { styles: styles2 } = useSelectContext();
    const { getListProps } = useSelectList();
    width != null ? width : width = w;
    width != null ? width : width = (_c = (_a = styles2.list) == null ? void 0 : _a.width) != null ? _c : (_b = styles2.list) == null ? void 0 : _b.w;
    minWidth != null ? minWidth : minWidth = minW;
    minWidth != null ? minWidth : minWidth = (_f = (_d = styles2.list) == null ? void 0 : _d.minWidth) != null ? _f : (_e = styles2.list) == null ? void 0 : _e.minW;
    return (0, import_jsx_runtime112.jsxs)(
      PopoverContent,
      {
        as: "div",
        className: "ui-select__content",
        width,
        minWidth,
        __css: { ...styles2.content, width, minWidth },
        ...contentProps,
        children: [
          header ? (0, import_jsx_runtime112.jsx)(ui.div, { className: "ui-select__header", __css: { ...styles2.header }, children: header }) : null,
          (0, import_jsx_runtime112.jsx)(
            ui.ul,
            {
              className: cx("ui-select__list", className),
              __css: { ...styles2.list },
              ...getListProps(rest, ref),
              children
            }
          ),
          footer ? (0, import_jsx_runtime112.jsx)(ui.div, { className: "ui-select__footer", __css: { ...styles2.footer }, children: footer }) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/select/dist/chunk-AMVZPAHU.mjs
var import_react133 = __toESM(require_react(), 1);
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var MultiSelect2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("MultiSelect", props2);
  let {
    className,
    defaultValue = [],
    component,
    separator,
    isClearable = true,
    items = [],
    color: color2,
    h,
    height,
    minH,
    minHeight,
    closeOnSelect = false,
    containerProps,
    listProps,
    fieldProps,
    iconProps,
    clearIconProps,
    portalProps = { isDisabled: true },
    header,
    footer,
    children,
    ...computedProps
  } = omitThemeProps(mergedProps);
  const validChildren = getValidChildren(children);
  let computedChildren = [];
  if (!validChildren.length && items.length) {
    computedChildren = items.map((item, i) => {
      if ("value" in item) {
        const { label, value: value2, ...props22 } = item;
        return (0, import_jsx_runtime113.jsx)(Option, { value: value2, ...props22, children: label }, i);
      } else if ("items" in item) {
        const { label, items: items2 = [], ...props22 } = item;
        return (0, import_jsx_runtime113.jsx)(
          OptionGroup,
          {
            label: label != null ? label : "",
            ...props22,
            children: items2.map(({ label: label2, value: value2, ...props3 }, i2) => (0, import_jsx_runtime113.jsx)(Option, { value: value2, ...props3, children: label2 }, i2))
          },
          i
        );
      }
    }).filter(Boolean);
  }
  let isEmpty2 = !validChildren.length && !computedChildren.length;
  const {
    value,
    onClose,
    descendants,
    formControlProps,
    getPopoverProps,
    getContainerProps,
    getFieldProps,
    placeholder,
    onClear,
    ...rest
  } = useSelect({
    ...computedProps,
    defaultValue,
    placeholderInOptions: false,
    closeOnSelect,
    isEmpty: isEmpty2
  });
  h != null ? h : h = height;
  minH != null ? minH : minH = minHeight;
  const css4 = {
    w: "100%",
    h: "fit-content",
    color: color2,
    ...styles2.container
  };
  return (0, import_jsx_runtime113.jsx)(SelectDescendantsContextProvider, { value: descendants, children: (0, import_jsx_runtime113.jsx)(SelectProvider, { value: { ...rest, value, onClose, placeholder, styles: styles2 }, children: (0, import_jsx_runtime113.jsx)(Popover2, { ...getPopoverProps(), children: (0, import_jsx_runtime113.jsxs)(
    ui.div,
    {
      className: cx("ui-multi-select", className),
      __css: css4,
      ...getContainerProps(containerProps),
      children: [
        (0, import_jsx_runtime113.jsxs)(
          ui.div,
          {
            className: "ui-multi-select__inner",
            __css: { position: "relative", ...styles2.inner },
            children: [
              (0, import_jsx_runtime113.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime113.jsx)(
                MultiSelectField,
                {
                  component,
                  separator,
                  h,
                  minH,
                  ...getFieldProps(fieldProps, ref)
                }
              ) }),
              isClearable && value.length ? (0, import_jsx_runtime113.jsx)(
                SelectClearIcon,
                {
                  ...clearIconProps,
                  onClick: handlerAll(clearIconProps == null ? void 0 : clearIconProps.onClick, onClear),
                  ...formControlProps
                }
              ) : (0, import_jsx_runtime113.jsx)(SelectIcon, { ...iconProps, ...formControlProps })
            ]
          }
        ),
        !isEmpty2 ? (0, import_jsx_runtime113.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime113.jsx)(
          SelectList,
          {
            header: runIfFunc(header, { value, onClose }),
            footer: runIfFunc(footer, { value, onClose }),
            ...listProps,
            children: children != null ? children : computedChildren
          }
        ) }) : null
      ]
    }
  ) }) }) });
});
var MultiSelectField = forwardRef22(
  ({
    className,
    component,
    separator = ",",
    isTruncated,
    lineClamp = 1,
    h,
    minH,
    ...rest
  }, ref) => {
    const { value, label, onChange, placeholder, styles: styles2 } = useSelectContext();
    const cloneChildren = (0, import_react133.useMemo)(() => {
      if (!(label == null ? void 0 : label.length))
        return (0, import_jsx_runtime113.jsx)(ui.span, { lineClamp, children: placeholder });
      if (component) {
        return (0, import_jsx_runtime113.jsx)(ui.span, { isTruncated, lineClamp, children: label.map((label2, index) => {
          const onRemove = (e) => {
            e.stopPropagation();
            onChange(value[index]);
          };
          const el = component({
            value: value[index],
            label: label2,
            index,
            onRemove
          });
          const style = {
            marginBlockStart: "0.125rem",
            marginBlockEnd: "0.125rem",
            marginInlineEnd: "0.25rem"
          };
          return el ? (0, import_react133.cloneElement)(el, { key: index, style }) : null;
        }) });
      } else {
        return (0, import_jsx_runtime113.jsx)(ui.span, { isTruncated, lineClamp, children: label.map((value2, index) => {
          const isLast = label.length === index + 1;
          return (0, import_jsx_runtime113.jsx)(
            ui.span,
            {
              display: "inline-block",
              me: "0.25rem",
              dangerouslySetInnerHTML: {
                __html: `${value2}${!isLast ? separator : ""}`
              }
            },
            index
          );
        }) });
      }
    }, [
      label,
      isTruncated,
      lineClamp,
      onChange,
      placeholder,
      separator,
      component,
      value
    ]);
    const css4 = {
      pe: "2rem",
      h,
      minH,
      display: "flex",
      alignItems: "center",
      ...styles2.field
    };
    return (0, import_jsx_runtime113.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-multi-select__field", className),
        __css: css4,
        py: (label == null ? void 0 : label.length) && component ? "0.125rem" : void 0,
        ...rest,
        children: cloneChildren
      }
    );
  }
);
var Select2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Select", props2);
  let {
    className,
    placeholder,
    defaultValue = "",
    placeholderInOptions = true,
    items = [],
    color: color2,
    h,
    height,
    minH,
    minHeight,
    containerProps,
    contentProps,
    listProps,
    fieldProps,
    iconProps,
    portalProps = { isDisabled: true },
    header,
    footer,
    children,
    ...computedProps
  } = omitThemeProps(mergedProps);
  const validChildren = getValidChildren(children);
  let computedChildren = [];
  if (!validChildren.length && items.length) {
    computedChildren = items.map((item, i) => {
      if ("value" in item) {
        const { label, value: value2, ...props22 } = item;
        return (0, import_jsx_runtime114.jsx)(Option, { value: value2, ...props22, children: label }, i);
      } else if ("items" in item) {
        const { label, items: items2 = [], ...props22 } = item;
        return (0, import_jsx_runtime114.jsx)(
          OptionGroup,
          {
            label: label != null ? label : "",
            ...props22,
            children: items2.map(({ label: label2, value: value2, ...props3 }, i2) => (0, import_jsx_runtime114.jsx)(Option, { value: value2, ...props3, children: label2 }, i2))
          },
          i
        );
      }
    }).filter(Boolean);
  }
  const isEmpty2 = !validChildren.length && !computedChildren.length && !(!!placeholder && placeholderInOptions);
  const {
    value,
    onClose,
    descendants,
    formControlProps,
    getPopoverProps,
    getContainerProps,
    getFieldProps,
    ...rest
  } = useSelect({
    ...computedProps,
    placeholder,
    placeholderInOptions,
    defaultValue,
    isEmpty: isEmpty2
  });
  h != null ? h : h = height;
  minH != null ? minH : minH = minHeight;
  const css4 = {
    w: "100%",
    h: "fit-content",
    color: color2,
    ...styles2.container
  };
  return (0, import_jsx_runtime114.jsx)(SelectDescendantsContextProvider, { value: descendants, children: (0, import_jsx_runtime114.jsx)(
    SelectProvider,
    {
      value: {
        ...rest,
        value,
        onClose,
        placeholder,
        placeholderInOptions,
        styles: styles2
      },
      children: (0, import_jsx_runtime114.jsx)(Popover2, { ...getPopoverProps(), children: (0, import_jsx_runtime114.jsxs)(
        ui.div,
        {
          className: cx("ui-select", className),
          __css: css4,
          ...getContainerProps(containerProps),
          children: [
            (0, import_jsx_runtime114.jsxs)(
              ui.div,
              {
                className: "ui-select__inner",
                __css: { position: "relative", ...styles2.inner },
                children: [
                  (0, import_jsx_runtime114.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime114.jsx)(
                    SelectField,
                    {
                      h,
                      minH,
                      ...getFieldProps(fieldProps, ref)
                    }
                  ) }),
                  (0, import_jsx_runtime114.jsx)(SelectIcon, { ...iconProps, ...formControlProps })
                ]
              }
            ),
            !isEmpty2 ? (0, import_jsx_runtime114.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime114.jsxs)(
              SelectList,
              {
                header: runIfFunc(header, { value, onClose }),
                footer: runIfFunc(footer, { value, onClose }),
                contentProps,
                ...listProps,
                children: [
                  !!placeholder && placeholderInOptions ? (0, import_jsx_runtime114.jsx)(Option, { children: placeholder }) : null,
                  children != null ? children : computedChildren
                ]
              }
            ) }) : null
          ]
        }
      ) })
    }
  ) });
});
var SelectField = forwardRef22(
  ({ className, isTruncated = true, lineClamp, h, minH, ...rest }, ref) => {
    var _a;
    const { label, placeholder, styles: styles2 } = useSelectContext();
    const css4 = {
      pe: "2rem",
      h,
      minH,
      display: "flex",
      alignItems: "center",
      ...styles2.field
    };
    return (0, import_jsx_runtime114.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-select__field", className),
        __css: css4,
        ...rest,
        children: (0, import_jsx_runtime114.jsx)(
          ui.span,
          {
            isTruncated,
            lineClamp,
            dangerouslySetInnerHTML: {
              __html: (_a = label != null ? label : placeholder) != null ? _a : ""
            }
          }
        )
      }
    );
  }
);

// node_modules/@yamada-ui/use-latest-ref/dist/index.mjs
var import_react134 = __toESM(require_react(), 1);
var useLatestRef = (value) => {
  const ref = (0, import_react134.useRef)(null);
  ref.current = value;
  return ref;
};

// node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep2(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData2) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}

// node_modules/framesync/dist/es/index.mjs
var maxElapsed3 = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame2 = {
  delta: 0,
  timestamp: 0
};
var stepsOrder2 = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps2 = stepsOrder2.reduce((acc, key) => {
  acc[key] = createRenderStep2(() => runNextFrame = true);
  return acc;
}, {});
var sync2 = stepsOrder2.reduce((acc, key) => {
  const step = steps2[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync2 = stepsOrder2.reduce((acc, key) => {
  acc[key] = steps2[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder2.reduce((acc, key) => {
  acc[key] = () => steps2[key].process(frame2);
  return acc;
}, {});
var processStep = (stepId) => steps2[stepId].process(frame2);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame2.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame2.timestamp, maxElapsed3), 1);
  frame2.timestamp = timestamp;
  isProcessing = true;
  stepsOrder2.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = () => frame2;
var es_default = sync2;

// node_modules/@yamada-ui/use-pan-event/dist/index.mjs
var import_react135 = __toESM(require_react(), 1);
var subtract2 = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
var getPanInfo2 = (info, history) => ({
  point: info.point,
  delta: subtract2(info.point, history[history.length - 1]),
  offset: subtract2(info.point, history[0]),
  velocity: getVelocity2(history, 0.1)
});
var toMilliseconds = (v) => v * 1e3;
var getVelocity2 = (history, timeDelta) => {
  if (history.length < 2) return { x: 0, y: 0 };
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = history[history.length - 1];
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) return { x: 0, y: 0 };
  const time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) currentVelocity.x = 0;
  if (currentVelocity.y === Infinity) currentVelocity.y = 0;
  return currentVelocity;
};
var pipe3 = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
var distance1D = (a, b) => Math.abs(a - b);
var isPoint = (point2) => "x" in point2 && "y" in point2;
var distance2 = (a, b) => {
  if (typeof a === "number" && typeof b === "number") return distance1D(a, b);
  if (isPoint(a) && isPoint(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  return 0;
};
var panEvent = (ev, handlers2, threshold = 3) => {
  var _a;
  if (isMultiTouchEvent(ev)) return;
  const win = (_a = ev.view) != null ? _a : window;
  const info = { point: getEventPoint(ev) };
  const { timestamp } = getFrameData();
  const { onSessionStart, onStart, onMove, onEnd, onSessionEnd } = handlers2;
  const history = [{ ...info.point, timestamp }];
  let startEvent = null;
  let lastEvent = null;
  let lastEventInfo = null;
  ev.stopPropagation();
  ev.preventDefault();
  onSessionStart == null ? void 0 : onSessionStart(ev, getPanInfo2(info, history));
  const updatePoint = () => {
    if (!(lastEvent && lastEventInfo)) return;
    const info2 = getPanInfo2(lastEventInfo, history);
    const isPanStarted = startEvent !== null;
    const isDistancePastThreshold = distance2(info2.offset, { x: 0, y: 0 }) >= threshold;
    if (!isPanStarted && !isDistancePastThreshold) return;
    const { timestamp: timestamp2 } = getFrameData();
    history.push({ ...info2.point, timestamp: timestamp2 });
    if (!isPanStarted) {
      onStart == null ? void 0 : onStart(lastEvent, info2);
      startEvent = lastEvent;
    }
    onMove == null ? void 0 : onMove(lastEvent, info2);
  };
  const onPointerMove = (ev2, info2) => {
    lastEvent = ev2;
    lastEventInfo = info2;
    es_default.update(updatePoint, true);
  };
  const onPointerUp = (ev2, info2) => {
    const panInfo = getPanInfo2(info2, history);
    onSessionEnd == null ? void 0 : onSessionEnd(ev2, panInfo);
    end2();
    if (!onEnd || !startEvent) return;
    onEnd == null ? void 0 : onEnd(ev2, panInfo);
  };
  const updateHandlers = (newHandlers) => {
    handlers2 = newHandlers;
  };
  let removeListeners = pipe3(
    addPointerEvent(win, "pointermove", onPointerMove),
    addPointerEvent(win, "pointerup", onPointerUp),
    addPointerEvent(win, "pointercancel", onPointerUp)
  );
  const end2 = () => {
    removeListeners == null ? void 0 : removeListeners();
    cancelSync2.update(updatePoint);
  };
  return {
    updateHandlers,
    end: end2
  };
};
var usePanEvent = (ref, {
  onMove,
  onStart,
  onEnd,
  onSessionStart,
  onSessionEnd,
  threshold
}) => {
  const hasPanEvents = !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd;
  const panSession = (0, import_react135.useRef)(null);
  const handlersRef = useLatestRef({
    onSessionStart,
    onSessionEnd,
    onStart,
    onMove,
    onEnd: (ev, info) => {
      panSession.current = null;
      onEnd == null ? void 0 : onEnd(ev, info);
    }
  });
  (0, import_react135.useEffect)(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);
  });
  (0, import_react135.useEffect)(() => {
    const node3 = ref.current;
    if (!node3 || !hasPanEvents) return;
    const onPointerDown = (ev) => {
      panSession.current = panEvent(ev, handlersRef.current, threshold);
    };
    return addPointerEvent(node3, "pointerdown", onPointerDown);
  }, [ref, hasPanEvents, handlersRef, threshold]);
  (0, import_react135.useEffect)(() => {
    return () => {
      var _a;
      (_a = panSession.current) == null ? void 0 : _a.end();
      panSession.current = null;
    };
  }, []);
};

// node_modules/@yamada-ui/use-size/dist/index.mjs
var import_react136 = __toESM(require_react(), 1);
var trackElementSize = (el, cb) => {
  var _a;
  if (!el) {
    cb(void 0);
    return;
  }
  cb({ width: el.offsetWidth, height: el.offsetHeight });
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  const observer2 = new win.ResizeObserver((entries) => {
    if (!isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry.borderBoxSize;
      const borderSize = isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize.inlineSize;
      height = borderSize.blockSize;
    } else {
      width = el.offsetWidth;
      height = el.offsetHeight;
    }
    cb({ width, height });
  });
  observer2.observe(el, { box: "border-box" });
  return () => observer2.unobserve(el);
};
var trackMutation = (el, cb) => {
  var _a, _b;
  if (!el || !el.parentElement) return;
  const win = (_b = (_a = el.ownerDocument) == null ? void 0 : _a.defaultView) != null ? _b : window;
  const observer2 = new win.MutationObserver(() => {
    cb();
  });
  observer2.observe(el.parentElement, { childList: true });
  return () => {
    observer2.disconnect();
  };
};
var useSizes = ({
  getNodes,
  observeMutation = true
}) => {
  const [sizes2, setSizes] = (0, import_react136.useState)([]);
  const [count, setCount] = (0, import_react136.useState)(0);
  useSafeLayoutEffect(() => {
    const elements = getNodes();
    const cleanups = elements.map(
      (element, index) => trackElementSize(element, (size) => {
        setSizes((sizes22) => {
          return [
            ...sizes22.slice(0, index),
            size,
            ...sizes22.slice(index + 1)
          ];
        });
      })
    );
    if (observeMutation) {
      const firstNode = elements[0];
      cleanups.push(
        trackMutation(firstNode, () => {
          setCount((count2) => count2 + 1);
        })
      );
    }
    return () => {
      cleanups.forEach((cleanup) => {
        cleanup == null ? void 0 : cleanup();
      });
    };
  }, [count]);
  return sizes2;
};
var useSize = (refOrEl) => {
  const [size] = useSizes({
    observeMutation: false,
    getNodes: () => {
      const node3 = isRefObject(refOrEl) ? refOrEl.current : refOrEl;
      return [node3];
    }
  });
  return size;
};

// node_modules/@yamada-ui/slider/dist/chunk-6GBIBUXC.mjs
var import_react137 = __toESM(require_react(), 1);
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var getThumbSize = (thumbSize, styles2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
  return (_t = (_s = (_q = (_o = (_m = (_k = (_i = (_g = (_e = (_c = thumbSize != null ? thumbSize : (_a = styles2.thumb) == null ? void 0 : _a.boxSize) != null ? _c : (_b = styles2.thumb) == null ? void 0 : _b.minBoxSize) != null ? _e : (_d = styles2.thumb) == null ? void 0 : _d.width) != null ? _g : (_f = styles2.thumb) == null ? void 0 : _f.w) != null ? _i : (_h = styles2.thumb) == null ? void 0 : _h.minWidth) != null ? _k : (_j = styles2.thumb) == null ? void 0 : _j.minW) != null ? _m : (_l = styles2.thumb) == null ? void 0 : _l.height) != null ? _o : (_n = styles2.thumb) == null ? void 0 : _n.h) != null ? _q : (_p = styles2.thumb) == null ? void 0 : _p.minHeight) != null ? _s : (_r = styles2.thumb) == null ? void 0 : _r.minH) != null ? _t : "3.5";
};
var useSlider = ({
  focusThumbOnChange = true,
  ...props2
}) => {
  if (!focusThumbOnChange) props2.isReadOnly = true;
  let {
    id: id4,
    name,
    min: min2 = 0,
    max: max2 = 100,
    step = 1,
    defaultValue,
    orientation = "horizontal",
    thumbSize: thumbSizeProp,
    isReversed,
    required,
    disabled,
    readOnly,
    value: valueProp,
    onChange,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    onFocus: onFocus4,
    onBlur: onBlur4,
    "aria-readonly": ariaReadonly,
    "aria-valuetext": ariaValueText,
    ...rest
  } = useFormControlProps(props2);
  const formControlProps = pickObject(rest, formControlProperties);
  if (max2 < min2)
    throw new Error("Do not assign a number less than 'min' to 'max'");
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const [computedValue, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : min2 + (max2 - min2) / 2,
    onChange
  });
  const [isDragging, setDragging] = (0, import_react137.useState)(false);
  const [isFocused, setFocused] = (0, import_react137.useState)(false);
  const isInteractive = !(disabled || readOnly);
  const tenStep = (max2 - min2) / 10;
  const oneStep = step || (max2 - min2) / 100;
  const value = clampNumber(computedValue, min2, max2);
  const reversedValue = max2 - value + min2;
  const thumbValue = isReversed ? reversedValue : value;
  const thumbPercent = valueToPercent(thumbValue, min2, max2);
  const isVertical = orientation === "vertical";
  const latestRef = useLatestRef({
    min: min2,
    max: max2,
    step,
    value,
    isInteractive,
    focusThumbOnChange
  });
  const eventSourceRef = (0, import_react137.useRef)(null);
  const containerRef = (0, import_react137.useRef)(null);
  const trackRef = (0, import_react137.useRef)(null);
  const thumbRef = (0, import_react137.useRef)(null);
  const thumbSize = useSize(thumbRef);
  usePanEvent(containerRef, {
    onSessionStart: (ev) => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(true);
      focusThumb();
      setValueFromPointer(ev);
      onChangeStart(value2);
    },
    onSessionEnd: () => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(false);
      onChangeEnd(value2);
    },
    onMove: (ev) => {
      const { isInteractive: isInteractive2 } = latestRef.current;
      if (!isInteractive2) return;
      setValueFromPointer(ev);
    }
  });
  const getValueFromPointer = (0, import_react137.useCallback)(
    (ev) => {
      var _a, _b;
      if (!trackRef.current) return;
      const { min: min22, max: max22, step: step2 } = latestRef.current;
      eventSourceRef.current = "pointer";
      const { bottom: bottom2, left: left2, height, width } = trackRef.current.getBoundingClientRect();
      const { clientX, clientY } = (_b = (_a = ev.touches) == null ? void 0 : _a[0]) != null ? _b : ev;
      const diff = isVertical ? bottom2 - clientY : clientX - left2;
      const length2 = isVertical ? height : width;
      let percent2 = diff / length2;
      if (isReversed) percent2 = 1 - percent2;
      let nextValue = percentToValue(percent2, min22, max22);
      if (step2) nextValue = parseFloat(roundNumberToStep(nextValue, min22, step2));
      nextValue = clampNumber(nextValue, min22, max22);
      return nextValue;
    },
    [isVertical, isReversed, latestRef]
  );
  const setValueFromPointer = (ev) => {
    const { value: value2 } = latestRef.current;
    const nextValue = getValueFromPointer(ev);
    if (nextValue != null && nextValue !== value2) setValue(nextValue);
  };
  const focusThumb = (0, import_react137.useCallback)(() => {
    const { focusThumbOnChange: focusThumbOnChange2 } = latestRef.current;
    if (focusThumbOnChange2) setTimeout(() => {
      var _a;
      return (_a = thumbRef.current) == null ? void 0 : _a.focus();
    });
  }, [latestRef]);
  const constrain = (0, import_react137.useCallback)(
    (value2) => {
      const { isInteractive: isInteractive2, min: min22, max: max22 } = latestRef.current;
      if (!isInteractive2) return;
      value2 = parseFloat(roundNumberToStep(value2, min22, oneStep));
      value2 = clampNumber(value2, min22, max22);
      setValue(value2);
    },
    [oneStep, setValue, latestRef]
  );
  const stepUp = (0, import_react137.useCallback)(
    (step2 = oneStep) => constrain(isReversed ? value - step2 : value + step2),
    [constrain, isReversed, oneStep, value]
  );
  const stepDown = (0, import_react137.useCallback)(
    (step2 = oneStep) => constrain(isReversed ? value + step2 : value - step2),
    [constrain, isReversed, oneStep, value]
  );
  const reset = (0, import_react137.useCallback)(
    () => constrain(defaultValue || 0),
    [constrain, defaultValue]
  );
  const stepTo = (0, import_react137.useCallback)((value2) => constrain(value2), [constrain]);
  const onKeyDown = (0, import_react137.useCallback)(
    (ev) => {
      const { min: min22, max: max22 } = latestRef.current;
      const actions = {
        ArrowRight: () => stepUp(),
        ArrowUp: () => stepUp(),
        ArrowLeft: () => stepDown(),
        ArrowDown: () => stepDown(),
        PageUp: () => stepUp(tenStep),
        PageDown: () => stepDown(tenStep),
        Home: () => constrain(min22),
        End: () => constrain(max22)
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action(ev);
      eventSourceRef.current = "keyboard";
    },
    [constrain, latestRef, stepDown, stepUp, tenStep]
  );
  useUpdateEffect(() => {
    const { value: value2 } = latestRef.current;
    focusThumb();
    if (eventSourceRef.current === "keyboard") onChangeEnd(value2);
  }, [value, onChangeEnd]);
  const getContainerProps = (0, import_react137.useCallback)(
    (props22 = {}, ref = null) => {
      const { width: w, height: h } = thumbSize != null ? thumbSize : {
        width: "$thumbSize",
        height: "$thumbSize"
      };
      const padding = isVertical ? { paddingLeft: `calc(${w} / 2)`, paddingRight: `calc(${w} / 2)` } : { paddingTop: `calc(${h} / 2)`, paddingBottom: `calc(${h} / 2)` };
      const style = {
        ...props22.style,
        position: "relative",
        userSelect: "none",
        touchAction: "none",
        WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
        outline: 0,
        ...padding
      };
      return {
        ...rest,
        ...props22,
        ref: mergeRefs(ref, containerRef),
        tabIndex: -1,
        style,
        var: [
          {
            name: "thumbSize",
            token: "sizes",
            value: thumbSizeProp
          }
        ]
      };
    },
    [isVertical, rest, thumbSize, thumbSizeProp]
  );
  const getInputProps = (0, import_react137.useCallback)(
    (props22 = {}, ref = null) => ({
      "aria-readonly": ariaReadonly,
      ...formControlProps,
      ...props22,
      id: id4,
      ref,
      type: "hidden",
      name,
      value,
      required,
      disabled,
      readOnly
    }),
    [
      ariaReadonly,
      disabled,
      formControlProps,
      id4,
      name,
      readOnly,
      required,
      value
    ]
  );
  const getTrackProps = (0, import_react137.useCallback)(
    (props22 = {}, ref = null) => {
      const style = {
        ...props22.style,
        position: "absolute",
        ...isVertical ? {
          left: "50%",
          transform: "translateX(-50%)",
          height: "100%"
        } : {
          top: "50%",
          transform: "translateY(-50%)",
          width: "100%"
        }
      };
      return {
        ...formControlProps,
        ...props22,
        ref: mergeRefs(ref, trackRef),
        style
      };
    },
    [isVertical, formControlProps]
  );
  const getFilledTrackProps = (0, import_react137.useCallback)(
    (props22 = {}, ref = null) => {
      const n = Math.abs(isReversed ? 100 - thumbPercent : thumbPercent);
      const style = {
        ...props22.style,
        position: "absolute",
        ...isVertical ? {
          left: "50%",
          transform: "translateX(-50%)",
          height: `${n}%`,
          ...isReversed ? { top: "0%" } : { bottom: "0%" }
        } : {
          top: "50%",
          transform: "translateY(-50%)",
          width: `${n}%`,
          ...isReversed ? { right: "0%" } : { left: "0%" }
        }
      };
      return {
        ...formControlProps,
        ...props22,
        ref,
        style
      };
    },
    [isReversed, isVertical, formControlProps, thumbPercent]
  );
  const getMarkProps = (0, import_react137.useCallback)(
    (props22, ref = null) => {
      let n = valueToPercent(props22.value, min2, max2);
      n = isReversed ? 100 - n : n;
      const style = {
        ...props22.style,
        position: "absolute",
        pointerEvents: "none",
        ...isVertical ? { bottom: `${n}%` } : { left: `${n}%` }
      };
      return {
        ...formControlProps,
        ...props22,
        ref,
        "aria-hidden": true,
        "data-invalid": dataAttr(props22.value < min2 || max2 < props22.value),
        "data-highlighted": dataAttr(props22.value <= value),
        style
      };
    },
    [isReversed, isVertical, max2, min2, formControlProps, value]
  );
  const getThumbProps = (0, import_react137.useCallback)(
    (props22 = {}, ref = null) => {
      const n = thumbPercent;
      let w = "$thumbSize";
      let h = "$thumbSize";
      if (thumbSize) {
        w = `${thumbSize.width}px`;
        h = `${thumbSize.height}px`;
      }
      const bottom2 = `calc(${n}% - (${h} / 2))`;
      const left2 = `calc(${n}% - (${w} / 2))`;
      const style = {
        ...props22.style,
        position: "absolute",
        userSelect: "none",
        touchAction: "none",
        ...isVertical ? { bottom: bottom2 } : { left: left2 }
      };
      return {
        "aria-label": "Slider thumb",
        "aria-readonly": ariaReadonly,
        ...formControlProps,
        ...props22,
        ref: mergeRefs(ref, thumbRef),
        tabIndex: isInteractive && focusThumbOnChange ? 0 : void 0,
        role: "slider",
        "aria-valuemin": min2,
        "aria-valuemax": max2,
        "aria-valuenow": value,
        "data-active": dataAttr(isDragging && focusThumbOnChange),
        "aria-orientation": orientation,
        "aria-valuetext": ariaValueText != null ? ariaValueText : value.toString(),
        onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
        onFocus: handlerAll(props22.onFocus, onFocus4, () => setFocused(true)),
        onBlur: handlerAll(props22.onBlur, onBlur4, () => setFocused(false)),
        style
      };
    },
    [
      thumbPercent,
      thumbSize,
      isVertical,
      ariaReadonly,
      formControlProps,
      isInteractive,
      focusThumbOnChange,
      min2,
      max2,
      value,
      isDragging,
      orientation,
      onKeyDown,
      onFocus4,
      onBlur4,
      ariaValueText
    ]
  );
  return {
    value,
    isFocused,
    isDragging,
    isVertical,
    stepUp,
    stepDown,
    reset,
    stepTo,
    getContainerProps,
    getInputProps,
    getTrackProps,
    getFilledTrackProps,
    getMarkProps,
    getThumbProps
  };
};
var [SliderProvider, useSliderContext] = createContext2({
  name: "SliderContext",
  errorMessage: `useSliderContext returned is 'undefined'. Seems you forgot to wrap the components in "<Slider />" `
});
var Slider2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Slider", props2);
  const {
    className,
    children,
    inputProps,
    trackProps,
    filledTrackProps,
    thumbProps,
    trackColor,
    filledTrackColor,
    trackSize,
    thumbColor,
    thumbSize,
    ...rest
  } = omitThemeProps(mergedProps);
  const {
    isVertical,
    getContainerProps,
    getInputProps,
    getTrackProps,
    getFilledTrackProps,
    getMarkProps,
    getThumbProps
  } = useSlider({ ...rest, thumbSize: getThumbSize(thumbSize, styles2) });
  const css4 = { ...styles2.container };
  const validChildren = getValidChildren(children);
  const [customSliderTrack] = findChildren(validChildren, SliderTrack);
  const [customSliderThumb] = findChildren(validChildren, SliderThumb);
  const hasSliderThumb = includesChildren(validChildren, SliderThumb);
  const cloneChildren = !isEmpty(validChildren) ? omitChildren(validChildren, SliderTrack, SliderThumb) : children;
  return (0, import_jsx_runtime115.jsx)(
    SliderProvider,
    {
      value: {
        isVertical,
        getTrackProps,
        getFilledTrackProps,
        getMarkProps,
        getThumbProps,
        trackProps,
        trackColor,
        trackSize,
        filledTrackProps,
        filledTrackColor,
        thumbProps,
        thumbColor,
        thumbSize,
        styles: styles2
      },
      children: (0, import_jsx_runtime115.jsxs)(
        ui.div,
        {
          className: cx("ui-slider", className),
          __css: css4,
          ...getContainerProps(),
          children: [
            (0, import_jsx_runtime115.jsx)(ui.input, { ...getInputProps(inputProps, ref) }),
            customSliderTrack != null ? customSliderTrack : (0, import_jsx_runtime115.jsx)(SliderTrack, {}),
            cloneChildren,
            customSliderThumb != null ? customSliderThumb : !hasSliderThumb ? (0, import_jsx_runtime115.jsx)(SliderThumb, {}) : null
          ]
        }
      )
    }
  );
});
var SliderTrack = forwardRef22(
  ({ className, children, filledTrackProps, ...rest }, ref) => {
    const {
      styles: styles2,
      trackProps,
      trackColor,
      trackSize,
      isVertical,
      getTrackProps
    } = useSliderContext();
    const css4 = { ...styles2.track };
    return (0, import_jsx_runtime115.jsx)(
      ui.div,
      {
        className: cx("ui-slider__track", className),
        __css: css4,
        ...getTrackProps(
          {
            ...trackColor ? { bg: trackColor } : {},
            ...trackSize ? isVertical ? { w: trackSize } : { h: trackSize } : {},
            ...trackProps,
            ...rest
          },
          ref
        ),
        children: children != null ? children : (0, import_jsx_runtime115.jsx)(SliderFilledTrack, { ...filledTrackProps })
      }
    );
  }
);
var SliderFilledTrack = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, filledTrackProps, filledTrackColor, getFilledTrackProps } = useSliderContext();
    const css4 = { ...styles2.filledTrack };
    return (0, import_jsx_runtime115.jsx)(
      ui.div,
      {
        className: cx("ui-slider__track-filled", className),
        __css: css4,
        ...getFilledTrackProps(
          {
            ...filledTrackColor ? { bg: filledTrackColor } : {},
            ...filledTrackProps,
            ...rest
          },
          ref
        )
      }
    );
  }
);
var SliderMark = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, getMarkProps } = useSliderContext();
    const css4 = {
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      ...styles2.mark
    };
    return (0, import_jsx_runtime115.jsx)(
      ui.div,
      {
        className: cx("ui-slider__mark", className),
        __css: css4,
        ...getMarkProps(rest, ref)
      }
    );
  }
);
var SliderThumb = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, thumbProps, thumbColor, thumbSize, getThumbProps } = useSliderContext();
    const css4 = { ...styles2.thumb };
    return (0, import_jsx_runtime115.jsx)(
      ui.div,
      {
        className: cx("ui-slider__thumb", className),
        __css: css4,
        ...getThumbProps(
          {
            ...thumbColor ? { bg: thumbColor } : {},
            ...thumbSize ? { boxSize: thumbSize } : {},
            ...thumbProps,
            ...rest
          },
          ref
        )
      }
    );
  }
);

// node_modules/@yamada-ui/slider/dist/chunk-T5CKIMDY.mjs
var import_react138 = __toESM(require_react(), 1);
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var useRangeSlider = ({
  focusThumbOnChange = true,
  ...props2
}) => {
  if (!focusThumbOnChange) props2.isReadOnly = true;
  let {
    id: id4,
    name,
    min: min2 = 0,
    max: max2 = 100,
    step = 1,
    defaultValue,
    orientation = "horizontal",
    thumbSize: thumbSizeProp,
    isReversed,
    betweenThumbs = 0,
    required,
    disabled,
    readOnly,
    value: valueProp,
    onChange,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    onFocus: onFocus4,
    onBlur: onBlur4,
    "aria-readonly": ariaReadonly,
    "aria-valuetext": ariaValueText,
    ...rest
  } = useFormControlProps(props2);
  const formControlProps = pickObject(rest, formControlProperties);
  defaultValue = defaultValue != null ? defaultValue : [min2 + (max2 - min2) / 4, max2 - (max2 - min2) / 4];
  if (max2 < min2)
    throw new Error("Do not assign a number less than 'min' to 'max'");
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const [computedValues, setValues2] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange
  });
  const [isDragging, setDragging] = (0, import_react138.useState)(false);
  const [isFocused, setFocused] = (0, import_react138.useState)(false);
  const [activeIndex, setActiveIndex] = (0, import_react138.useState)(-1);
  const isInteractive = !(disabled || readOnly);
  const tenStep = (max2 - min2) / 10;
  const oneStep = step || (max2 - min2) / 100;
  const spacing = betweenThumbs * step;
  const values = computedValues.map(
    (value) => clampNumber(value, min2, max2)
  );
  const [startValue, endValue] = values;
  const reversedValues = values.map((value) => max2 - value + min2);
  const thumbValues = isReversed ? reversedValues : values;
  const thumbPercents = thumbValues.map(
    (value) => valueToPercent(value, min2, max2)
  );
  const valueBounds = [
    { min: min2, max: endValue - spacing },
    { min: startValue + spacing, max: max2 }
  ];
  const isVertical = orientation === "vertical";
  const latestRef = useLatestRef({
    min: min2,
    max: max2,
    step,
    disabled,
    values,
    valueBounds,
    isInteractive,
    isReversed,
    isVertical,
    focusThumbOnChange,
    betweenThumbs,
    orientation
  });
  const eventSourceRef = (0, import_react138.useRef)(null);
  const containerRef = (0, import_react138.useRef)(null);
  const trackRef = (0, import_react138.useRef)(null);
  const thumbSizes = useSizes({
    getNodes: () => {
      var _a;
      const nodes = (_a = containerRef.current) == null ? void 0 : _a.querySelectorAll("[role=slider]");
      return nodes ? Array.from(nodes) : [];
    }
  });
  id4 != null ? id4 : id4 = (0, import_react138.useId)();
  name != null ? name : name = id4;
  const getThumbId = (0, import_react138.useCallback)((i) => `slider-thumb-${id4}-${i}`, [id4]);
  const getInputId = (0, import_react138.useCallback)((i) => `slider-input-${id4}-${i}`, [id4]);
  const getMarkerId = (0, import_react138.useCallback)(
    (i) => `slider-marker-${id4}-${i}`,
    [id4]
  );
  usePanEvent(containerRef, {
    onSessionStart: (ev) => {
      const { isInteractive: isInteractive2, values: values2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(true);
      const pointValue = getValueFromPointer(ev) || 0;
      const distances = values2.map((value) => Math.abs(value - pointValue));
      const closest = Math.min(...distances);
      let i = distances.indexOf(closest);
      const thumbsPosition = distances.filter(
        (distance3) => distance3 === closest
      );
      const isThumbStacked = thumbsPosition.length > 1;
      if (isThumbStacked && pointValue > values2[i])
        i = i + thumbsPosition.length - 1;
      setActiveIndex(i);
      constrain(i, pointValue);
      focusThumb(i);
      onChangeStart(values2);
    },
    onSessionEnd: () => {
      const { isInteractive: isInteractive2, values: values2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(false);
      onChangeEnd(values2);
    },
    onMove: (ev) => {
      const { isInteractive: isInteractive2 } = latestRef.current;
      if (!isInteractive2 || activeIndex == -1) return;
      const pointValue = getValueFromPointer(ev) || 0;
      setActiveIndex(activeIndex);
      constrain(activeIndex, pointValue);
      focusThumb(activeIndex);
    }
  });
  const getValueFromPointer = (0, import_react138.useCallback)(
    (ev) => {
      var _a, _b;
      if (!trackRef.current) return;
      const { min: min22, max: max22 } = latestRef.current;
      eventSourceRef.current = "pointer";
      const { bottom: bottom2, left: left2, height, width } = trackRef.current.getBoundingClientRect();
      const { clientX, clientY } = (_b = (_a = ev.touches) == null ? void 0 : _a[0]) != null ? _b : ev;
      const diff = isVertical ? bottom2 - clientY : clientX - left2;
      const length2 = isVertical ? height : width;
      let percent2 = diff / length2;
      if (isReversed) percent2 = 1 - percent2;
      let nextValue = percentToValue(percent2, min22, max22);
      return nextValue;
    },
    [latestRef, isVertical, isReversed]
  );
  const focusThumb = (0, import_react138.useCallback)(
    (i) => {
      var _a;
      i != null ? i : i = activeIndex;
      if (i === -1 || !focusThumbOnChange) return;
      const id22 = getThumbId(i);
      const el = (_a = containerRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id22);
      if (el) setTimeout(() => el.focus());
    },
    [activeIndex, focusThumbOnChange, getThumbId]
  );
  const constrain = (0, import_react138.useCallback)(
    (i, value) => {
      const { isInteractive: isInteractive2, valueBounds: valueBounds2, values: values2 } = latestRef.current;
      if (!isInteractive2) return;
      const { min: min22, max: max22 } = valueBounds2[i];
      value = parseFloat(roundNumberToStep(value, min22, oneStep));
      value = clampNumber(value, min22, max22);
      const nextValues = [...values2];
      nextValues[i] = value;
      setValues2(nextValues);
    },
    [latestRef, oneStep, setValues2]
  );
  const stepUp = (0, import_react138.useCallback)(
    (i, step2 = oneStep) => {
      const { values: values2 } = latestRef.current;
      const value = values2[i];
      constrain(i, isReversed ? value - step2 : value + step2);
    },
    [constrain, isReversed, latestRef, oneStep]
  );
  const stepDown = (0, import_react138.useCallback)(
    (i, step2 = oneStep) => {
      const { values: values2 } = latestRef.current;
      const value = values2[i];
      constrain(i, isReversed ? value + step2 : value - step2);
    },
    [constrain, isReversed, latestRef, oneStep]
  );
  const reset = (0, import_react138.useCallback)(
    () => setValues2(defaultValue),
    [defaultValue, setValues2]
  );
  const onKeyDown = (0, import_react138.useCallback)(
    (ev) => {
      const { valueBounds: valueBounds2 } = latestRef.current;
      const { min: min22, max: max22 } = valueBounds2[activeIndex];
      const actions = {
        ArrowRight: () => stepUp(activeIndex),
        ArrowUp: () => stepUp(activeIndex),
        ArrowLeft: () => stepDown(activeIndex),
        ArrowDown: () => stepDown(activeIndex),
        PageUp: () => stepUp(activeIndex, tenStep),
        PageDown: () => stepDown(activeIndex, tenStep),
        Home: () => constrain(activeIndex, min22),
        End: () => constrain(activeIndex, max22)
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action(ev);
      eventSourceRef.current = "keyboard";
    },
    [activeIndex, constrain, latestRef, stepDown, stepUp, tenStep]
  );
  useUpdateEffect(() => {
    const { values: values2 } = latestRef.current;
    if (eventSourceRef.current === "keyboard") onChangeEnd(values2);
  }, [startValue, endValue, onChangeEnd]);
  const getContainerProps = (0, import_react138.useCallback)(
    (props22 = {}, ref = null) => {
      var _a;
      let w = "$thumbSize";
      let h = "$thumbSize";
      if (thumbSizes.length) {
        const p = isVertical ? "height" : "width";
        const z = { width: 0, height: 0 };
        const { width, height } = (_a = thumbSizes.reduce((a = z, b = z) => a[p] > b[p] ? a : b, z)) != null ? _a : {};
        if (width) w = width;
        if (height) h = height;
      }
      const padding = isVertical ? { paddingLeft: `calc(${w} / 2)`, paddingRight: `calc(${w} / 2)` } : { paddingTop: `calc(${h} / 2)`, paddingBottom: `calc(${h} / 2)` };
      const style = {
        ...props22.style,
        position: "relative",
        userSelect: "none",
        touchAction: "none",
        WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
        outline: 0,
        ...padding
      };
      return {
        ...rest,
        ...props22,
        id: `slider-container-${id4}`,
        ref: mergeRefs(ref, containerRef),
        tabIndex: -1,
        style,
        var: [
          {
            name: "thumbSize",
            token: "sizes",
            value: thumbSizeProp
          }
        ]
      };
    },
    [id4, isVertical, rest, thumbSizeProp, thumbSizes]
  );
  const getInputProps = (0, import_react138.useCallback)(
    ({ index: i, ...props22 }, ref = null) => ({
      "aria-readonly": ariaReadonly,
      ...formControlProps,
      ...props22,
      ref,
      id: getInputId(i),
      type: "hidden",
      name: isArray(name) ? name[i] : `${name}-${i}`,
      value: values[i],
      required,
      disabled,
      readOnly
    }),
    [
      ariaReadonly,
      disabled,
      getInputId,
      name,
      readOnly,
      required,
      formControlProps,
      values
    ]
  );
  const getTrackProps = (0, import_react138.useCallback)(
    (props22 = {}, ref = null) => {
      const style = {
        ...props22.style,
        position: "absolute",
        ...isVertical ? {
          left: "50%",
          transform: "translateX(-50%)",
          height: "100%"
        } : {
          top: "50%",
          transform: "translateY(-50%)",
          width: "100%"
        }
      };
      return {
        ...formControlProps,
        ...props22,
        id: `slider-track-${id4}`,
        ref: mergeRefs(ref, trackRef),
        style
      };
    },
    [id4, isVertical, formControlProps]
  );
  const getFilledTrackProps = (0, import_react138.useCallback)(
    (props22 = {}, ref = null) => {
      const n = Math.abs(thumbPercents[1] - thumbPercents[0]);
      const s = isReversed ? 100 - thumbPercents[0] : thumbPercents[0];
      const style = {
        ...props22.style,
        position: "absolute",
        ...isVertical ? {
          left: "50%",
          transform: "translateX(-50%)",
          height: `${n}%`,
          ...isReversed ? { top: `${s}%` } : { bottom: `${s}%` }
        } : {
          top: "50%",
          transform: "translateY(-50%)",
          width: `${n}%`,
          ...isReversed ? { right: `${s}%` } : { left: `${s}%` }
        }
      };
      return {
        ...formControlProps,
        ...props22,
        id: `slider-filled-track-${id4}`,
        ref,
        style
      };
    },
    [id4, isReversed, isVertical, formControlProps, thumbPercents]
  );
  const getMarkProps = (0, import_react138.useCallback)(
    (props22, ref = null) => {
      let n = valueToPercent(props22.value, min2, max2);
      n = isReversed ? 100 - n : n;
      const style = {
        ...props22.style,
        position: "absolute",
        pointerEvents: "none",
        ...isVertical ? { bottom: `${n}%` } : { left: `${n}%` }
      };
      return {
        ...formControlProps,
        ...props22,
        ref,
        id: getMarkerId(props22.value),
        "aria-hidden": true,
        "data-invalid": dataAttr(props22.value < min2 || max2 < props22.value),
        "data-highlighted": dataAttr(
          values[0] <= props22.value && props22.value <= values[1]
        ),
        style
      };
    },
    [getMarkerId, isReversed, isVertical, max2, min2, formControlProps, values]
  );
  const getThumbProps = (0, import_react138.useCallback)(
    ({ index: i, ...props22 }, ref = null) => {
      var _a, _b;
      const n = thumbPercents[i];
      let w = "$thumbSize";
      let h = "$thumbSize";
      if (thumbSizes[i]) {
        w = `${(_a = thumbSizes[i]) == null ? void 0 : _a.width}px`;
        h = `${(_b = thumbSizes[i]) == null ? void 0 : _b.height}px`;
      }
      const bottom2 = `calc(${n}% - (${h} / 2))`;
      const left2 = `calc(${n}% - (${w} / 2))`;
      const style = {
        ...props22.style,
        position: "absolute",
        userSelect: "none",
        touchAction: "none",
        ...isVertical ? { bottom: bottom2 } : { left: left2 }
      };
      const value = values[i];
      if (value == null)
        throw new Error(
          `Cannot find value at index '${i}'. The 'value' or 'defaultValue'`
        );
      return {
        "aria-label": "Slider thumb",
        "aria-readonly": ariaReadonly,
        ...formControlProps,
        ...props22,
        ref,
        id: getThumbId(i),
        tabIndex: isInteractive && focusThumbOnChange ? 0 : void 0,
        role: "slider",
        "aria-valuemin": min2,
        "aria-valuemax": max2,
        "aria-valuenow": value,
        "data-active": dataAttr(
          isDragging && focusThumbOnChange && activeIndex === i
        ),
        "aria-orientation": orientation,
        "aria-valuetext": ariaValueText != null ? ariaValueText : value.toString(),
        onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
        onFocus: handlerAll(props22.onFocus, onFocus4, () => {
          setFocused(true);
          setActiveIndex(i);
        }),
        onBlur: handlerAll(props22.onBlur, onBlur4, () => {
          setFocused(false);
          setActiveIndex(-1);
        }),
        style
      };
    },
    [
      thumbPercents,
      thumbSizes,
      isVertical,
      values,
      ariaReadonly,
      formControlProps,
      getThumbId,
      isInteractive,
      focusThumbOnChange,
      min2,
      max2,
      isDragging,
      activeIndex,
      orientation,
      ariaValueText,
      onKeyDown,
      onFocus4,
      onBlur4
    ]
  );
  return {
    values,
    isFocused,
    isDragging,
    isVertical,
    stepUp,
    stepDown,
    reset,
    setActiveIndex,
    getThumbId,
    getInputId,
    getMarkerId,
    getContainerProps,
    getInputProps,
    getTrackProps,
    getFilledTrackProps,
    getMarkProps,
    getThumbProps
  };
};
var [RangeSliderProvider, useRangeSliderContext] = createContext2({
  name: "RangeSliderContext",
  errorMessage: `useRangeSliderContext returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
});
var RangeSlider2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("RangeSlider", props2);
  const {
    className,
    children,
    inputProps,
    trackProps,
    filledTrackProps,
    thumbProps,
    trackColor,
    filledTrackColor,
    trackSize,
    thumbColor,
    thumbSize,
    ...rest
  } = omitThemeProps(mergedProps);
  const {
    isVertical,
    getContainerProps,
    getInputProps,
    getTrackProps,
    getFilledTrackProps,
    getMarkProps,
    getThumbProps
  } = useRangeSlider({ ...rest, thumbSize: getThumbSize(thumbSize, styles2) });
  const css4 = { ...styles2.container };
  const validChildren = getValidChildren(children);
  const [customRangeSliderTrack] = findChildren(validChildren, RangeSliderTrack);
  const [customRangeSliderStartThumb] = findChildren(
    validChildren,
    RangeSliderStartThumb
  );
  const [customRangeSliderEndThumb] = findChildren(
    validChildren,
    RangeSliderEndThumb
  );
  const hasRangeSliderStartThumb = includesChildren(
    validChildren,
    RangeSliderStartThumb
  );
  const hasRangeSliderEndThumb = includesChildren(
    validChildren,
    RangeSliderEndThumb
  );
  const cloneChildren = !isEmpty(validChildren) ? omitChildren(
    validChildren,
    RangeSliderTrack,
    RangeSliderStartThumb,
    RangeSliderEndThumb
  ) : children;
  return (0, import_jsx_runtime116.jsx)(
    RangeSliderProvider,
    {
      value: {
        isVertical,
        getTrackProps,
        getFilledTrackProps,
        getMarkProps,
        getThumbProps,
        getInputProps,
        trackProps,
        trackColor,
        trackSize,
        filledTrackProps,
        filledTrackColor,
        thumbProps,
        thumbColor,
        thumbSize,
        inputProps,
        styles: styles2
      },
      children: (0, import_jsx_runtime116.jsxs)(
        ui.div,
        {
          className: cx("ui-slider", className),
          __css: css4,
          ...getContainerProps({}, ref),
          children: [
            customRangeSliderTrack != null ? customRangeSliderTrack : (0, import_jsx_runtime116.jsx)(RangeSliderTrack, {}),
            cloneChildren,
            customRangeSliderStartThumb != null ? customRangeSliderStartThumb : !hasRangeSliderStartThumb ? (0, import_jsx_runtime116.jsx)(RangeSliderStartThumb, {}) : null,
            customRangeSliderEndThumb != null ? customRangeSliderEndThumb : !hasRangeSliderEndThumb ? (0, import_jsx_runtime116.jsx)(RangeSliderEndThumb, {}) : null
          ]
        }
      )
    }
  );
});
var RangeSliderTrack = forwardRef22(
  ({ className, children, filledTrackProps, ...rest }, ref) => {
    const {
      styles: styles2,
      trackProps,
      trackColor,
      trackSize,
      isVertical,
      getTrackProps
    } = useRangeSliderContext();
    const css4 = { ...styles2.track };
    return (0, import_jsx_runtime116.jsx)(
      ui.div,
      {
        className: cx("ui-slider__track", className),
        __css: css4,
        ...getTrackProps(
          {
            ...trackColor ? { bg: trackColor } : {},
            ...trackSize ? isVertical ? { w: trackSize } : { h: trackSize } : {},
            ...trackProps,
            ...rest
          },
          ref
        ),
        children: children != null ? children : (0, import_jsx_runtime116.jsx)(RangeSliderFilledTrack, { ...filledTrackProps })
      }
    );
  }
);
var RangeSliderFilledTrack = forwardRef22(({ className, ...rest }, ref) => {
  const { styles: styles2, filledTrackProps, filledTrackColor, getFilledTrackProps } = useRangeSliderContext();
  const css4 = { ...styles2.filledTrack };
  return (0, import_jsx_runtime116.jsx)(
    ui.div,
    {
      className: cx("ui-slider__track-filled", className),
      __css: css4,
      ...getFilledTrackProps(
        {
          ...filledTrackColor ? { bg: filledTrackColor } : {},
          ...filledTrackProps,
          ...rest
        },
        ref
      )
    }
  );
});
var RangeSliderMark = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2, getMarkProps } = useRangeSliderContext();
    const css4 = {
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      ...styles2.mark
    };
    return (0, import_jsx_runtime116.jsx)(
      ui.div,
      {
        className: cx("ui-slider__mark", className),
        __css: css4,
        ...getMarkProps(rest, ref)
      }
    );
  }
);
var RangeSliderThumb = forwardRef22(({ className, index, children, ...rest }, ref) => {
  const {
    styles: styles2,
    thumbProps,
    thumbColor,
    thumbSize,
    inputProps,
    getThumbProps,
    getInputProps
  } = useRangeSliderContext();
  const css4 = { ...styles2.thumb };
  const { children: propChildren } = thumbProps != null ? thumbProps : {};
  return (0, import_jsx_runtime116.jsxs)(
    ui.div,
    {
      className: cx("ui-slider__thumb", className),
      __css: css4,
      ...getThumbProps(
        {
          index,
          ...thumbColor ? { bg: thumbColor } : {},
          ...thumbSize ? { boxSize: thumbSize } : {},
          ...thumbProps,
          ...rest
        },
        ref
      ),
      children: [
        (0, import_jsx_runtime116.jsx)(ui.input, { ...getInputProps({ ...inputProps, index }, ref) }),
        children != null ? children : propChildren
      ]
    }
  );
});
var RangeSliderStartThumb = forwardRef22(
  (rest, ref) => {
    return (0, import_jsx_runtime116.jsx)(RangeSliderThumb, { ref, index: 0, ...rest });
  }
);
var RangeSliderEndThumb = forwardRef22(
  (rest, ref) => {
    return (0, import_jsx_runtime116.jsx)(RangeSliderThumb, { ref, index: 1, ...rest });
  }
);

// node_modules/@yamada-ui/switch/dist/chunk-76VRVHIX.mjs
var import_react139 = __toESM(require_react(), 1);
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var Switch2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Switch", props2);
  const {
    className,
    gap = "0.5rem",
    children,
    icon,
    inputProps,
    labelProps,
    isReverse,
    flexDirection,
    transition = {
      type: "spring",
      stiffness: 700,
      damping: 40
    },
    ...computedProps
  } = omitThemeProps(mergedProps);
  const {
    isChecked,
    isFocused,
    isHovered,
    isActive,
    getContainerProps,
    getIconProps,
    getInputProps,
    getLabelProps,
    props: rest
  } = useCheckbox(computedProps);
  const cloneIcon = icon ? (0, import_react139.cloneElement)(icon, {
    isChecked,
    isFocused,
    isHovered,
    isActive
  }) : null;
  return (0, import_jsx_runtime117.jsxs)(
    ui.label,
    {
      ref,
      className: cx("ui-switch", className),
      __css: {
        cursor: "pointer",
        position: "relative",
        display: "inline-flex",
        flexDirection: flexDirection != null ? flexDirection : isReverse ? "row-reverse" : "row",
        alignItems: "center",
        verticalAlign: "top",
        gap,
        ...styles2.container
      },
      ...getContainerProps(),
      ...rest,
      children: [
        (0, import_jsx_runtime117.jsx)(
          ui.input,
          {
            role: "switch",
            "aria-checked": isChecked,
            className: cx("ui-switch__input", className),
            ...getInputProps(inputProps, ref)
          }
        ),
        cloneIcon != null ? cloneIcon : (0, import_jsx_runtime117.jsx)(
          ui.span,
          {
            className: cx("ui-switch__track", className),
            __css: {
              boxSizing: "content-box",
              display: "inline-flex",
              justifyContent: "flex-start",
              alignItems: "center",
              flexShrink: 0,
              ...styles2.track
            },
            ...getIconProps(),
            children: (0, import_jsx_runtime117.jsx)(
              ui.span,
              {
                as: motion.span,
                className: cx("ui-switch__thumb", className),
                "data-checked": dataAttr(isChecked),
                layout: true,
                transition,
                __css: { ...styles2.thumb }
              }
            )
          }
        ),
        children ? (0, import_jsx_runtime117.jsx)(
          ui.span,
          {
            className: cx("ui-switch__label", className),
            __css: { ...styles2.label },
            ...getLabelProps(labelProps),
            children
          }
        ) : null
      ]
    }
  );
});

// node_modules/@yamada-ui/tabs/dist/chunk-AKPON6FM.mjs
var import_react140 = __toESM(require_react(), 1);
var import_react141 = __toESM(require_react(), 1);
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var TabList = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { focusedIndex, orientation, tabListProps, styles: styles2 } = useTabsContext();
    const descendants = useTabsDescendantsContext();
    const isVertical = orientation === "vertical";
    const onNext = (0, import_react141.useCallback)(() => {
      var _a;
      const next2 = descendants.enabledNextValue(focusedIndex);
      if (next2) (_a = next2.node) == null ? void 0 : _a.focus();
    }, [descendants, focusedIndex]);
    const onPrev = (0, import_react141.useCallback)(() => {
      var _a;
      const prev2 = descendants.enabledPrevValue(focusedIndex);
      if (prev2) (_a = prev2.node) == null ? void 0 : _a.focus();
    }, [descendants, focusedIndex]);
    const onFirst = (0, import_react141.useCallback)(() => {
      var _a;
      const first = descendants.enabledFirstValue();
      if (first) (_a = first.node) == null ? void 0 : _a.focus();
    }, [descendants]);
    const onLast = (0, import_react141.useCallback)(() => {
      var _a;
      const last = descendants.enabledLastValue();
      if (last) (_a = last.node) == null ? void 0 : _a.focus();
    }, [descendants]);
    const onKeyDown = (0, import_react141.useCallback)(
      (ev) => {
        const actions = {
          ArrowLeft: () => !isVertical ? onPrev() : {},
          ArrowRight: () => !isVertical ? onNext() : {},
          ArrowDown: () => isVertical ? onNext() : {},
          ArrowUp: () => isVertical ? onPrev() : {},
          Home: onFirst,
          End: onLast
        };
        const action = actions[ev.key];
        if (!action) return;
        ev.preventDefault();
        action(ev);
      },
      [onFirst, onLast, isVertical, onPrev, onNext]
    );
    const css4 = { display: "flex", ...styles2.tabList };
    return (0, import_jsx_runtime118.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-tabs__list", className),
        role: "tablist",
        __css: css4,
        ...tabListProps,
        ...rest,
        onKeyDown: handlerAll(rest.onKeyDown, onKeyDown)
      }
    );
  }
);
var Tab = forwardRef22(
  ({
    className,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    clickOnEnter,
    clickOnSpace,
    children,
    ...props2
  }, ref) => {
    const {
      selectedIndex,
      isManual,
      disableRipple,
      setSelectedIndex,
      setFocusedIndex,
      styles: styles2
    } = useTabsContext();
    const { index, register } = useTabsDescendant({
      disabled: isDisabled2 && !isFocusable2
    });
    const isSelected = index === selectedIndex;
    const onFocus4 = () => {
      setFocusedIndex(index);
      if (!isManual && !(isDisabled2 && isFocusable2)) setSelectedIndex(index);
    };
    const rest = useClickable({
      ref: mergeRefs(register, ref),
      isDisabled: isDisabled2,
      isFocusable: isFocusable2,
      clickOnEnter,
      clickOnSpace,
      onClick: handlerAll(props2.onClick, () => setSelectedIndex(index))
    });
    const { onPointerDown, ...rippleProps } = useRipple({
      ...rest,
      isDisabled: disableRipple || isDisabled2
    });
    const css4 = {
      position: "relative",
      overflow: "hidden",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      ...styles2.tab
    };
    return (0, import_jsx_runtime119.jsxs)(
      ui.button,
      {
        className: cx("ui-tabs__tab", className),
        __css: css4,
        role: "tab",
        ...props2,
        ...rest,
        type: "button",
        tabIndex: isSelected ? 0 : -1,
        "aria-selected": ariaAttr(isSelected),
        onPointerDown,
        onFocus: isDisabled2 ? void 0 : handlerAll(props2.onFocus, onFocus4),
        children: [
          children,
          (0, import_jsx_runtime119.jsx)(Ripple, { isDisabled: disableRipple || isDisabled2, ...rippleProps })
        ]
      }
    );
  }
);
var [TabPanelProvider, useTabPanelContext] = createContext2({});
var TabPanels = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { selectedIndex, tabPanelsProps, styles: styles2 } = useTabsContext();
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map((child, index) => {
      const isSelected = index === selectedIndex;
      return (0, import_react142.createElement)(
        TabPanelProvider,
        { key: index, value: { isSelected, selectedIndex } },
        child
      );
    });
    const css4 = {
      w: "100%",
      ...styles2.tabPanels
    };
    return (0, import_jsx_runtime120.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-tabs__panels", className),
        __css: css4,
        ...tabPanelsProps,
        ...rest,
        children: cloneChildren
      }
    );
  }
);
var TabPanel = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { isLazy: enabled2, lazyBehavior: mode2, styles: styles2 } = useTabsContext();
    const { isSelected } = useTabPanelContext();
    const hasBeenSelected = (0, import_react143.useRef)(false);
    if (isSelected) hasBeenSelected.current = true;
    const shouldRenderChildren = useLazyDisclosure({
      wasSelected: hasBeenSelected.current,
      isSelected,
      enabled: enabled2,
      mode: mode2
    });
    const css4 = { ...styles2.tabPanel };
    return (0, import_jsx_runtime121.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-tabs__panel", className),
        role: "tabpanel",
        __css: css4,
        ...rest,
        hidden: !isSelected,
        children: shouldRenderChildren ? children : null
      }
    );
  }
);
var {
  DescendantsContextProvider: DescendantsContextProvider6,
  useDescendantsContext: useTabsDescendantsContext,
  useDescendants: useDescendants6,
  useDescendant: useTabsDescendant
} = createDescendant();
var [TabsProvider, useTabsContext] = createContext2({
  name: "TabsContext",
  errorMessage: `useTabsContext returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />"`
});
var Tabs2 = forwardRef22(
  ({ align = "start", ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Tabs", {
      align,
      ...props2
    });
    const {
      className,
      index,
      defaultIndex = 0,
      onChange,
      isFitted,
      isManual,
      isLazy = true,
      disableRipple = false,
      lazyBehavior = "keepMounted",
      orientation = "horizontal",
      tabListProps,
      tabPanelsProps,
      children,
      ...rest
    } = omitThemeProps(mergedProps);
    const [focusedIndex, setFocusedIndex] = (0, import_react140.useState)(defaultIndex);
    const [selectedIndex, setSelectedIndex] = useControllableState({
      value: index,
      defaultValue: defaultIndex,
      onChange
    });
    const descendants = useDescendants6();
    const validChildren = getValidChildren(children);
    const [customTabList] = findChildren(validChildren, TabList);
    const [customTabPanels] = findChildren(validChildren, TabPanels);
    const cloneTabs = pickChildren(validChildren, Tab);
    const cloneTabPanels = pickChildren(validChildren, TabPanel);
    (0, import_react140.useEffect)(() => {
      if (index != null) setFocusedIndex(index);
    }, [index]);
    const css4 = { w: "100%", ...styles2.container };
    return (0, import_jsx_runtime122.jsx)(DescendantsContextProvider6, { value: descendants, children: (0, import_jsx_runtime122.jsx)(
      TabsProvider,
      {
        value: {
          focusedIndex,
          setFocusedIndex,
          selectedIndex,
          setSelectedIndex,
          disableRipple,
          isFitted,
          align,
          isManual,
          isLazy,
          lazyBehavior,
          orientation,
          tabListProps,
          tabPanelsProps,
          styles: styles2
        },
        children: (0, import_jsx_runtime122.jsxs)(
          ui.div,
          {
            ref,
            className: cx("ui-tabs", className),
            __css: css4,
            ...rest,
            children: [
              customTabList != null ? customTabList : (0, import_jsx_runtime122.jsx)(TabList, { children: cloneTabs }),
              customTabPanels != null ? customTabPanels : (0, import_jsx_runtime122.jsx)(TabPanels, { children: cloneTabPanels })
            ]
          }
        )
      }
    ) });
  }
);

// node_modules/@yamada-ui/tag/dist/chunk-5TQMVFJH.mjs
var import_react144 = __toESM(require_react(), 1);
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var Tag2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Tag", props2);
  const {
    className,
    leftIcon,
    rightIcon,
    onClose,
    isDisabled: isDisabled2,
    children,
    ...rest
  } = omitThemeProps(mergedProps);
  const css4 = {
    maxW: "100%",
    display: "inline-flex",
    alignItems: "center",
    gap: "fallback(1, 0.25rem)",
    verticalAlign: "top",
    ...styles2.container
  };
  return (0, import_jsx_runtime123.jsxs)(
    ui.span,
    {
      ref,
      className: cx("ui-tag", className),
      __css: css4,
      ...rest,
      children: [
        leftIcon,
        (0, import_jsx_runtime123.jsx)(ui.span, { lineClamp: 1, __css: styles2.label, children }),
        rightIcon,
        onClose ? (0, import_jsx_runtime123.jsx)(CloseButton3, { isDisabled: isDisabled2, onClick: onClose, children: (0, import_jsx_runtime123.jsx)(CloseIcon2, {}) }) : null
      ]
    }
  );
});
var CloseIcon2 = () => {
  return (0, import_jsx_runtime123.jsx)(Icon, { verticalAlign: "inherit", viewBox: "0 0 512 512", fontSize: "1.125rem", children: (0, import_jsx_runtime123.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
    }
  ) });
};
var CloseButton3 = ({ children, ...props2 }) => {
  const ref = (0, import_react144.useRef)(null);
  const [styles2] = useMultiComponentStyle("Tag", props2);
  const css4 = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    outline: "0",
    cursor: "pointer",
    ...styles2.closeButton
  };
  const rest = useClickable({ ref, ...props2 });
  return (0, import_jsx_runtime123.jsx)(ui.span, { "aria-label": "Close tag", __css: css4, ...rest, children });
};

// node_modules/@yamada-ui/textarea/dist/chunk-VTY3KHND.mjs
var import_react145 = __toESM(require_react(), 1);
var useAutosize = (ref, maxRows, minRows) => {
  const valueRef = (0, import_react145.useRef)();
  const resizeTextarea = () => {
    const el = ref.current;
    if (!el) return;
    let { value, placeholder } = el;
    if (value === valueRef.current) return;
    else valueRef.current = value;
    value != null ? value : value = placeholder != null ? placeholder : "x";
    const nodeSizeData = getSizingData(el);
    if (!nodeSizeData) return;
    const rows = calcRows(el, nodeSizeData, value, maxRows, minRows);
    el.rows = rows;
  };
  return resizeTextarea;
};
var SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
];
var getSizingData = (el) => {
  const style = window == null ? void 0 : window.getComputedStyle(el);
  if (style == null) return null;
  const sizingStyle = pickObject(
    style,
    SIZING_STYLE
  );
  const { boxSizing } = sizingStyle;
  if (boxSizing === "") return null;
  const paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  const borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  const singleRowHeight = parseFloat(sizingStyle.lineHeight);
  return {
    sizingStyle,
    paddingSize,
    borderSize,
    singleRowHeight
  };
};
var calcRows = (el, sizingData, value, maxRows, minRows) => {
  const clone = el.cloneNode();
  Object.assign(clone.style, sizingData.sizingStyle);
  forceHiddenStyles(clone);
  clone.value = value;
  document.body.appendChild(clone);
  let rows;
  if (clone.scrollHeight) {
    const rowHeight = sizingData.singleRowHeight;
    rows = Math.min(
      maxRows,
      Math.max(minRows, Math.floor(clone.scrollHeight / rowHeight))
    );
  } else {
    const lineBreaks = (value.match(/\n/g) || []).length;
    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1));
  }
  document.body.removeChild(clone);
  return rows;
};
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
};
var forceHiddenStyles = (el) => {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((key) => {
    el.style.setProperty(
      key,
      HIDDEN_TEXTAREA_STYLE[key],
      "important"
    );
  });
};
var use_autosize_default = useAutosize;

// node_modules/@yamada-ui/textarea/dist/chunk-7RSD2MNU.mjs
var import_react146 = __toESM(require_react(), 1);
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var Textarea2 = forwardRef22((props2, ref) => {
  var _a, _b;
  const [
    { h, height, minH, minHeight, maxH, maxHeight, ...styles2 },
    mergedProps
  ] = useComponentStyle("Textarea", props2);
  let {
    className,
    rows,
    resize: resize2 = "none",
    autosize,
    maxRows = Infinity,
    minRows = 1,
    resizeRef,
    onChange,
    ...rest
  } = omitThemeProps(mergedProps);
  rest = useFormControlProps(rest);
  const isBrowser4 = createdDom();
  const textareaRef = (0, import_react146.useRef)(null);
  const value = (_b = (_a = textareaRef.current) == null ? void 0 : _a.value) != null ? _b : "";
  const resizeTextarea = use_autosize_default(textareaRef, maxRows, minRows);
  let css4;
  if (rows || autosize) {
    css4 = styles2;
  } else {
    css4 = { h, height, minH, minHeight, maxH, maxHeight, ...styles2 };
  }
  useSafeLayoutEffect(() => {
    if (!isBrowser4 || !autosize) return;
    resizeTextarea();
    const unsubscribeResize = addDomEvent(window, "resize", resizeTextarea);
    const unsubscribeLoadingdone = addDomEvent(
      document.fonts,
      "loadingdone",
      resizeTextarea
    );
    return () => {
      unsubscribeResize();
      unsubscribeLoadingdone();
    };
  }, []);
  useUpdateEffect(() => {
    if (!autosize) return;
    resizeTextarea();
  }, [value]);
  assignRef(resizeRef, resizeTextarea);
  return (0, import_jsx_runtime124.jsx)(
    ui.textarea,
    {
      ref: mergeRefs(ref, textareaRef),
      className: cx("ui-textarea", className),
      __css: css4,
      resize: resize2,
      rows,
      onChange: handlerAll(autosize ? resizeTextarea : noop, onChange),
      ...rest
    }
  );
});

// node_modules/@yamada-ui/tooltip/dist/chunk-W7CRWSR7.mjs
var import_react147 = __toESM(require_react(), 1);
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var getTooltipProps = (animation2 = "scale", duration) => {
  const custom = {
    reverse: true,
    duration,
    enter: { visibility: "visible" },
    transitionEnd: { exit: { visibility: "hidden" } }
  };
  switch (animation2) {
    case "scale":
      return {
        ...scaleFadeProps,
        custom: { ...custom, scale: 0.95 }
      };
    case "top":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetY: -16 }
      };
    case "right":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: 16 }
      };
    case "left":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: -16 }
      };
    case "bottom":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetY: 16 }
      };
  }
};
var Tooltip2 = forwardRef22(
  ({ z: zProp, zIndex: zIndexProp, portalProps, withPortal = true, ...props2 }, ref) => {
    var _a, _b;
    let [{ z, zIndex, ...styles2 }, mergedProps] = useComponentStyle(
      "Tooltip",
      props2
    );
    const {
      className,
      children,
      label,
      placement,
      modifiers,
      gutter,
      offset: offset2,
      openDelay = 0,
      closeDelay = 0,
      isDisabled: isDisabled2,
      closeOnClick,
      closeOnScroll,
      closeOnMouseDown = false,
      closeOnPointerDown = false,
      closeOnEsc = true,
      animation: animation2,
      duration,
      isOpen: isOpenProp,
      defaultIsOpen: defaultIsOpenProp,
      onOpen: onOpenProp,
      onClose: onCloseProp,
      ...rest
    } = omitThemeProps(mergedProps);
    const effectiveCloseOnPointerDown = closeOnPointerDown || closeOnMouseDown;
    const labelId = (0, import_react147.useId)();
    const { isOpen, onOpen, onClose } = useDisclosure({
      isOpen: isOpenProp,
      defaultIsOpen: defaultIsOpenProp,
      onOpen: onOpenProp,
      onClose: onCloseProp
    });
    const triggerRef = (0, import_react147.useRef)(null);
    const openTimeout = (0, import_react147.useRef)();
    const closeTimeout = (0, import_react147.useRef)();
    const { referenceRef, getPopperProps, transformOrigin } = usePopper({
      enabled: isOpen,
      placement,
      modifiers,
      gutter,
      offset: offset2
    });
    const closeNow = (0, import_react147.useCallback)(() => {
      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
        closeTimeout.current = void 0;
      }
      onClose();
    }, [onClose]);
    const openWithDelay = (0, import_react147.useCallback)(() => {
      if (!isDisabled2 && !openTimeout.current) {
        if (isOpen) closeNow();
        const win = getOwnerWindow(triggerRef.current);
        openTimeout.current = win.setTimeout(onOpen, openDelay);
      }
    }, [isDisabled2, isOpen, openDelay, closeNow, onOpen]);
    const closeWithDelay = (0, import_react147.useCallback)(() => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
        openTimeout.current = void 0;
      }
      const win = getOwnerWindow(triggerRef.current);
      closeTimeout.current = win.setTimeout(closeNow, closeDelay);
    }, [closeDelay, closeNow]);
    const onClick2 = (0, import_react147.useCallback)(
      () => isOpen && closeOnClick ? closeWithDelay() : void 0,
      [isOpen, closeOnClick, closeWithDelay]
    );
    const onPointerDown = (0, import_react147.useCallback)(
      () => isOpen && effectiveCloseOnPointerDown ? closeWithDelay() : void 0,
      [isOpen, effectiveCloseOnPointerDown, closeWithDelay]
    );
    const onKeyDown = (0, import_react147.useCallback)(
      (ev) => isOpen && ev.key === "Escape" ? closeWithDelay() : void 0,
      [isOpen, closeWithDelay]
    );
    const getTriggerProps = (0, import_react147.useCallback)(
      (props22 = {}, ref2 = null) => ({
        ...props22,
        ref: mergeRefs(triggerRef, ref2, referenceRef),
        onPointerEnter: handlerAll(props22.onPointerEnter, openWithDelay),
        onClick: handlerAll(props22.onClick, onClick2),
        onPointerDown: handlerAll(props22.onPointerDown, onPointerDown),
        onFocus: handlerAll(props22.onFocus, openWithDelay),
        onBlur: handlerAll(props22.onBlur, closeWithDelay)
      }),
      [referenceRef, onClick2, onPointerDown, openWithDelay, closeWithDelay]
    );
    useEventListener(
      () => getOwnerDocument(triggerRef.current),
      "keydown",
      (ev) => closeOnEsc ? onKeyDown(ev) : void 0
    );
    useEventListener(
      () => getOwnerDocument(triggerRef.current),
      "scroll",
      () => isOpen && closeOnScroll ? closeNow() : void 0
    );
    useEventListener(
      () => triggerRef.current,
      "pointerleave",
      (e) => {
        if (e.pointerType !== "touch") closeWithDelay();
      }
    );
    useEventListener(
      () => triggerRef.current,
      "touchstart",
      () => {
        if (isOpen) closeWithDelay();
        else openWithDelay();
      },
      { passive: true }
    );
    useOutsideClick({
      ref: triggerRef,
      handler: () => {
        closeWithDelay();
      }
    });
    (0, import_react147.useEffect)(
      () => () => {
        clearTimeout(openTimeout.current);
        clearTimeout(closeTimeout.current);
      },
      []
    );
    if (!label) return (0, import_jsx_runtime125.jsx)(import_jsx_runtime125.Fragment, { children });
    const child = import_react147.Children.only(children);
    const trigger2 = (0, import_react147.cloneElement)(
      child,
      getTriggerProps(
        { ...child.props, "aria-describedby": labelId },
        child.ref
      )
    );
    const css4 = {
      position: "relative",
      ...styles2
    };
    const resolvedZIndex = (_b = (_a = zIndexProp != null ? zIndexProp : zProp) != null ? _a : zIndex) != null ? _b : z;
    return (0, import_jsx_runtime125.jsxs)(import_jsx_runtime125.Fragment, { children: [
      trigger2,
      (0, import_jsx_runtime125.jsx)(
        ui.span,
        {
          id: labelId,
          style: {
            border: "0px",
            clip: "rect(0px, 0px, 0px, 0px)",
            height: "1px",
            width: "1px",
            margin: "-1px",
            padding: "0px",
            overflow: "hidden",
            whiteSpace: "nowrap",
            position: "absolute"
          },
          children: label
        }
      ),
      (0, import_jsx_runtime125.jsx)(AnimatePresence, { children: isOpen ? (0, import_jsx_runtime125.jsx)(Portal, { isDisabled: !withPortal, ...portalProps, children: (0, import_jsx_runtime125.jsx)(
        ui.div,
        {
          ...getPopperProps(),
          zIndex: resolvedZIndex,
          pointerEvents: "none",
          children: (0, import_jsx_runtime125.jsx)(
            ui.div,
            {
              as: motion.div,
              ref,
              className: cx("ui-tooltip", className),
              role: "tooltip",
              style: { transformOrigin },
              ...animation2 !== "none" ? getTooltipProps(animation2, duration) : {},
              initial: "exit",
              animate: isOpen ? "enter" : "exit",
              exit: "exit",
              __css: css4,
              ...rest,
              children: label
            }
          )
        }
      ) }) : null })
    ] });
  }
);

// node_modules/@yamada-ui/use-resize-observer/dist/index.mjs
var import_react148 = __toESM(require_react(), 1);
var defaultRect = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
var useResizeObserver = () => {
  const id4 = (0, import_react148.useRef)(0);
  const ref = (0, import_react148.useRef)(null);
  const [rect, setRect] = (0, import_react148.useState)(defaultRect);
  const observer2 = (0, import_react148.useMemo)(() => {
    const isBrowser4 = createdDom();
    if (!isBrowser4) return null;
    return new ResizeObserver(([entry]) => {
      if (!entry) return;
      cancelAnimationFrame(id4.current);
      id4.current = requestAnimationFrame(() => {
        if (ref.current) setRect(entry.contentRect);
      });
    });
  }, []);
  (0, import_react148.useEffect)(() => {
    if (ref.current) observer2 == null ? void 0 : observer2.observe(ref.current);
    return () => {
      observer2 == null ? void 0 : observer2.disconnect();
      if (id4.current) cancelAnimationFrame(id4.current);
    };
  }, [observer2]);
  return [ref, rect];
};
var useElementSize = () => {
  const [ref, { width, height }] = useResizeObserver();
  return { ref, width, height };
};

// node_modules/@yamada-ui/scroll-area/dist/chunk-X5P7TVZN.mjs
var import_react149 = __toESM(require_react(), 1);
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var neverStyles = {
  scrollbarWidth: "none",
  _scrollbar: { display: "none" },
  "&::-webkit-scrollbar": { display: "none" }
};
var hiddenStyles = {
  _scrollbarTrack: { bg: "transparent" },
  "&::-webkit-scrollbar-track": { bg: "transparent" },
  _scrollbarThumb: { bg: "transparent" },
  "&::-webkit-scrollbar-thumb": { bg: "transparent" },
  _light: {
    _scrollbarTrack: { bg: "transparent" },
    "&::-webkit-scrollbar-track": { bg: "transparent" },
    _scrollbarThumb: { bg: "transparent" },
    "&::-webkit-scrollbar-thumb": { bg: "transparent" }
  },
  _dark: {
    _scrollbarTrack: { bg: "transparent" },
    "&::-webkit-scrollbar-track": { bg: "transparent" },
    _scrollbarThumb: { bg: "transparent" },
    "&::-webkit-scrollbar-thumb": { bg: "transparent" }
  },
  "@-moz-document url-prefix()": {
    scrollbarColor: "transparent transparent",
    _light: {
      scrollbarColor: "transparent transparent"
    },
    _dark: {
      scrollbarColor: "transparent transparent"
    }
  }
};
var ScrollArea2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("ScrollArea", props2);
  const {
    type = "hover",
    overflow = "overlay",
    scrollHideDelay = 1e3,
    onScrollPositionChange,
    ...rest
  } = omitThemeProps(mergedProps);
  const [isHovered, setIsHovered] = (0, import_react149.useState)(false);
  const [isScrolling, setIsScrolling] = (0, import_react149.useState)(false);
  const isAlways = type === "always";
  const isNever = type === "never";
  const isSafari2 = isMac() && vendor(/apple/i);
  const hoverTimeout = (0, import_react149.useRef)(void 0);
  const scrollTimeout = (0, import_react149.useRef)(void 0);
  const scrollAreaRef = (0, import_react149.useRef)(null);
  const scrollPosition = (0, import_react149.useRef)({ x: 0, y: 0 });
  useSafeLayoutEffect(() => {
    if (!scrollAreaRef.current || !isSafari2) return;
    scrollAreaRef.current.scrollLeft = scrollPosition.current.x;
    scrollAreaRef.current.scrollTop = scrollPosition.current.y;
  });
  const onMouseEnter = (0, import_react149.useCallback)(() => {
    if (type !== "hover") return;
    clearTimeout(hoverTimeout.current);
    setIsHovered(true);
  }, [type]);
  const onMouseLeave = (0, import_react149.useCallback)(() => {
    if (type !== "hover") return;
    hoverTimeout.current = setTimeout(
      () => setIsHovered(false),
      scrollHideDelay
    );
  }, [scrollHideDelay, type]);
  const onScroll2 = (0, import_react149.useCallback)(
    (ev) => {
      const el = ev.target;
      const { scrollLeft: x, scrollTop: y } = el;
      const { x: prevX, y: prevY } = scrollPosition.current;
      const isEqual2 = Math.abs(x - prevX) <= 5 && Math.abs(y - prevY) <= 5;
      onScrollPositionChange == null ? void 0 : onScrollPositionChange({ x, y });
      scrollPosition.current = { x, y };
      if (type !== "scroll" || isEqual2) return;
      if (!isScrolling) setIsScrolling(true);
      clearTimeout(scrollTimeout.current);
      scrollTimeout.current = setTimeout(
        () => setIsScrolling(false),
        scrollHideDelay
      );
    },
    [isScrolling, onScrollPositionChange, scrollHideDelay, type]
  );
  (0, import_react149.useEffect)(() => {
    return () => {
      if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
      if (scrollTimeout.current) clearTimeout(scrollTimeout.current);
    };
  }, []);
  const css4 = (0, import_react149.useMemo)(() => {
    const baseStyle = { overflow, ...styles2 };
    if (isNever) {
      return merge(baseStyle, neverStyles);
    } else {
      return merge(
        baseStyle,
        !isAlways && !isHovered && !isScrolling ? hiddenStyles : {}
      );
    }
  }, [isAlways, isHovered, isNever, isScrolling, overflow, styles2]);
  const computedProps = (0, import_react149.useMemo)(
    () => ({
      __css: css4,
      ...rest,
      onMouseEnter: handlerAll(rest.onMouseEnter, onMouseEnter),
      onMouseLeave: handlerAll(rest.onMouseLeave, onMouseLeave),
      onScroll: handlerAll(rest.onScroll, onScroll2)
    }),
    [css4, onMouseEnter, onMouseLeave, onScroll2, rest]
  );
  if (isSafari2) {
    const componentKey = `${isHovered}-${isScrolling}`;
    return (0, import_jsx_runtime126.jsx)(
      InternalScrollArea,
      {
        ref: mergeRefs(ref, scrollAreaRef),
        "data-key": componentKey,
        "data-hovered": dataAttr(isHovered),
        "data-scrolling": dataAttr(isScrolling),
        ...computedProps
      },
      componentKey
    );
  } else {
    return (0, import_jsx_runtime126.jsx)(
      InternalScrollArea,
      {
        ref,
        "data-hovered": dataAttr(isHovered),
        "data-scrolling": dataAttr(isScrolling),
        ...computedProps
      }
    );
  }
});
var InternalScrollArea = forwardRef22(
  ({ className, innerProps, children, ...rest }, ref) => {
    return (0, import_jsx_runtime126.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-scroll-area", className),
        tabIndex: 0,
        ...rest,
        children: innerProps ? (0, import_jsx_runtime126.jsx)(ui.div, { className: "ui-scroll-area__inner", ...innerProps, children }) : children
      }
    );
  }
);

// node_modules/@yamada-ui/autocomplete/dist/chunk-ZJ2E3I2R.mjs
var import_react150 = __toESM(require_react(), 1);
var import_react151 = __toESM(require_react(), 1);
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var AutocompleteIcon = forwardRef22(
  ({ className, children, __css, ...rest }, ref) => {
    const { styles: styles2 } = useAutocompleteContext();
    const css4 = {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      cursor: "pointer",
      ...styles2.icon,
      ...__css
    };
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map(
      (child) => (0, import_react151.cloneElement)(child, {
        focusable: false,
        "aria-hidden": true,
        style: {
          maxWidth: "1em",
          maxHeight: "1em",
          color: "currentColor"
        }
      })
    );
    return (0, import_jsx_runtime127.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-autocomplete__icon", className),
        __css: css4,
        ...rest,
        children: isValidElement2(children) ? cloneChildren : (0, import_jsx_runtime127.jsx)(ChevronIcon, {})
      }
    );
  }
);
var AutocompleteClearIcon = ({
  className,
  children,
  ...props2
}) => {
  const ref = (0, import_react151.useRef)(null);
  const { styles: styles2 } = useAutocompleteContext();
  const isDisabled2 = props2.disabled;
  const rest = useClickable({
    ref,
    isDisabled: isDisabled2,
    ...props2
  });
  return (0, import_jsx_runtime127.jsx)(
    AutocompleteIcon,
    {
      "aria-label": "Clear value",
      className: cx("ui-autocomplete__icon--clear", className),
      __css: styles2.clearIcon,
      ...rest,
      children: children != null ? children : (0, import_jsx_runtime127.jsx)(CloseIcon, { w: "0.5em", h: "0.5em" })
    }
  );
};
var AutocompleteItemIcon = forwardRef22(({ className, ...rest }, ref) => {
  const { styles: styles2 } = useAutocompleteContext();
  const css4 = {
    flexShrink: 0,
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    fontSize: "0.85em",
    ...styles2.itemIcon
  };
  return (0, import_jsx_runtime127.jsx)(
    ui.span,
    {
      ref,
      className: cx("ui-autocomplete__item__icon", className),
      __css: css4,
      ...rest
    }
  );
});
var Autocomplete2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Autocomplete", props2);
    let {
      className,
      defaultValue = "",
      color: color2,
      h,
      height,
      minH,
      minHeight,
      containerProps,
      contentProps,
      listProps,
      fieldProps,
      inputProps,
      iconProps,
      portalProps = { isDisabled: true },
      createProps,
      emptyProps,
      header,
      footer,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      value,
      onClose,
      descendants,
      formControlProps,
      getPopoverProps,
      getContainerProps,
      getFieldProps,
      allowCreate,
      isEmpty: isEmpty2,
      inputValue,
      computedChildren,
      ...rest
    } = useAutocomplete({ ...computedProps, defaultValue, children });
    h != null ? h : h = height;
    minH != null ? minH : minH = minHeight;
    const css4 = {
      w: "100%",
      h: "fit-content",
      color: color2,
      ...styles2.container
    };
    return (0, import_jsx_runtime128.jsx)(AutocompleteDescendantsContextProvider, { value: descendants, children: (0, import_jsx_runtime128.jsx)(
      AutocompleteProvider,
      {
        value: {
          ...rest,
          value,
          onClose,
          formControlProps,
          inputValue,
          allowCreate,
          isEmpty: isEmpty2,
          styles: styles2
        },
        children: (0, import_jsx_runtime128.jsx)(Popover2, { ...getPopoverProps(), children: (0, import_jsx_runtime128.jsxs)(
          ui.div,
          {
            className: cx("ui-autocomplete", className),
            __css: css4,
            ...getContainerProps(containerProps),
            children: [
              (0, import_jsx_runtime128.jsxs)(
                ui.div,
                {
                  className: "ui-autocomplete__inner",
                  __css: { position: "relative", ...styles2.inner },
                  children: [
                    (0, import_jsx_runtime128.jsx)(
                      AutocompleteField,
                      {
                        h,
                        minH,
                        inputProps,
                        ...getFieldProps(fieldProps, ref)
                      }
                    ),
                    (0, import_jsx_runtime128.jsx)(AutocompleteIcon, { ...iconProps, ...formControlProps })
                  ]
                }
              ),
              !isEmpty2 ? (0, import_jsx_runtime128.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime128.jsxs)(
                AutocompleteList,
                {
                  header: runIfFunc(header, { value, onClose }),
                  footer: runIfFunc(footer, { value, onClose }),
                  contentProps,
                  ...listProps,
                  children: [
                    allowCreate ? (0, import_jsx_runtime128.jsx)(AutocompleteCreate, { ...createProps }) : (0, import_jsx_runtime128.jsx)(AutocompleteEmpty, { ...emptyProps }),
                    children != null ? children : computedChildren
                  ]
                }
              ) }) : (0, import_jsx_runtime128.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime128.jsx)(
                AutocompleteList,
                {
                  header: runIfFunc(header, { value, onClose }),
                  footer: runIfFunc(footer, { value, onClose }),
                  contentProps,
                  ...listProps,
                  children: allowCreate && inputValue ? (0, import_jsx_runtime128.jsx)(AutocompleteCreate, { ...createProps }) : (0, import_jsx_runtime128.jsx)(AutocompleteEmpty, { ...emptyProps })
                }
              ) })
            ]
          }
        ) })
      }
    ) });
  }
);
var AutocompleteField = forwardRef22(
  ({ className, h, minH, placeholder, inputProps, ...rest }, ref) => {
    const { label, inputValue, styles: styles2 } = useAutocompleteContext();
    const { getInputProps } = useAutocompleteInput();
    const css4 = {
      pe: "2rem",
      h,
      minH,
      display: "flex",
      alignItems: "center",
      ...styles2.field,
      cursor: "text"
    };
    return (0, import_jsx_runtime128.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime128.jsx)(
      ui.div,
      {
        className: cx("ui-autocomplete__field", className),
        __css: css4,
        ...rest,
        children: (0, import_jsx_runtime128.jsx)(
          ui.input,
          {
            className: "ui-autocomplete__field__input",
            display: "inline-block",
            w: "100%",
            placeholder,
            ...getInputProps(
              { ...inputProps, value: inputValue || label || "" },
              ref
            )
          }
        )
      }
    ) });
  }
);
var AutocompleteOptionGroup = forwardRef22(
  ({ className, color: color2, h, height, minH, minHeight, children, ...rest }, ref) => {
    const { styles: styles2 } = useAutocompleteContext();
    const { label, getContainerProps, getGroupProps } = useAutocompleteOptionGroup(rest);
    h != null ? h : h = height;
    minH != null ? minH : minH = minHeight;
    return (0, import_jsx_runtime129.jsxs)(
      ui.li,
      {
        className: cx(
          "ui-autocomplete__item",
          "ui-autocomplete__item--group",
          className
        ),
        __css: { w: "100%", h: "fit-content", color: color2 },
        ...getContainerProps(),
        children: [
          (0, import_jsx_runtime129.jsx)(
            ui.span,
            {
              className: "ui-autocomplete__item__group-label",
              __css: styles2.groupLabel,
              lineClamp: 1,
              children: label
            }
          ),
          (0, import_jsx_runtime129.jsx)(
            ui.ul,
            {
              ...getGroupProps({}, ref),
              className: "ui-autocomplete__item__group",
              __css: { h, minH, ...styles2.group },
              children
            }
          )
        ]
      }
    );
  }
);
var AutocompleteOption = forwardRef22(
  ({ className, icon, ...rest }, ref) => {
    const { styles: styles2 } = useAutocompleteContext();
    const { isSelected, customIcon, children, getOptionProps } = useAutocompleteOption(rest);
    icon != null ? icon : icon = customIcon;
    const css4 = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      ...styles2.item
    };
    return (0, import_jsx_runtime130.jsxs)(
      ui.li,
      {
        className: cx("ui-autocomplete__item", className),
        __css: css4,
        ...getOptionProps({}, ref),
        children: [
          icon !== null ? (0, import_jsx_runtime130.jsx)(AutocompleteItemIcon, { opacity: isSelected ? 1 : 0, children: icon || (0, import_jsx_runtime130.jsx)(CheckIcon5, {}) }) : null,
          (0, import_jsx_runtime130.jsx)(ui.span, { style: { flex: 1 }, "data-label": true, children })
        ]
      }
    );
  }
);
var CheckIcon5 = () => (0, import_jsx_runtime130.jsx)("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", children: (0, import_jsx_runtime130.jsx)(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) });
var AutocompleteCreate = forwardRef22(
  ({ className, icon, children, ...rest }, ref) => {
    const { inputValue, styles: styles2 } = useAutocompleteContext();
    const { getCreateProps } = useAutocompleteCreate();
    children != null ? children : children = inputValue;
    const css4 = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      ...styles2.item
    };
    return (0, import_jsx_runtime131.jsxs)(
      ui.li,
      {
        className: cx("ui-autocomplete__item--create", className),
        __css: css4,
        ...getCreateProps(rest, ref),
        children: [
          icon !== null ? (0, import_jsx_runtime131.jsx)(AutocompleteItemIcon, { children: icon || (0, import_jsx_runtime131.jsx)(PlusIcon, {}) }) : null,
          icon ? (0, import_jsx_runtime131.jsx)(ui.span, { style: { pointerEvents: "none", flex: 1 }, lineClamp: 1, children: runIfFunc(children, inputValue) }) : runIfFunc(children, inputValue)
        ]
      }
    );
  }
);
var PlusIcon = () => (0, import_jsx_runtime131.jsx)("svg", { viewBox: "0 0 45.402 45.402", width: "1em", height: "1em", children: (0, import_jsx_runtime131.jsx)(
  "path",
  {
    fill: "currentColor",
    d: "M41.267,18.557H26.832V4.134C26.832,1.851,24.99,0,22.707,0c-2.283,0-4.124,1.851-4.124,4.135v14.432H4.141   c-2.283,0-4.139,1.851-4.138,4.135c-0.001,1.141,0.46,2.187,1.207,2.934c0.748,0.749,1.78,1.222,2.92,1.222h14.453V41.27   c0,1.142,0.453,2.176,1.201,2.922c0.748,0.748,1.777,1.211,2.919,1.211c2.282,0,4.129-1.851,4.129-4.133V26.857h14.435   c2.283,0,4.134-1.867,4.133-4.15C45.399,20.425,43.548,18.557,41.267,18.557z"
  }
) });
var AutocompleteEmpty = forwardRef22(
  ({ className, icon, children, ...rest }, ref) => {
    const { emptyMessage, styles: styles2 } = useAutocompleteContext();
    const { getEmptyProps } = useAutocompleteEmpty();
    children != null ? children : children = emptyMessage;
    const css4 = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      pointerEvents: "none",
      ...styles2.item
    };
    return (0, import_jsx_runtime132.jsxs)(
      ui.li,
      {
        className: cx("ui-autocomplete__item--empty", className),
        __css: css4,
        ...getEmptyProps(rest, ref),
        children: [
          icon !== null ? (0, import_jsx_runtime132.jsx)(AutocompleteItemIcon, { children: icon || (0, import_jsx_runtime132.jsx)(MinusIcon, {}) }) : null,
          icon ? (0, import_jsx_runtime132.jsx)(ui.span, { style: { pointerEvents: "none", flex: 1 }, lineClamp: 1, children }) : children
        ]
      }
    );
  }
);
var MinusIcon = () => (0, import_jsx_runtime132.jsx)("svg", { viewBox: "0 0 448 512", width: "1em", height: "1em", children: (0, import_jsx_runtime132.jsx)(
  "path",
  {
    fill: "currentColor",
    d: "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"
  }
) });
var MultiAutocomplete2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle(
      "MultiAutocomplete",
      props2
    );
    let {
      className,
      defaultValue = [],
      component,
      separator,
      isClearable = true,
      color: color2,
      h,
      height,
      minH,
      minHeight,
      closeOnSelect = false,
      keepPlaceholder = false,
      containerProps,
      contentProps,
      listProps,
      fieldProps,
      inputProps,
      iconProps,
      clearIconProps,
      portalProps = { isDisabled: true },
      createProps,
      emptyProps,
      header,
      footer,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      value,
      onClose,
      descendants,
      formControlProps,
      getPopoverProps,
      getContainerProps,
      getFieldProps,
      allowCreate,
      isEmpty: isEmpty2,
      inputValue,
      computedChildren,
      onClear,
      ...rest
    } = useAutocomplete({
      ...computedProps,
      defaultValue,
      closeOnSelect,
      children
    });
    h != null ? h : h = height;
    minH != null ? minH : minH = minHeight;
    const css4 = {
      w: "100%",
      h: "fit-content",
      color: color2,
      ...styles2.container
    };
    return (0, import_jsx_runtime133.jsx)(AutocompleteDescendantsContextProvider, { value: descendants, children: (0, import_jsx_runtime133.jsx)(
      AutocompleteProvider,
      {
        value: {
          ...rest,
          value,
          onClose,
          formControlProps,
          inputValue,
          allowCreate,
          isEmpty: isEmpty2,
          styles: styles2
        },
        children: (0, import_jsx_runtime133.jsx)(Popover2, { ...getPopoverProps(), children: (0, import_jsx_runtime133.jsxs)(
          ui.div,
          {
            className: cx("ui-multi-autocomplete", className),
            __css: css4,
            ...getContainerProps(containerProps),
            children: [
              (0, import_jsx_runtime133.jsxs)(
                ui.div,
                {
                  className: "ui-multi-autocomplete__inner",
                  __css: { position: "relative", ...styles2.inner },
                  children: [
                    (0, import_jsx_runtime133.jsx)(
                      MultiAutocompleteField,
                      {
                        component,
                        separator,
                        keepPlaceholder,
                        h,
                        minH,
                        inputProps,
                        ...getFieldProps(fieldProps, ref)
                      }
                    ),
                    isClearable && value.length ? (0, import_jsx_runtime133.jsx)(
                      AutocompleteClearIcon,
                      {
                        ...clearIconProps,
                        onClick: handlerAll(clearIconProps == null ? void 0 : clearIconProps.onClick, onClear),
                        ...formControlProps
                      }
                    ) : (0, import_jsx_runtime133.jsx)(AutocompleteIcon, { ...iconProps, ...formControlProps })
                  ]
                }
              ),
              !isEmpty2 ? (0, import_jsx_runtime133.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime133.jsxs)(
                AutocompleteList,
                {
                  header: runIfFunc(header, { value, onClose }),
                  footer: runIfFunc(footer, { value, onClose }),
                  contentProps,
                  ...listProps,
                  children: [
                    allowCreate ? (0, import_jsx_runtime133.jsx)(AutocompleteCreate, { ...createProps }) : (0, import_jsx_runtime133.jsx)(AutocompleteEmpty, { ...emptyProps }),
                    children != null ? children : computedChildren
                  ]
                }
              ) }) : (0, import_jsx_runtime133.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime133.jsx)(
                AutocompleteList,
                {
                  header: runIfFunc(header, { value, onClose }),
                  footer: runIfFunc(footer, { value, onClose }),
                  contentProps,
                  ...listProps,
                  children: allowCreate && inputValue ? (0, import_jsx_runtime133.jsx)(AutocompleteCreate, { ...createProps }) : (0, import_jsx_runtime133.jsx)(AutocompleteEmpty, { ...emptyProps })
                }
              ) })
            ]
          }
        ) })
      }
    ) });
  }
);
var MultiAutocompleteField = forwardRef22(
  ({
    className,
    component,
    separator = ",",
    keepPlaceholder,
    h,
    minH,
    placeholder,
    inputProps,
    ...rest
  }, ref) => {
    const { value, label, inputValue, onChange, isOpen, inputRef, styles: styles2 } = useAutocompleteContext();
    const { getInputProps } = useAutocompleteInput();
    const cloneChildren = (0, import_react152.useMemo)(() => {
      if (!(label == null ? void 0 : label.length)) return null;
      if (component) {
        return label.map((label2, index) => {
          const onRemove = (ev) => {
            ev.stopPropagation();
            onChange(value[index]);
            if (inputRef.current) inputRef.current.focus();
          };
          const el = component({
            value: value[index],
            label: label2,
            index,
            onRemove
          });
          const style = {
            marginBlockStart: "0.125rem",
            marginBlockEnd: "0.125rem",
            marginInlineEnd: "0.25rem"
          };
          return el ? (0, import_react152.cloneElement)(el, { key: index, style }) : null;
        });
      } else {
        return label.map((value2, index) => {
          const isLast = label.length === index + 1;
          return (0, import_jsx_runtime133.jsxs)(ui.span, { display: "inline-block", me: "0.25rem", children: [
            value2,
            !isLast || isOpen ? separator : null
          ] }, index);
        });
      }
    }, [label, component, value, onChange, isOpen, inputRef, separator]);
    const css4 = {
      pe: "2rem",
      h,
      minH,
      display: "flex",
      flexWrap: "wrap",
      alignItems: "center",
      ...styles2.field,
      cursor: "text"
    };
    return (0, import_jsx_runtime133.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime133.jsxs)(
      ui.div,
      {
        className: cx("ui-multi-autocomplete__field", className),
        __css: css4,
        py: (label == null ? void 0 : label.length) && component ? "0.125rem" : void 0,
        ...rest,
        children: [
          cloneChildren,
          (0, import_jsx_runtime133.jsx)(
            ui.input,
            {
              "aria-label": "Input value",
              className: "ui-multi-autocomplete__field__input",
              display: "inline-block",
              flex: "1",
              minW: "0px",
              overflow: "hidden",
              marginBlockStart: "0.125rem",
              marginBlockEnd: "0.125rem",
              "aria-multiselectable": "true",
              placeholder: !label || !(label == null ? void 0 : label.length) || keepPlaceholder && isOpen ? placeholder : void 0,
              ...getInputProps({ ...inputProps, value: inputValue != null ? inputValue : "" }, ref)
            }
          )
        ]
      }
    ) });
  }
);
var kanaMap = {
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  "": "",
  "": "",
  : "",
  "": "",
  "": "",
  "": ""
};
var defaultFormat2 = (value) => {
  value = value.replace(
    /[-]/g,
    (v) => String.fromCharCode(v.charCodeAt(0) - 65248)
  );
  const reg = new RegExp("(" + Object.keys(kanaMap).join("|") + ")", "g");
  value = value.replace(reg, (v) => kanaMap[v]).replace(//g, "").replace(//g, "");
  value = value.toUpperCase();
  return value;
};
var flattenItems = (items) => {
  const filterItems = (items2) => items2.map((item) => {
    var _a;
    const { isDisabled: isDisabled2, isFocusable: isFocusable2 } = item;
    const trulyDisabled = !!isDisabled2 && !isFocusable2;
    if (trulyDisabled) return;
    if ("items" in item) {
      return filterItems((_a = item.items) != null ? _a : []);
    } else {
      return item;
    }
  }).filter(Boolean);
  return filterItems(items).flat(Infinity);
};
var isTargetOption2 = (target) => {
  var _a;
  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("option"));
};
var {
  DescendantsContextProvider: AutocompleteDescendantsContextProvider,
  useDescendantsContext: useAutocompleteDescendantsContext,
  useDescendants: useAutocompleteDescendants,
  useDescendant: useAutocompleteDescendant
} = createDescendant();
var [AutocompleteProvider, useAutocompleteContext] = createContext2({
  name: "AutocompleteContext",
  errorMessage: `useAutocompleteContext returned is 'undefined'. Seems you forgot to wrap the components in "<Autocomplete />" or "<MultiAutocomplete />"`
});
var useAutocomplete = ({
  value: valueProp,
  defaultValue,
  onChange: onChangeProp,
  onCreate: onCreateProp,
  onSearch: onSearchProp,
  closeOnSelect = true,
  omitSelectedValues = false,
  maxSelectValues,
  closeOnBlur = true,
  closeOnEsc = true,
  allowCreate = false,
  allowFree = false,
  insertPositionItem = "first",
  emptyMessage = "No results found",
  format = defaultFormat2,
  placement = "bottom-start",
  duration = 0.2,
  optionProps,
  placeholder,
  items,
  children,
  isOpen: isOpenProp,
  defaultIsOpen,
  onOpen: onOpenProp,
  onClose: onCloseProp,
  ...rest
}) => {
  rest = useFormControlProps(rest);
  const { id: id4 } = rest;
  const { "aria-readonly": _ariaReadonly, ...formControlProps } = pickObject(
    rest,
    formControlProperties
  );
  const [containerProps, inputProps] = splitObject(
    omitObject(rest, [...popoverProperties, "onKeyDown", "onFocus"]),
    layoutStyleProperties
  );
  const descendants = useAutocompleteDescendants();
  const containerRef = (0, import_react150.useRef)(null);
  const listRef = (0, import_react150.useRef)(null);
  const inputRef = (0, import_react150.useRef)(null);
  const timeoutIds = (0, import_react150.useRef)(/* @__PURE__ */ new Set([]));
  const isComposition = (0, import_react150.useRef)(false);
  const prevValue = (0, import_react150.useRef)(void 0);
  const [resolvedItems, setResolvedItems] = (0, import_react150.useState)(items ? JSON.parse(JSON.stringify(items)) : void 0);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const [label, setLabel] = (0, import_react150.useState)(void 0);
  const [inputValue, setInputValue] = (0, import_react150.useState)("");
  const [focusedIndex, setFocusedIndex] = (0, import_react150.useState)(-1);
  const [isAllSelected, setIsAllSelected] = (0, import_react150.useState)(false);
  const [isHit, setIsHit] = (0, import_react150.useState)(true);
  const {
    isOpen,
    onOpen: onInternalOpen,
    onClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const isFocused = focusedIndex > -1;
  const isCreate = focusedIndex === -2 && allowCreate;
  const isMulti = isArray(value);
  const isEmptyValue = !isMulti ? !value : !value.length;
  const [firstInsertPositionItem, secondInsertPositionItem] = (0, import_react150.useMemo)(() => {
    if (isArray(insertPositionItem)) {
      return insertPositionItem;
    } else {
      return [insertPositionItem, "first"];
    }
  }, [insertPositionItem]);
  if (allowCreate && !isUndefined(children)) {
    console.warn(
      `${!isMulti ? "Autocomplete" : "MultiAutocomplete"}: ${!isMulti ? "Autocomplete" : "MultiAutocomplete"} internally prefers 'children'. If 'allowCreate' is true, it will not be reflected correctly. If want to reflect, please set 'items' in props.`
    );
  }
  const selectedValues = descendants.enabledValues(
    ({ node: node3 }) => {
      var _a;
      return isMulti && value.includes((_a = node3.dataset.value) != null ? _a : "");
    }
  );
  const selectedIndexes = selectedValues.map(({ index }) => index);
  const enabledValues = descendants.enabledValues(
    ({ node: node3, index }) => "target" in node3.dataset && !selectedIndexes.includes(index)
  );
  const validChildren = getValidChildren(children);
  const computedChildren = (0, import_react150.useMemo)(
    () => resolvedItems == null ? void 0 : resolvedItems.map((item, i) => {
      if ("value" in item) {
        const { label: label2, value: value2, ...props2 } = item;
        return (0, import_jsx_runtime134.jsx)(AutocompleteOption, { value: value2, ...props2, children: label2 }, i);
      } else if ("items" in item) {
        const { label: label2, items: items2 = [], ...props2 } = item;
        return (0, import_jsx_runtime134.jsx)(
          AutocompleteOptionGroup,
          {
            label: label2,
            ...props2,
            children: items2.map(({ label: label3, value: value2, ...props22 }, i2) => (0, import_jsx_runtime134.jsx)(AutocompleteOption, { value: value2, ...props22, children: label3 }, i2))
          },
          i
        );
      }
    }),
    [resolvedItems]
  );
  const isEmpty2 = !validChildren.length && !(computedChildren == null ? void 0 : computedChildren.length);
  const onOpen = (0, import_react150.useCallback)(() => {
    if (formControlProps.disabled || formControlProps.readOnly) return;
    if (!allowCreate && (isEmpty2 || isAllSelected)) return;
    onInternalOpen();
    if (inputRef.current) inputRef.current.focus();
  }, [allowCreate, formControlProps, isAllSelected, isEmpty2, onInternalOpen]);
  const onFocusFirst = (0, import_react150.useCallback)(() => {
    const id22 = setTimeout(() => {
      if (isEmpty2 || isAllSelected) return;
      const first = descendants.enabledFirstValue(
        ({ node: node3 }) => "target" in node3.dataset
      );
      if (!first) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(first.index);
      } else {
        if (selectedIndexes.includes(first.index)) {
          const enabledFirst = enabledValues[0];
          setFocusedIndex(enabledFirst.index);
        } else {
          setFocusedIndex(first.index);
        }
      }
    });
    timeoutIds.current.add(id22);
  }, [
    descendants,
    enabledValues,
    isAllSelected,
    isEmpty2,
    isMulti,
    omitSelectedValues,
    selectedIndexes
  ]);
  const onFocusLast = (0, import_react150.useCallback)(() => {
    const id22 = setTimeout(() => {
      if (isEmpty2 || isAllSelected) return;
      const last = descendants.enabledLastValue(
        ({ node: node3 }) => "target" in node3.dataset
      );
      if (!last) return;
      if (!isMulti || !omitSelectedValues) {
        setFocusedIndex(last.index);
      } else {
        if (selectedIndexes.includes(last.index)) {
          const enabledLast = enabledValues.reverse()[0];
          setFocusedIndex(enabledLast.index);
        } else {
          setFocusedIndex(last.index);
        }
      }
    });
    timeoutIds.current.add(id22);
  }, [
    descendants,
    enabledValues,
    isAllSelected,
    isEmpty2,
    isMulti,
    omitSelectedValues,
    selectedIndexes
  ]);
  const onFocusSelected = (0, import_react150.useCallback)(() => {
    const id22 = setTimeout(() => {
      const values = descendants.enabledValues();
      const selected = values.find(
        ({ node: node3 }) => {
          var _a;
          return !isMulti ? node3.dataset.value === value : value.includes((_a = node3.dataset.value) != null ? _a : "");
        }
      );
      if (selected) setFocusedIndex(selected.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants, isMulti, value]);
  const onFocusNext = (0, import_react150.useCallback)(
    (index = focusedIndex) => {
      const id22 = setTimeout(() => {
        var _a;
        const next2 = descendants.enabledNextValue(
          index,
          ({ node: node3 }) => "target" in node3.dataset
        );
        if (!next2) return;
        if (!isMulti || !omitSelectedValues) {
          setFocusedIndex(next2.index);
        } else {
          if (selectedIndexes.includes(next2.index)) {
            const enabledNext = (_a = enabledValues.find(({ index: index2 }) => next2.index < index2)) != null ? _a : enabledValues[0];
            setFocusedIndex(enabledNext.index);
          } else {
            setFocusedIndex(next2.index);
          }
        }
      });
      timeoutIds.current.add(id22);
    },
    [
      descendants,
      enabledValues,
      focusedIndex,
      isMulti,
      omitSelectedValues,
      selectedIndexes
    ]
  );
  const onFocusPrev = (0, import_react150.useCallback)(
    (index = focusedIndex) => {
      const id22 = setTimeout(() => {
        var _a;
        const prev2 = descendants.enabledPrevValue(
          index,
          ({ node: node3 }) => "target" in node3.dataset
        );
        if (!prev2) return;
        if (!isMulti || !omitSelectedValues) {
          setFocusedIndex(prev2.index);
        } else {
          if (selectedIndexes.includes(prev2.index)) {
            const enabledPrev = (_a = enabledValues.reverse().find(({ index: index2 }) => index2 < prev2.index)) != null ? _a : enabledValues[0];
            setFocusedIndex(enabledPrev.index);
          } else {
            setFocusedIndex(prev2.index);
          }
        }
      });
      timeoutIds.current.add(id22);
    },
    [
      descendants,
      enabledValues,
      focusedIndex,
      isMulti,
      omitSelectedValues,
      selectedIndexes
    ]
  );
  const onFocusFirstOrSelected = isEmptyValue || omitSelectedValues ? onFocusFirst : onFocusSelected;
  const onFocusLastOrSelected = isEmptyValue || omitSelectedValues ? onFocusLast : onFocusSelected;
  const pickOptions = (0, import_react150.useCallback)(
    (value2) => {
      const values = descendants.values();
      let isHit2 = false;
      let isFocused2 = false;
      values.forEach(({ node: node3, index }) => {
        var _a;
        if (format((_a = node3.textContent) != null ? _a : "").includes(value2)) {
          isHit2 = true;
          const isDisabled2 = "disabled" in node3.dataset;
          node3.dataset.target = "";
          if (!isFocused2 && !isDisabled2) {
            isFocused2 = true;
            setFocusedIndex(index);
          }
        } else {
          delete node3.dataset.target;
        }
      });
      setIsHit(isHit2);
    },
    [descendants, format]
  );
  const rebirthOptions = (0, import_react150.useCallback)(
    (runFocus = true) => {
      const values = descendants.values();
      values.forEach(({ node: node3 }) => {
        node3.dataset.target = "";
      });
      if (runFocus) onFocusFirst();
      setIsHit(true);
    },
    [descendants, onFocusFirst]
  );
  const getSelectedValues = (0, import_react150.useCallback)(
    (newValues) => {
      const enabledValues2 = descendants.enabledValues();
      const resolvedValues = isArray(newValues) ? newValues : [newValues];
      const selectedValues2 = resolvedValues.map((value2) => {
        var _a, _b;
        const { node: node3 } = (_a = enabledValues2.find(({ node: node22 }) => node22.dataset.value === value2)) != null ? _a : {};
        if (node3) {
          const el = Array.from(node3.children).find(
            (child) => child.getAttribute("data-label") !== null
          );
          return (_b = el == null ? void 0 : el.textContent) != null ? _b : void 0;
        } else {
          return allowFree ? value2 : void 0;
        }
      }).filter(Boolean);
      return selectedValues2;
    },
    [allowFree, descendants]
  );
  const onChangeLabel = (0, import_react150.useCallback)(
    (newValue, { forceUpdate, runOmit = true } = {}) => {
      const selectedValues2 = getSelectedValues(newValue);
      if (!forceUpdate && !selectedValues2.length) return;
      setLabel((prev2) => {
        if (!isMulti) {
          return selectedValues2[0];
        } else {
          selectedValues2.forEach((selectedValue) => {
            const isSelected = isArray(prev2) && prev2.includes(selectedValue != null ? selectedValue : "");
            if (!isSelected) {
              prev2 = [...isArray(prev2) ? prev2 : [], selectedValue];
            } else if (runOmit) {
              prev2 = isArray(prev2) ? prev2.filter((value2) => value2 !== selectedValue) : void 0;
            }
          });
          return prev2;
        }
      });
    },
    [getSelectedValues, isMulti]
  );
  const onChange = (0, import_react150.useCallback)(
    (newValue, { forceUpdate, runRebirth = true } = {}) => {
      setValue((prev2) => {
        let next2;
        if (!isArray(prev2)) {
          next2 = newValue;
        } else {
          const isSelected = prev2.includes(newValue);
          if (!isSelected) {
            next2 = [...prev2, newValue];
          } else {
            next2 = prev2.filter((value2) => value2 !== newValue);
          }
        }
        prevValue.current = next2;
        return next2;
      });
      const isHit2 = descendants.values().filter(
        ({ node: node3 }) => {
          var _a;
          return format((_a = node3.textContent) != null ? _a : "").includes(newValue);
        }
      ).length > 0;
      onChangeLabel(newValue, { forceUpdate });
      if (allowFree || isHit2) setInputValue("");
      if (isMulti && runRebirth) rebirthOptions(false);
    },
    [
      allowFree,
      isMulti,
      onChangeLabel,
      rebirthOptions,
      setValue,
      descendants,
      format
    ]
  );
  const onSelect = (0, import_react150.useCallback)(() => {
    var _a, _b;
    let enabledValue = descendants.value(focusedIndex);
    if ("disabled" in ((_a = enabledValue == null ? void 0 : enabledValue.node.dataset) != null ? _a : {}))
      enabledValue = void 0;
    if (!enabledValue) return;
    const value2 = (_b = enabledValue.node.dataset.value) != null ? _b : "";
    onChange(value2);
    if (closeOnSelect) onClose();
    if (omitSelectedValues) onFocusNext();
  }, [
    closeOnSelect,
    descendants,
    focusedIndex,
    omitSelectedValues,
    onChange,
    onClose,
    onFocusNext
  ]);
  const onSearch = (0, import_react150.useCallback)(
    (ev) => {
      if (!isOpen) onOpen();
      onSearchProp == null ? void 0 : onSearchProp(ev);
      const value2 = ev.target.value;
      const computedValue = format(value2);
      if (computedValue) {
        pickOptions(computedValue);
      } else {
        rebirthOptions();
      }
      setInputValue(value2);
    },
    [isOpen, onOpen, format, onSearchProp, pickOptions, rebirthOptions]
  );
  const onCompositionStart = (0, import_react150.useCallback)(() => {
    isComposition.current = true;
  }, []);
  const onCompositionEnd = (0, import_react150.useCallback)(() => {
    isComposition.current = false;
  }, []);
  const onCreate = (0, import_react150.useCallback)(() => {
    var _a, _b;
    if (!listRef.current) return;
    const newItem = { label: inputValue, value: inputValue };
    let newItems = [];
    if (resolvedItems) newItems = [...resolvedItems];
    if (firstInsertPositionItem === "first") {
      newItems = [newItem, ...newItems];
    } else if (firstInsertPositionItem === "last") {
      newItems = [...newItems, newItem];
    } else {
      const i = newItems.findIndex(
        ({ label: label2 }) => label2 === firstInsertPositionItem
      );
      const targetItem = newItems[i];
      if (i !== -1 && "items" in targetItem) {
        if (secondInsertPositionItem === "first") {
          targetItem.items = [newItem, ...(_a = targetItem.items) != null ? _a : []];
        } else {
          targetItem.items = [...(_b = targetItem.items) != null ? _b : [], newItem];
        }
        newItems[i] = targetItem;
      } else {
        console.warn(
          `${!isMulti ? "Autocomplete" : "MultiAutocomplete"}: '${firstInsertPositionItem}' specified in insertPositionItem does not exist in the option group.`
        );
      }
    }
    setResolvedItems(newItems);
    onChange(inputValue);
    rebirthOptions(false);
    const index = flattenItems(newItems).findIndex(
      ({ value: value2 }) => value2 === inputValue
    );
    setFocusedIndex(index);
    onCreateProp == null ? void 0 : onCreateProp(newItem, newItems);
  }, [
    inputValue,
    resolvedItems,
    firstInsertPositionItem,
    onChange,
    rebirthOptions,
    onCreateProp,
    secondInsertPositionItem,
    isMulti
  ]);
  const onClick2 = (0, import_react150.useCallback)(() => {
    if (isOpen) {
      if (inputRef.current) inputRef.current.focus();
    } else {
      onOpen();
      onFocusFirstOrSelected();
    }
  }, [isOpen, onFocusFirstOrSelected, onOpen]);
  const onFocus4 = (0, import_react150.useCallback)(() => {
    if (isOpen) return;
    onOpen();
    onFocusFirstOrSelected();
  }, [isOpen, onFocusFirstOrSelected, onOpen]);
  const onBlur4 = (0, import_react150.useCallback)(
    (ev) => {
      const relatedTarget = getEventRelatedTarget(ev);
      if (isContains(containerRef.current, relatedTarget)) return;
      if (!closeOnBlur && isHit) return;
      if (allowFree && !!inputValue) onChange(inputValue, { runRebirth: false });
      setInputValue("");
      if (isOpen) onClose();
    },
    [closeOnBlur, isHit, isOpen, inputValue, allowFree, onClose, onChange]
  );
  const onDelete = (0, import_react150.useCallback)(() => {
    if (!isMulti) {
      onChange("", { forceUpdate: true });
    } else {
      onChange(value[value.length - 1]);
    }
    if (!isOpen) onFocus4();
  }, [isMulti, isOpen, onChange, onFocus4, value]);
  const onClear = (0, import_react150.useCallback)(
    (ev) => {
      ev.stopPropagation();
      prevValue.current = [];
      setValue([]);
      setLabel(void 0);
      setInputValue("");
      rebirthOptions();
      if (isOpen && inputRef.current) inputRef.current.focus();
    },
    [isOpen, setLabel, setInputValue, setValue, rebirthOptions]
  );
  const onKeyDown = (0, import_react150.useCallback)(
    (ev) => {
      if (ev.key === " ") ev.key = ev.code;
      if (formControlProps.disabled || formControlProps.readOnly) return;
      if (isComposition.current) return;
      const enabledDelete = label === inputValue || !inputValue.length;
      const actions = {
        ArrowDown: isFocused ? () => onFocusNext() : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : void 0,
        ArrowUp: isFocused ? () => onFocusPrev() : !isOpen ? funcAll(onOpen, onFocusLastOrSelected) : void 0,
        Space: isCreate ? onCreate : isFocused ? onSelect : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : void 0,
        Enter: isCreate ? onCreate : isFocused ? onSelect : !isOpen ? funcAll(onOpen, onFocusFirstOrSelected) : allowFree && isMulti ? () => {
          if (inputValue) onChange(inputValue);
          setFocusedIndex(0);
        } : void 0,
        Home: isOpen ? onFocusFirst : void 0,
        End: isOpen ? onFocusLast : void 0,
        Escape: closeOnEsc ? onClose : void 0,
        Backspace: !isEmptyValue && enabledDelete ? onDelete : void 0
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action(ev);
    },
    [
      allowFree,
      formControlProps,
      label,
      inputValue,
      onOpen,
      isFocused,
      isMulti,
      onFocusFirstOrSelected,
      onFocusNext,
      onFocusLastOrSelected,
      onFocusPrev,
      isCreate,
      onCreate,
      onSelect,
      isOpen,
      onFocusFirst,
      onFocusLast,
      closeOnEsc,
      onClose,
      isEmptyValue,
      onDelete,
      onChange
    ]
  );
  (0, import_react150.useEffect)(() => {
    if (!isMulti) return;
    if (!omitSelectedValues && isUndefined(maxSelectValues)) return;
    const isAll = value.length > 0 && value.length === descendants.count();
    const isMax = value.length === maxSelectValues;
    if (isAll || isMax) {
      onClose();
      setIsAllSelected(true);
    } else {
      setIsAllSelected(false);
    }
  }, [
    omitSelectedValues,
    value,
    descendants,
    isMulti,
    onClose,
    maxSelectValues
  ]);
  (0, import_react150.useEffect)(() => {
    var _a;
    if (isMulti) {
      if (JSON.stringify((_a = prevValue.current) != null ? _a : []) === JSON.stringify(value != null ? value : []))
        return;
      const label2 = getSelectedValues(value);
      setLabel(label2);
    } else {
      if (prevValue.current === value) return;
      onChangeLabel(value, { runOmit: false });
    }
  }, [isMulti, value, onChangeLabel, getSelectedValues]);
  useUpdateEffect(() => {
    if (isOpen || allowFree) return;
    setFocusedIndex(-1);
    setInputValue("");
  }, [isOpen]);
  useUpdateEffect(() => {
    if (!isHit) setFocusedIndex(-2);
  }, [isHit]);
  useUpdateEffect(() => {
    setResolvedItems(items ? JSON.parse(JSON.stringify(items)) : void 0);
  }, [items]);
  useUnmountEffect(() => {
    timeoutIds.current.forEach((id22) => clearTimeout(id22));
    timeoutIds.current.clear();
  });
  useOutsideClick({
    ref: containerRef,
    handler: onClose,
    enabled: isOpen && (closeOnBlur || !isHit)
  });
  const getPopoverProps = (0, import_react150.useCallback)(
    (props2) => ({
      matchWidth: true,
      ...rest,
      ...props2,
      isOpen,
      onOpen,
      onClose,
      placement,
      duration,
      trigger: "never",
      closeOnButton: false,
      closeOnBlur
    }),
    [duration, closeOnBlur, isOpen, onClose, onOpen, placement, rest]
  );
  const getContainerProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => ({
      ref: mergeRefs(containerRef, ref),
      ...containerProps,
      ...props2,
      ...formControlProps,
      onClick: handlerAll(props2.onClick, rest.onClick, onClick2),
      onBlur: handlerAll(props2.onBlur, rest.onBlur, onBlur4)
    }),
    [containerProps, formControlProps, onBlur4, onClick2, rest]
  );
  const getFieldProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => ({
      ref,
      tabIndex: -1,
      ...props2,
      ...formControlProps,
      placeholder,
      "data-active": dataAttr(isOpen),
      "aria-expanded": dataAttr(isOpen),
      onFocus: handlerAll(props2.onFocus, rest.onFocus, onFocus4),
      onKeyDown: handlerAll(props2.onKeyDown, rest.onKeyDown, onKeyDown)
    }),
    [formControlProps, placeholder, isOpen, rest, onFocus4, onKeyDown]
  );
  return {
    id: id4,
    descendants,
    value,
    label,
    inputValue,
    isHit,
    isEmpty: isEmpty2,
    computedChildren,
    focusedIndex,
    omitSelectedValues,
    closeOnSelect,
    allowCreate,
    allowFree,
    emptyMessage,
    isOpen,
    isAllSelected,
    listRef,
    inputRef,
    optionProps,
    formControlProps,
    setFocusedIndex,
    onChangeLabel,
    onChange,
    onSearch,
    onCreate,
    onClear,
    onCompositionStart,
    onCompositionEnd,
    pickOptions,
    rebirthOptions,
    onOpen,
    onClose,
    onFocusFirst,
    onFocusLast,
    onFocusSelected,
    onFocusNext,
    onFocusPrev,
    getPopoverProps,
    getContainerProps,
    getFieldProps,
    inputProps
  };
};
var useAutocompleteInput = () => {
  const {
    id: id4,
    inputRef,
    onSearch,
    onCompositionStart,
    onCompositionEnd,
    isAllSelected,
    formControlProps,
    inputProps,
    isOpen,
    focusedIndex,
    listRef
  } = useAutocompleteContext();
  const { value } = useAutocompleteDescendantsContext();
  useUpdateEffect(() => {
    if (isAllSelected && inputRef.current) inputRef.current.blur();
  }, [isAllSelected]);
  const getInputProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => {
      var _a, _b;
      return {
        ref: mergeRefs(inputRef, ref),
        ...formControlProps,
        role: "combobox",
        "aria-haspopup": "listbox",
        "aria-autocomplete": "list",
        "aria-expanded": isOpen,
        "aria-activedescendant": (_a = value(focusedIndex)) == null ? void 0 : _a.node.id,
        "aria-controls": (_b = listRef.current) == null ? void 0 : _b.id,
        autoCapitalize: "none",
        autoComplete: "off",
        spellCheck: "false",
        ...inputProps,
        ...props2,
        id: id4,
        cursor: formControlProps.readOnly ? "default" : "text",
        pointerEvents: formControlProps.disabled || isAllSelected ? "none" : "auto",
        tabIndex: isAllSelected ? -1 : 0,
        onChange: handlerAll(props2.onChange, onSearch),
        onCompositionStart: handlerAll(
          props2.onCompositionStart,
          inputProps.onCompositionStart,
          onCompositionStart
        ),
        onCompositionEnd: handlerAll(
          props2.onCompositionEnd,
          inputProps.onCompositionEnd,
          onCompositionEnd
        )
      };
    },
    [
      listRef,
      focusedIndex,
      isOpen,
      inputProps,
      inputRef,
      formControlProps,
      id4,
      isAllSelected,
      value,
      onSearch,
      onCompositionStart,
      onCompositionEnd
    ]
  );
  return {
    getInputProps
  };
};
var useAutocompleteList = () => {
  const { focusedIndex, isOpen, listRef, rebirthOptions } = useAutocompleteContext();
  const descendants = useAutocompleteDescendantsContext();
  const beforeFocusedIndex = (0, import_react150.useRef)(-1);
  const selectedValue = descendants.value(focusedIndex);
  const onAnimationComplete = (0, import_react150.useCallback)(() => {
    if (!isOpen) rebirthOptions(false);
  }, [isOpen, rebirthOptions]);
  (0, import_react150.useEffect)(() => {
    if (!listRef.current || !selectedValue) return;
    if (beforeFocusedIndex.current === selectedValue.index) return;
    const parent = listRef.current;
    const child = selectedValue.node;
    const parentHeight = parent.clientHeight;
    const viewTop = parent.scrollTop;
    const viewBottom = viewTop + parentHeight;
    const childHeight = child.clientHeight;
    const childTop = child.offsetTop;
    const childBottom = childTop + childHeight;
    const isInView = viewTop <= childTop && childBottom <= viewBottom;
    const isScrollBottom = beforeFocusedIndex.current < selectedValue.index;
    if (!isInView) {
      if (childBottom <= parentHeight) {
        listRef.current.scrollTo({ top: 0 });
      } else {
        if (!isScrollBottom) {
          listRef.current.scrollTo({ top: childTop + 1 });
        } else {
          listRef.current.scrollTo({ top: childBottom - parentHeight });
        }
      }
    }
    beforeFocusedIndex.current = selectedValue.index;
  }, [listRef, selectedValue]);
  useUpdateEffect(() => {
    if (!isOpen) beforeFocusedIndex.current = -1;
  }, [isOpen]);
  const getListProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => ({
      as: "ul",
      ref: mergeRefs(listRef, ref),
      role: "listbox",
      tabIndex: -1,
      position: "relative",
      id: props2.id || (0, import_react150.useId)(),
      ...props2
    }),
    [listRef]
  );
  return {
    onAnimationComplete,
    getListProps
  };
};
var useAutocompleteOptionGroup = ({
  label,
  ...rest
}) => {
  const { value, omitSelectedValues } = useAutocompleteContext();
  const isMulti = isArray(value);
  const descendants = useAutocompleteDescendantsContext();
  const values = descendants.values();
  const selectedValues = isMulti && omitSelectedValues ? descendants.values(
    ({ node: node3 }) => {
      var _a;
      return value.includes((_a = node3.dataset.value) != null ? _a : "");
    }
  ) : [];
  const selectedIndexes = selectedValues.map(({ index }) => index);
  const childValues = values.filter(
    ({ node: node3, index }) => {
      var _a;
      return ((_a = node3.parentElement) == null ? void 0 : _a.dataset.label) === label && !selectedIndexes.includes(index) && "target" in node3.dataset;
    }
  );
  const isEmpty2 = !childValues.length;
  const computedRest = splitObject(rest, layoutStyleProperties);
  const getContainerProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref,
        ...props2,
        ...computedRest[0],
        style: isEmpty2 ? style : void 0,
        "data-label": label,
        role: "autocomplete-group-container"
      };
    },
    [computedRest, isEmpty2, label]
  );
  const getGroupProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => ({
      ref,
      ...props2,
      ...computedRest[1],
      "data-label": label,
      role: "autocomplete-group"
    }),
    [computedRest, label]
  );
  return {
    label,
    getContainerProps,
    getGroupProps
  };
};
var useAutocompleteOption = (props2) => {
  var _a, _b;
  const {
    value,
    omitSelectedValues,
    onChange,
    onChangeLabel,
    focusedIndex,
    setFocusedIndex,
    onClose,
    closeOnSelect: generalCloseOnSelect,
    optionProps,
    inputRef,
    onFocusNext
  } = useAutocompleteContext();
  let {
    icon: customIcon,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect: customCloseOnSelect,
    children,
    value: optionValue,
    ...computedProps
  } = { ...optionProps, ...props2 };
  const trulyDisabled = !!isDisabled2 && !isFocusable2;
  const itemRef = (0, import_react150.useRef)(null);
  const { index, register, descendants } = useAutocompleteDescendant({
    disabled: trulyDisabled
  });
  const values = descendants.values();
  const frontValues = values.slice(0, index);
  const isMulti = isArray(value);
  const isDuplicated = !isMulti ? frontValues.some(({ node: node3 }) => node3.dataset.value === (optionValue != null ? optionValue : "")) : false;
  const isSelected = !isDuplicated && (!isMulti ? (optionValue != null ? optionValue : "") === value : value.includes(optionValue != null ? optionValue : ""));
  const isTarget = "target" in ((_b = (_a = itemRef.current) == null ? void 0 : _a.dataset) != null ? _b : {});
  const isFocused = index === focusedIndex;
  const onClick2 = (0, import_react150.useCallback)(
    (ev) => {
      ev.stopPropagation();
      if (isDisabled2) {
        if (inputRef.current) inputRef.current.focus();
        return;
      }
      if (!isTargetOption2(ev.currentTarget)) {
        if (inputRef.current) inputRef.current.focus();
        return;
      }
      setFocusedIndex(index);
      onChange(optionValue != null ? optionValue : "");
      if (inputRef.current) inputRef.current.focus();
      if (customCloseOnSelect != null ? customCloseOnSelect : generalCloseOnSelect) onClose();
      if (omitSelectedValues) onFocusNext(index);
    },
    [
      onFocusNext,
      omitSelectedValues,
      isDisabled2,
      optionValue,
      setFocusedIndex,
      index,
      onChange,
      customCloseOnSelect,
      generalCloseOnSelect,
      onClose,
      inputRef
    ]
  );
  useUpdateEffect(() => {
    if (isSelected) onChangeLabel(optionValue != null ? optionValue : "", { runOmit: false });
  }, [optionValue]);
  const getOptionProps = (0, import_react150.useCallback)(
    (props22 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref: mergeRefs(itemRef, ref, register),
        id: (0, import_react150.useId)(),
        role: "option",
        ...computedProps,
        ...props22,
        tabIndex: -1,
        style: !isTarget || omitSelectedValues && isSelected ? style : void 0,
        "data-target": dataAttr(true),
        "data-value": optionValue != null ? optionValue : "",
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled2),
        "aria-checked": isSelected,
        "aria-disabled": ariaAttr(isDisabled2),
        onClick: handlerAll(computedProps.onClick, props22.onClick, onClick2)
      };
    },
    [
      optionValue,
      computedProps,
      isDisabled2,
      isFocused,
      isSelected,
      isTarget,
      omitSelectedValues,
      onClick2,
      register
    ]
  );
  return {
    isSelected,
    isFocused,
    customIcon,
    children,
    getOptionProps
  };
};
var useAutocompleteCreate = () => {
  const { isHit, onCreate } = useAutocompleteContext();
  const getCreateProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref,
        ...props2,
        tabIndex: -1,
        style: isHit ? style : void 0,
        "data-focus": dataAttr(!isHit),
        onClick: handlerAll(props2.onClick, onCreate)
      };
    },
    [isHit, onCreate]
  );
  return { getCreateProps };
};
var useAutocompleteEmpty = () => {
  const { isHit, isEmpty: isEmpty2 } = useAutocompleteContext();
  const getEmptyProps = (0, import_react150.useCallback)(
    (props2 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref,
        ...props2,
        tabIndex: -1,
        style: isHit && !isEmpty2 ? style : void 0
      };
    },
    [isHit, isEmpty2]
  );
  return { getEmptyProps };
};
var AutocompleteList = forwardRef22(
  ({
    className,
    w,
    width,
    minW,
    minWidth,
    contentProps,
    header,
    footer,
    children,
    ...rest
  }, ref) => {
    var _a, _b, _c, _d, _e, _f;
    const { styles: styles2 } = useAutocompleteContext();
    const { onAnimationComplete, getListProps } = useAutocompleteList();
    width != null ? width : width = w;
    width != null ? width : width = (_c = (_a = styles2.list) == null ? void 0 : _a.width) != null ? _c : (_b = styles2.list) == null ? void 0 : _b.w;
    minWidth != null ? minWidth : minWidth = minW;
    minWidth != null ? minWidth : minWidth = (_f = (_d = styles2.list) == null ? void 0 : _d.minWidth) != null ? _f : (_e = styles2.list) == null ? void 0 : _e.minW;
    return (0, import_jsx_runtime135.jsxs)(
      PopoverContent,
      {
        as: "div",
        className: "ui-autocomplete__popover",
        width,
        minWidth,
        __css: { ...styles2.content, width, minWidth },
        ...contentProps,
        onAnimationComplete: handlerAll(
          contentProps == null ? void 0 : contentProps.onAnimationComplete,
          onAnimationComplete
        ),
        children: [
          header ? (0, import_jsx_runtime135.jsx)(
            ui.div,
            {
              className: "ui-autocomplete__header",
              __css: { ...styles2.header },
              children: header
            }
          ) : null,
          (0, import_jsx_runtime135.jsx)(
            ui.ul,
            {
              className: cx("ui-autocomplete__list", className),
              __css: { ...styles2.list },
              ...getListProps(rest, ref),
              children
            }
          ),
          footer ? (0, import_jsx_runtime135.jsx)(
            ui.div,
            {
              className: "ui-autocomplete__footer",
              __css: { ...styles2.footer },
              children: footer
            }
          ) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/avatar/dist/chunk-RYWCAIUH.mjs
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var AvatarIcon = (props2) => (0, import_jsx_runtime136.jsxs)(
  Icon,
  {
    viewBox: "0 0 128 128",
    color: ["white", "black"],
    width: "100%",
    height: "100%",
    className: "ui-avatar__icon",
    ...props2,
    children: [
      (0, import_jsx_runtime136.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
        }
      ),
      (0, import_jsx_runtime136.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
        }
      )
    ]
  }
);

// node_modules/@yamada-ui/avatar/dist/chunk-F7MHUXUL.mjs
var import_react153 = __toESM(require_react(), 1);
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var [AvatarProvider, useAvatarContext] = createContext2({
  strict: false,
  name: "AvatarContext"
});
var Avatar2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Avatar", props2);
  const {
    className,
    src,
    srcSet,
    name,
    loading,
    alt,
    icon,
    ignoreFallback,
    referrerPolicy,
    borderRadius = "fallback(full, 9999px)",
    rounded = "fallback(full, 9999px)",
    onError,
    onLoad,
    crossOrigin,
    format,
    children,
    ...rest
  } = omitThemeProps(mergedProps);
  const [isLoaded, setIsLoaded] = (0, import_react153.useState)(false);
  const css4 = {
    position: "relative",
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    flexShrink: 0,
    textAlign: "center",
    textTransform: "uppercase",
    fontWeight: "medium",
    ...styles2.container
  };
  return (0, import_jsx_runtime137.jsx)(AvatarProvider, { value: styles2, children: (0, import_jsx_runtime137.jsxs)(
    ui.span,
    {
      ref,
      className: cx("ui-avatar", className),
      "data-loaded": dataAttr(isLoaded),
      borderRadius,
      rounded,
      __css: css4,
      ...rest,
      children: [
        (0, import_jsx_runtime137.jsx)(
          AvatarImage,
          {
            src,
            alt,
            srcSet,
            loading,
            borderRadius,
            rounded,
            onLoad: handlerAll(onLoad, () => setIsLoaded(true)),
            onError,
            crossOrigin,
            format,
            name,
            icon,
            ignoreFallback,
            referrerPolicy
          }
        ),
        children
      ]
    }
  ) });
});
var AvatarImage = ({
  src,
  alt,
  srcSet,
  onError,
  onLoad,
  format,
  borderRadius,
  rounded,
  name,
  loading,
  icon = (0, import_jsx_runtime137.jsx)(AvatarIcon, {}),
  ignoreFallback,
  crossOrigin,
  referrerPolicy
}) => {
  const status = useImage({ src, onLoad, onError, crossOrigin, ignoreFallback });
  const isLoaded = status === "loaded";
  const isFallback = !src || !isLoaded;
  if (isFallback)
    return name ? (0, import_jsx_runtime137.jsx)(AvatarName, { name, format }) : (0, import_react153.cloneElement)(icon, { role: "img", "aria-label": alt != null ? alt : "Avatar Icon" });
  const css4 = {
    width: "100%",
    height: "100%",
    objectFit: "cover"
  };
  return (0, import_jsx_runtime137.jsx)(
    ui.img,
    {
      className: "ui-avatar__image",
      src,
      srcSet,
      alt: alt != null ? alt : name,
      loading,
      referrerPolicy,
      borderRadius,
      rounded,
      __css: css4
    }
  );
};
var defaultFormat3 = (name) => {
  var _a;
  const names = name.trim().split(" ");
  const firstName = (_a = names[0]) != null ? _a : "";
  const lastName = names.length > 1 ? names[names.length - 1] : "";
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
};
var AvatarName = ({
  name,
  format = defaultFormat3,
  ...rest
}) => {
  const styles2 = useAvatarContext();
  const css4 = { ...styles2.name };
  return (0, import_jsx_runtime138.jsx)(
    ui.div,
    {
      className: "ui-avatar__name",
      role: "img",
      "aria-label": name,
      __css: css4,
      ...rest,
      children: name ? format(name) : null
    }
  );
};

// node_modules/@yamada-ui/avatar/dist/chunk-Y3MK4PTJ.mjs
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var placementStyles = {
  "top-start": {
    top: "0",
    insetStart: "0",
    transform: "translate(-25%, -25%)"
  },
  "top-end": {
    top: "0",
    insetEnd: "0",
    transform: "translate(25%, -25%)"
  },
  "bottom-start": {
    bottom: "0",
    insetStart: "0",
    transform: "translate(-25%, 25%)"
  },
  "bottom-end": {
    bottom: "0",
    insetEnd: "0",
    transform: "translate(25%, 25%)"
  }
};
var AvatarBadge = forwardRef22(
  ({
    className,
    boxSize = "1em",
    placement = "bottom-end",
    ping,
    pingColor = ["blackAlpha.400", "whiteAlpha.500"],
    pingDuration = "1.4s",
    pingCount = "infinite",
    pingScale = 1.8,
    children,
    ...rest
  }, ref) => {
    const styles2 = useAvatarContext();
    const animation2 = useAnimation2({
      keyframes: {
        "75%, 100%": {
          transform: `scale(${pingScale})`,
          opacity: 0
        }
      },
      fillMode: "forwards",
      duration: pingDuration,
      timingFunction: "cubic-bezier(0, 0, 0.2, 1)",
      iterationCount: pingCount
    });
    const css4 = {
      position: "absolute",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      ...placementStyles[placement],
      ...styles2.badge
    };
    return (0, import_jsx_runtime139.jsxs)(
      ui.div,
      {
        ref,
        className: cx("ui-avatar__badge", className),
        boxSize,
        __css: css4,
        ...rest,
        children: [
          children,
          ping ? (0, import_jsx_runtime139.jsx)(
            ui.div,
            {
              className: "ui-avatar__badge__ping",
              __css: {
                position: "absolute",
                boxSize: "100%",
                rounded: "fallback(full, 9999px)",
                opacity: 0.75,
                zIndex: -1,
                bg: pingColor
              },
              animation: animation2
            }
          ) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/avatar/dist/chunk-MJEARQCG.mjs
var import_react154 = __toESM(require_react(), 1);
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var AvatarGroup = forwardRef22((props2, ref) => {
  const [styles2] = useMultiComponentStyle("Avatar", props2);
  const {
    className,
    max: max2,
    borderColor,
    gap = "fallback(-2, -0.5rem)",
    borderRadius = "fallback(full, 9999px)",
    rounded = "fallback(full, 9999px)",
    children,
    ...rest
  } = omitThemeProps(props2);
  let validChildren = getValidChildren(children);
  const excess = !isUndefined(max2) ? validChildren.length - max2 : 0;
  validChildren = !isUndefined(max2) ? validChildren.slice(0, max2) : validChildren;
  validChildren = validChildren.reverse();
  const cloneChildren = validChildren.map(
    (child, i) => {
      var _a;
      return (0, import_react154.cloneElement)(
        child,
        filterUndefined({
          marginEnd: !i ? 0 : gap,
          size: props2.size,
          borderColor: (_a = child.props.borderColor) != null ? _a : borderColor,
          borderWidth: "2px"
        })
      );
    }
  );
  return (0, import_jsx_runtime140.jsxs)(
    ui.div,
    {
      ref,
      role: "group",
      className: cx("ui-avatar-group", className),
      __css: {
        display: "flex",
        flexDirection: "row-reverse",
        justifyContent: "flex-end",
        alignItems: "center",
        ...styles2.group
      },
      ...rest,
      children: [
        excess > 0 ? (0, import_jsx_runtime140.jsx)(
          ui.span,
          {
            className: "ui-avatar__excess",
            borderRadius,
            rounded,
            ms: gap,
            __css: {
              position: "relative",
              display: "inline-flex",
              justifyContent: "center",
              alignItems: "center",
              flexShrink: 0,
              textAlign: "center",
              textTransform: "uppercase",
              fontWeight: "medium",
              borderWidth: "2px",
              ...styles2.excess
            },
            children: `+${excess}`
          }
        ) : null,
        cloneChildren
      ]
    }
  );
});

// node_modules/@yamada-ui/reorder/dist/chunk-7LKLDEZH.mjs
var import_react155 = __toESM(require_react(), 1);
var import_react156 = __toESM(require_react(), 1);
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var [ReorderProvider, useReorderContext] = createContext2({
  name: "ReorderContext",
  errorMessage: `useReorderContext returned is 'undefined'. Seems you forgot to wrap the components in "<Reorder />"`
});
var omitDuplicated = (values) => Array.from(new Set(values));
var pickDuplicated = (values) => values.filter(
  (value, index, self) => self.indexOf(value) === index && index !== self.lastIndexOf(value)
);
var Reorder3 = (0, import_react156.forwardRef)(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Reorder", props2);
    const {
      className,
      orientation = "vertical",
      gap = "fallback(4, 1rem)",
      items = [],
      onChange,
      onCompleteChange,
      children,
      ...rest
    } = omitThemeProps(mergedProps);
    const axis = orientation === "vertical" ? "y" : "x";
    const validChildren = getValidChildren(children);
    const hasChildren = !!validChildren.length;
    const defaultValues = (0, import_react156.useMemo)(() => {
      const values2 = hasChildren ? validChildren.map(({ props: props22 }) => props22.value) : items.map(({ value }) => value);
      const duplicatedValues = pickDuplicated(values2);
      if (duplicatedValues.length)
        console.warn(
          `Reorder: 'value' of 'ReorderItem' must not be duplicated. duplicate 'value' is '${duplicatedValues.join(
            `', '`
          )}' `
        );
      return omitDuplicated(values2);
    }, [hasChildren, validChildren, items]);
    const prevDefaultValues = (0, import_react156.useRef)(defaultValues);
    const [values, setValues2] = (0, import_react156.useState)(defaultValues);
    const prevValues = (0, import_react156.useRef)(defaultValues);
    const onReorder = (0, import_react156.useCallback)(
      (newValues) => {
        setValues2(newValues);
        onChange == null ? void 0 : onChange(newValues);
      },
      [onChange]
    );
    const onCompleteReorder = (0, import_react156.useCallback)(() => {
      const isEqual2 = JSON.stringify(prevValues.current) === JSON.stringify(values);
      if (isEqual2) return;
      prevValues.current = values;
      onCompleteChange == null ? void 0 : onCompleteChange(values);
    }, [onCompleteChange, values]);
    useUpdateEffect(() => {
      const isEqual2 = JSON.stringify(defaultValues) === JSON.stringify(prevDefaultValues.current);
      if (isEqual2) return;
      prevValues.current = defaultValues;
      prevDefaultValues.current = defaultValues;
      setValues2(defaultValues);
    }, [defaultValues]);
    const cloneChildren = (0, import_react156.useMemo)(
      () => values.map((value) => {
        if (hasChildren) {
          return validChildren.find(({ props: props22 }) => props22.value === value);
        } else {
          const props22 = items.find((item) => item.value === value);
          return props22 ? (0, import_jsx_runtime141.jsx)(ReorderItem2, { ...props22 }, props22.value) : null;
        }
      }),
      [values, hasChildren, validChildren, items]
    );
    const css4 = {
      display: "flex",
      flexDirection: orientation === "vertical" ? "column" : "row",
      gap,
      ...styles2.container
    };
    return (0, import_jsx_runtime141.jsx)(ReorderProvider, { value: { orientation, styles: styles2 }, children: (0, import_jsx_runtime141.jsx)(
      ui.ul,
      {
        ref,
        as: Reorder.Group,
        className: cx("ui-reorder", className),
        axis,
        values,
        onReorder,
        __css: css4,
        ...rest,
        onMouseUp: handlerAll(rest.onMouseUp, onCompleteReorder),
        onTouchEnd: handlerAll(rest.onTouchEnd, onCompleteReorder),
        children: cloneChildren
      }
    ) });
  }
);
Reorder3.displayName = "Reorder";
var [ReorderItemProvider, useReorderItemContext] = createContext2({
  name: "ReorderContext",
  errorMessage: `useReorderItemContext returned is 'undefined'. Seems you forgot to wrap the components in "<ReorderItem />"`
});
var ReorderItem2 = (0, import_react155.forwardRef)(
  ({ className, label, value, children, ...rest }, ref) => {
    var _a;
    const { orientation, styles: styles2 } = useReorderContext();
    const dragControls = useDragControls();
    const [hasTrigger, setHasTrigger] = (0, import_react155.useState)(false);
    const [isDrag, setIsDrag] = (0, import_react155.useState)(false);
    const x = useMotionValue(0);
    const y = useMotionValue(0);
    const register = (0, import_react155.useCallback)(
      (node3) => setHasTrigger(!!node3),
      []
    );
    (0, import_react155.useEffect)(() => {
      const unsubscribeX = x.on("change", (x2) => {
        if (orientation === "horizontal") setIsDrag(x2 !== 0);
      });
      const unsubscribeY = y.on("change", (y2) => {
        if (orientation === "vertical") setIsDrag(y2 !== 0);
      });
      return () => {
        unsubscribeX();
        unsubscribeY();
      };
    }, [orientation, x, y]);
    const css4 = {
      _selected: {
        cursor: "grabbing"
      },
      ...!hasTrigger ? { cursor: "grab" } : { userSelect: "none" },
      ...styles2.item,
      ...!hasTrigger ? {
        _selected: {
          ...(_a = styles2.item) == null ? void 0 : _a._selected,
          cursor: "grabbing"
        }
      } : {}
    };
    return (0, import_jsx_runtime142.jsx)(ReorderItemProvider, { value: { register, isDrag, dragControls }, children: (0, import_jsx_runtime142.jsx)(
      ui.li,
      {
        ref,
        as: Reorder.Item,
        className: cx("ui-reorder__item", className),
        value,
        __css: css4,
        ...rest,
        dragListener: !hasTrigger,
        dragControls,
        "data-selected": dataAttr(isDrag),
        style: { ...rest.style, x, y },
        children: children != null ? children : label
      }
    ) });
  }
);
ReorderItem2.displayName = "ReorderItem";

// node_modules/@yamada-ui/reorder/dist/chunk-WWNJ34QW.mjs
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var ReorderTrigger = forwardRef22(
  ({ className, children = (0, import_jsx_runtime143.jsx)(ReorderTriggerIcon, {}), ...rest }, ref) => {
    const { styles: styles2 } = useReorderContext();
    const { register, isDrag, dragControls } = useReorderItemContext();
    const css4 = {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      cursor: "grab",
      _selected: {
        cursor: "grabbing"
      },
      ...styles2.trigger
    };
    return (0, import_jsx_runtime143.jsx)(
      ui.div,
      {
        ref: mergeRefs(register, ref),
        className: cx("ui-reorder__trigger", className),
        __css: css4,
        ...rest,
        "data-selected": dataAttr(isDrag),
        onPointerDown: handlerAll(
          rest.onPointerDown,
          (ev) => dragControls.start(ev)
        ),
        children
      }
    );
  }
);
var ReorderTriggerIcon = (rest) => {
  return (0, import_jsx_runtime143.jsxs)(Icon, { viewBox: "0 0 39 39", ...rest, children: [
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 5 0 C 7.761 0 10 2.239 10 5 C 10 7.761 7.761 10 5 10 C 2.239 10 0 7.761 0 5 C 0 2.239 2.239 0 5 0 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 19 0 C 21.761 0 24 2.239 24 5 C 24 7.761 21.761 10 19 10 C 16.239 10 14 7.761 14 5 C 14 2.239 16.239 0 19 0 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 33 0 C 35.761 0 38 2.239 38 5 C 38 7.761 35.761 10 33 10 C 30.239 10 28 7.761 28 5 C 28 2.239 30.239 0 33 0 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 33 14 C 35.761 14 38 16.239 38 19 C 38 21.761 35.761 24 33 24 C 30.239 24 28 21.761 28 19 C 28 16.239 30.239 14 33 14 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 19 14 C 21.761 14 24 16.239 24 19 C 24 21.761 21.761 24 19 24 C 16.239 24 14 21.761 14 19 C 14 16.239 16.239 14 19 14 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 5 14 C 7.761 14 10 16.239 10 19 C 10 21.761 7.761 24 5 24 C 2.239 24 0 21.761 0 19 C 0 16.239 2.239 14 5 14 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 5 28 C 7.761 28 10 30.239 10 33 C 10 35.761 7.761 38 5 38 C 2.239 38 0 35.761 0 33 C 0 30.239 2.239 28 5 28 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 19 28 C 21.761 28 24 30.239 24 33 C 24 35.761 21.761 38 19 38 C 16.239 38 14 35.761 14 33 C 14 30.239 16.239 28 19 28 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime143.jsx)(
      "path",
      {
        d: "M 33 28 C 35.761 28 38 30.239 38 33 C 38 35.761 35.761 38 33 38 C 30.239 38 28 35.761 28 33 C 28 30.239 30.239 28 33 28 Z",
        fill: "currentColor"
      }
    )
  ] });
};

// node_modules/@yamada-ui/pagination/dist/chunk-FAA64ZR4.mjs
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var DotsIcon = (props2) => {
  return (0, import_jsx_runtime144.jsx)(Icon, { viewBox: "0 0 16 16", ...props2, children: (0, import_jsx_runtime144.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M2 8c0-.733.6-1.333 1.333-1.333.734 0 1.334.6 1.334 1.333s-.6 1.333-1.334 1.333C2.6 9.333 2 8.733 2 8zm9.333 0c0-.733.6-1.333 1.334-1.333C13.4 6.667 14 7.267 14 8s-.6 1.333-1.333 1.333c-.734 0-1.334-.6-1.334-1.333zM6.667 8c0-.733.6-1.333 1.333-1.333s1.333.6 1.333 1.333S8.733 9.333 8 9.333 6.667 8.733 6.667 8z"
    }
  ) });
};
var FirstIcon = (props2) => {
  return (0, import_jsx_runtime144.jsx)(Icon, { viewBox: "0 0 16 16", ...props2, children: (0, import_jsx_runtime144.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M6.85355 3.85355C7.04882 3.65829 7.04882 3.34171 6.85355 3.14645C6.65829 2.95118 6.34171 2.95118 6.14645 3.14645L2.14645 7.14645C1.95118 7.34171 1.95118 7.65829 2.14645 7.85355L6.14645 11.8536C6.34171 12.0488 6.65829 12.0488 6.85355 11.8536C7.04882 11.6583 7.04882 11.3417 6.85355 11.1464L3.20711 7.5L6.85355 3.85355ZM12.8536 3.85355C13.0488 3.65829 13.0488 3.34171 12.8536 3.14645C12.6583 2.95118 12.3417 2.95118 12.1464 3.14645L8.14645 7.14645C7.95118 7.34171 7.95118 7.65829 8.14645 7.85355L12.1464 11.8536C12.3417 12.0488 12.6583 12.0488 12.8536 11.8536C13.0488 11.6583 13.0488 11.3417 12.8536 11.1464L9.20711 7.5L12.8536 3.85355Z"
    }
  ) });
};
var LastIcon = (props2) => {
  return (0, import_jsx_runtime144.jsx)(Icon, { viewBox: "0 0 16 16", ...props2, children: (0, import_jsx_runtime144.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M2.14645 11.1464C1.95118 11.3417 1.95118 11.6583 2.14645 11.8536C2.34171 12.0488 2.65829 12.0488 2.85355 11.8536L6.85355 7.85355C7.04882 7.65829 7.04882 7.34171 6.85355 7.14645L2.85355 3.14645C2.65829 2.95118 2.34171 2.95118 2.14645 3.14645C1.95118 3.34171 1.95118 3.65829 2.14645 3.85355L5.79289 7.5L2.14645 11.1464ZM8.14645 11.1464C7.95118 11.3417 7.95118 11.6583 8.14645 11.8536C8.34171 12.0488 8.65829 12.0488 8.85355 11.8536L12.8536 7.85355C13.0488 7.65829 13.0488 7.34171 12.8536 7.14645L8.85355 3.14645C8.65829 2.95118 8.34171 2.95118 8.14645 3.14645C7.95118 3.34171 7.95118 3.65829 8.14645 3.85355L11.7929 7.5L8.14645 11.1464Z"
    }
  ) });
};
var PrevIcon = (props2) => {
  return (0, import_jsx_runtime144.jsx)(Icon, { viewBox: "0 0 16 16", ...props2, children: (0, import_jsx_runtime144.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M7.219 8l3.3 3.3-.943.943L5.333 8l4.243-4.243.943.943-3.3 3.3z"
    }
  ) });
};
var NextIcon = (props2) => {
  return (0, import_jsx_runtime144.jsx)(Icon, { viewBox: "0 0 16 16", ...props2, children: (0, import_jsx_runtime144.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M8.781 8l-3.3-3.3.943-.943L10.667 8l-4.243 4.243-.943-.943 3.3-3.3z"
    }
  ) });
};

// node_modules/@yamada-ui/pagination/dist/chunk-UUTVIFJX.mjs
var import_react157 = __toESM(require_react(), 1);
var [PaginationProvider, usePaginationContext] = createContext2({
  strict: false,
  name: "PaginationContext"
});
var computedRange = (start2, end2) => Array.from({ length: end2 - start2 + 1 }, (_, index) => index + start2);
var usePagination = ({
  page,
  defaultPage = 1,
  total,
  siblings = 1,
  boundaries = 1,
  isDisabled: isDisabled2 = false,
  onChange: onChangeProp
}) => {
  const computedSiblings = useValue(siblings);
  const computedBoundaries = useValue(boundaries);
  const [currentPage, setCurrentPage] = useControllableState({
    value: page,
    defaultValue: defaultPage,
    onChange: onChangeProp
  });
  const onFirst = (0, import_react157.useCallback)(() => setCurrentPage(1), [setCurrentPage]);
  const onLast = (0, import_react157.useCallback)(
    () => setCurrentPage(total),
    [setCurrentPage, total]
  );
  const onPrev = (0, import_react157.useCallback)(
    () => setCurrentPage((prev2) => prev2 === 1 ? prev2 : prev2 - 1),
    [setCurrentPage]
  );
  const onNext = (0, import_react157.useCallback)(
    () => setCurrentPage((prev2) => prev2 === total ? prev2 : prev2 + 1),
    [setCurrentPage, total]
  );
  const onChange = (0, import_react157.useCallback)(
    (page2) => setCurrentPage(page2),
    [setCurrentPage]
  );
  const range = (0, import_react157.useMemo)(() => {
    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2;
    if (minimumTotal >= total) return computedRange(1, total);
    const prevSiblings = Math.max(
      currentPage - computedSiblings,
      computedBoundaries
    );
    const nextSiblings = Math.min(
      currentPage + computedSiblings,
      total - computedBoundaries
    );
    const prevDots = prevSiblings > computedBoundaries + 2;
    const nextDots = nextSiblings < total - (computedBoundaries + 1);
    if (!prevDots && nextDots) {
      const prevPages = computedSiblings * 2 + computedBoundaries + 2;
      return [
        ...computedRange(1, prevPages),
        "dots",
        ...computedRange(total - (computedBoundaries - 1), total)
      ];
    }
    if (prevDots && !nextDots) {
      const nextPages = computedBoundaries + 1 + 2 * computedSiblings;
      return [
        ...computedRange(1, computedBoundaries),
        "dots",
        ...computedRange(total - nextPages, total)
      ];
    }
    return [
      ...computedRange(1, computedBoundaries),
      "dots",
      ...computedRange(prevSiblings, nextSiblings),
      "dots",
      ...computedRange(total - computedBoundaries + 1, total)
    ];
  }, [computedBoundaries, computedSiblings, currentPage, total]);
  return {
    currentPage,
    total,
    isDisabled: isDisabled2,
    onFirst,
    onLast,
    onPrev,
    onNext,
    onChange,
    range
  };
};

// node_modules/@yamada-ui/pagination/dist/chunk-MUXUDK7D.mjs
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var iconMap = {
  dots: (0, import_jsx_runtime145.jsx)(DotsIcon, {}),
  next: (0, import_jsx_runtime145.jsx)(NextIcon, {}),
  prev: (0, import_jsx_runtime145.jsx)(PrevIcon, {}),
  first: (0, import_jsx_runtime145.jsx)(FirstIcon, {}),
  last: (0, import_jsx_runtime145.jsx)(LastIcon, {})
};
var PaginationItem = ({
  className,
  isActive,
  page,
  isDisabled: isDisabled2,
  disableRipple,
  children,
  ...rest
}) => {
  var _a;
  const styles2 = usePaginationContext();
  const { onPointerDown, ...rippleProps } = useRipple({
    ...rest,
    isDisabled: disableRipple || isDisabled2
  });
  children != null ? children : children = (_a = iconMap[page]) != null ? _a : page;
  const css4 = {
    position: "relative",
    overflow: "hidden",
    userSelect: "none",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    ...styles2.item,
    ...styles2[page]
  };
  return (0, import_jsx_runtime145.jsxs)(
    ui.button,
    {
      className: cx("ui-pagination__item", className),
      type: "button",
      tabIndex: page !== "dots" ? 0 : -1,
      disabled: isDisabled2,
      "data-selected": dataAttr(isActive),
      "data-disabled": dataAttr(isDisabled2),
      __css: css4,
      ...rest,
      onPointerDown,
      children: [
        children,
        (0, import_jsx_runtime145.jsx)(Ripple, { isDisabled: disableRipple || isDisabled2, ...rippleProps })
      ]
    }
  );
};

// node_modules/@yamada-ui/pagination/dist/chunk-UUBWPBYB.mjs
var import_react158 = __toESM(require_react(), 1);
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var Pagination2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Pagination", props2);
  const {
    className,
    component: Component3 = PaginationItem,
    itemProps,
    withControls = true,
    withEdges = false,
    innerProps,
    controlProps,
    controlPrevProps,
    controlNextProps,
    edgeProps,
    edgeFirstProps,
    edgeLastProps,
    page,
    defaultPage,
    total,
    siblings,
    boundaries,
    isDisabled: isDisabled2,
    onChange: onChangeProp,
    ...rest
  } = omitThemeProps(mergedProps);
  const computedWithControls = useValue(withControls);
  const computedWithEdges = useValue(withEdges);
  const { currentPage, onFirst, onLast, onPrev, onNext, onChange, range } = usePagination({
    page,
    defaultPage,
    total,
    siblings,
    boundaries,
    isDisabled: isDisabled2,
    onChange: onChangeProp
  });
  const children = (0, import_react158.useMemo)(
    () => range.map((page2, key) => (0, import_jsx_runtime146.jsx)(
      Component3,
      {
        page: page2,
        isActive: currentPage === page2,
        isDisabled: isDisabled2,
        "aria-label": page2 === "dots" ? "Jump to omitted pages" : `Go to page ${page2}`,
        ...itemProps,
        onClick: handlerAll(
          itemProps == null ? void 0 : itemProps.onClick,
          page2 !== "dots" ? () => onChange(page2) : void 0
        )
      },
      key
    )),
    [Component3, currentPage, isDisabled2, onChange, range, itemProps]
  );
  const css4 = {
    display: "flex",
    alignItems: "center",
    ...styles2.container
  };
  return (0, import_jsx_runtime146.jsx)(PaginationProvider, { value: styles2, children: (0, import_jsx_runtime146.jsxs)(
    ui.div,
    {
      ref,
      className: cx("ui-pagination", className),
      role: "navigation",
      __css: css4,
      ...rest,
      "data-disabled": dataAttr(isDisabled2),
      children: [
        computedWithEdges ? (0, import_jsx_runtime146.jsx)(
          Component3,
          {
            page: "first",
            "aria-label": "Go to first page",
            className: "ui-pagination__item--first",
            isDisabled: isDisabled2 || currentPage === 1,
            ...edgeProps,
            ...edgeFirstProps,
            onClick: handlerAll(
              edgeProps == null ? void 0 : edgeProps.onClick,
              edgeFirstProps == null ? void 0 : edgeFirstProps.onClick,
              onFirst
            )
          }
        ) : null,
        computedWithControls ? (0, import_jsx_runtime146.jsx)(
          Component3,
          {
            page: "prev",
            "aria-label": "Go to previous page",
            className: "ui-pagination__item--prev",
            isDisabled: isDisabled2 || currentPage === 1,
            ...controlProps,
            ...controlPrevProps,
            onClick: handlerAll(
              controlProps == null ? void 0 : controlProps.onClick,
              controlPrevProps == null ? void 0 : controlPrevProps.onClick,
              onPrev
            )
          }
        ) : null,
        (0, import_jsx_runtime146.jsx)(
          ui.div,
          {
            className: "ui-pagination-inner",
            __css: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              ...styles2.inner
            },
            ...innerProps,
            children
          }
        ),
        computedWithControls ? (0, import_jsx_runtime146.jsx)(
          Component3,
          {
            page: "next",
            "aria-label": "Go to next page",
            className: "ui-pagination__item--next",
            isDisabled: isDisabled2 || currentPage === total,
            ...controlProps,
            ...controlNextProps,
            onClick: handlerAll(
              controlProps == null ? void 0 : controlProps.onClick,
              controlNextProps == null ? void 0 : controlNextProps.onClick,
              onNext
            )
          }
        ) : null,
        computedWithEdges ? (0, import_jsx_runtime146.jsx)(
          Component3,
          {
            page: "last",
            "aria-label": "Go to last page",
            className: "ui-pagination__item--last",
            isDisabled: isDisabled2 || currentPage === total,
            ...edgeProps,
            ...edgeLastProps,
            onClick: handlerAll(
              edgeProps == null ? void 0 : edgeProps.onClick,
              edgeLastProps == null ? void 0 : edgeLastProps.onClick,
              onLast
            )
          }
        ) : null
      ]
    }
  ) });
});

// node_modules/@yamada-ui/use-previous/dist/index.mjs
var import_react159 = __toESM(require_react(), 1);
var usePrevious = (value) => {
  const ref = (0, import_react159.useRef)();
  (0, import_react159.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// node_modules/@yamada-ui/skeleton/dist/chunk-XFST3ALX.mjs
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var Skeleton2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("Skeleton", props2);
  let {
    className,
    startColor,
    endColor,
    fadeDuration = 0.4,
    speed = 0.8,
    isLoaded,
    isFitContent,
    children,
    ...rest
  } = omitThemeProps(mergedProps);
  const [isMounted] = useIsMounted();
  const validChildren = getValidChildren(children);
  const prevIsLoaded = usePrevious(isLoaded);
  const computedStartColor = useValue(startColor);
  const computedEndColor = useValue(endColor);
  const hasChildren = !!validChildren.length;
  isFitContent != null ? isFitContent : isFitContent = hasChildren;
  const fadeIn = useAnimation2({
    keyframes: {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    },
    duration: typeof fadeDuration === "string" ? fadeDuration : `${fadeDuration}s`
  });
  const animation2 = useAnimation2({
    keyframes: {
      "0%": {
        borderColor: computedStartColor,
        background: computedStartColor
      },
      "100%": {
        borderColor: computedEndColor,
        background: computedEndColor
      }
    },
    duration: typeof speed === "string" ? speed : `${speed}s`,
    iterationCount: "infinite",
    direction: "alternate",
    timingFunction: "linear"
  });
  const css4 = {
    w: isFitContent ? "fit-content" : "100%",
    maxW: "100%",
    h: isFitContent ? "fit-content" : "fallback(4, 1rem)",
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    },
    ...styles2
  };
  if (isLoaded) {
    const animation22 = !isMounted() || prevIsLoaded ? "none" : fadeIn;
    return (0, import_jsx_runtime147.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-skeleton", "ui-skeleton--loaded", className),
        ...rest,
        animation: animation22,
        "aria-busy": "false",
        children: validChildren
      }
    );
  } else {
    return (0, import_jsx_runtime147.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-skeleton", className),
        __css: css4,
        ...rest,
        animation: animation2,
        "aria-busy": "true",
        children: validChildren
      }
    );
  }
});

// node_modules/@yamada-ui/skeleton/dist/chunk-DK2XTCLO.mjs
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var SkeletonText = forwardRef22(
  ({
    className,
    lineClamp = 3,
    startColor,
    endColor,
    fadeDuration,
    speed,
    isLoaded,
    gap = "fallback(2, 0.5rem)",
    textHeight = "fallback(2, 0.5rem)",
    children,
    ...rest
  }, ref) => {
    const computedLineClamp = useValue(lineClamp);
    const css4 = {
      w: "100%"
    };
    return (0, import_jsx_runtime148.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-skeleton__text", className),
        __css: css4,
        ...rest,
        children: Array(computedLineClamp).fill(0).map((_, index) => {
          if (isLoaded && index > 0) return null;
          const isLast = index + 1 === computedLineClamp;
          const props2 = !isLoaded ? {
            mb: !isLast ? gap : void 0,
            w: computedLineClamp > 1 ? !isLast ? "100%" : "80%" : "100%",
            h: textHeight
          } : {};
          return (0, import_jsx_runtime148.jsx)(
            Skeleton2,
            {
              ...{
                startColor,
                endColor,
                fadeDuration,
                speed,
                isLoaded,
                ...props2
              },
              children: index === 0 ? children : void 0
            },
            index
          );
        })
      }
    );
  }
);
var SkeletonCircle = forwardRef22(
  ({
    className,
    boxSize = "fallback(12, 3rem)",
    children,
    isFitContent,
    ...rest
  }, ref) => {
    const validChildren = getValidChildren(children);
    const hasChildren = !!validChildren.length;
    isFitContent != null ? isFitContent : isFitContent = hasChildren;
    return (0, import_jsx_runtime149.jsx)(
      Skeleton2,
      {
        ref,
        className: cx("ui-skeleton__circle", className),
        rounded: "fallback(full, 9999px)",
        isFitContent,
        ...!isFitContent ? { boxSize } : {},
        ...rest,
        children: validChildren
      }
    );
  }
);

// node_modules/@yamada-ui/stepper/dist/chunk-FDB3CXIB.mjs
var import_react160 = __toESM(require_react(), 1);
var {
  DescendantsContextProvider: StepperDescendantsContextProvider,
  useDescendants: useStepperDescendants,
  useDescendant: useStepperDescendant
} = createDescendant();
var [StepperProvider, useStepperContext] = createContext2({
  name: "StepperContext",
  errorMessage: `useStepperContext returned is 'undefined'. Seems you forgot to wrap the components in "<Stepper />"`
});
var useStepper = ({
  index,
  orientation = "horizontal",
  showLastSeparator = false,
  ...rest
}) => {
  const descendants = useStepperDescendants();
  const getStepStatus = (0, import_react160.useCallback)(
    (step) => {
      if (step < index) return "complete";
      if (step > index) return "incomplete";
      return "active";
    },
    [index]
  );
  const getContainerProps = (0, import_react160.useCallback)(
    (props2 = {}, ref = null) => ({
      ...rest,
      ...props2,
      ref,
      "data-orientation": orientation
    }),
    [orientation, rest]
  );
  return {
    descendants,
    index,
    orientation,
    showLastSeparator,
    getStepStatus,
    getContainerProps
  };
};
var useStep = () => {
  var _a;
  const { orientation, getStepStatus } = useStepperContext();
  const { index, register, descendants } = useStepperDescendant();
  const isFirst = index === 0;
  const isLast = index === ((_a = descendants.lastValue()) == null ? void 0 : _a.index);
  const status = getStepStatus(index);
  const getStepProps = (0, import_react160.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(ref, register),
      "data-status": status,
      "data-orientation": orientation
    }),
    [orientation, register, status]
  );
  return { index, status, isFirst, isLast, getStepProps };
};

// node_modules/@yamada-ui/stepper/dist/chunk-N5XFZLWY.mjs
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var [StepProvider, useStepContext] = createContext2({
  name: "StepperContext",
  errorMessage: `useStepContext returned is 'undefined'. Seems you forgot to wrap the components in "<Step />"`
});
var Step = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { orientation, showLastSeparator, styles: styles2 } = useStepperContext();
    const { index, status, isFirst, isLast, getStepProps } = useStep();
    const css4 = { ...styles2.step };
    return (0, import_jsx_runtime150.jsx)(StepProvider, { value: { index, status, isFirst, isLast }, children: (0, import_jsx_runtime150.jsx)(
      ui.div,
      {
        className: cx("ui-step", className),
        __css: css4,
        "data-orientation": orientation,
        "data-stretch": dataAttr(showLastSeparator),
        ...getStepProps(rest, ref)
      }
    ) });
  }
);

// node_modules/@yamada-ui/stepper/dist/chunk-E36CPWJZ.mjs
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var StepDescription = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useStepperContext();
    const { status } = useStepContext();
    const css4 = { ...styles2.description };
    return (0, import_jsx_runtime151.jsx)(
      ui.p,
      {
        ref,
        className: cx("ui-step__description", className),
        "data-status": status,
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/stepper/dist/chunk-PNGIUUGW.mjs
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var StepSeparator = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { orientation, showLastSeparator, styles: styles2 } = useStepperContext();
    const { status, isLast } = useStepContext();
    const css4 = { ...styles2.separator };
    if (isLast && !showLastSeparator) return null;
    return (0, import_jsx_runtime152.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-step__separator", className),
        role: "separator",
        "data-orientation": orientation,
        "data-status": status,
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/stepper/dist/chunk-P5NE4AGB.mjs
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var StepStatus = forwardRef22(
  ({
    className,
    complete = (0, import_jsx_runtime153.jsx)(StepIcon, {}),
    incomplete = (0, import_jsx_runtime153.jsx)(StepNumber, {}),
    active = (0, import_jsx_runtime153.jsx)(StepNumber, {}),
    ...rest
  }, ref) => {
    const { styles: styles2 } = useStepperContext();
    const { status, ...props2 } = useStepContext();
    const css4 = { ...styles2.status };
    let component = null;
    switch (status) {
      case "complete":
        component = runIfFunc(complete, props2);
        break;
      case "incomplete":
        component = runIfFunc(incomplete, props2);
        break;
      case "active":
        component = runIfFunc(active, props2);
        break;
    }
    return (0, import_jsx_runtime153.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-step__status", className),
        "data-status": status,
        __css: css4,
        ...rest,
        children: component ? (0, import_jsx_runtime153.jsx)(import_jsx_runtime153.Fragment, { children: component }) : null
      }
    );
  }
);
var StepNumber = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { styles: styles2 } = useStepperContext();
    const { status, index } = useStepContext();
    const css4 = { ...styles2.number };
    return (0, import_jsx_runtime153.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-step__number", className),
        "data-status": status,
        __css: css4,
        ...rest,
        children: children || index + 1
      }
    );
  }
);
var StepIcon = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useStepperContext();
    const { status } = useStepContext();
    const as = status === "complete" ? CheckIcon6 : void 0;
    const css4 = { ...styles2.icon };
    return (0, import_jsx_runtime153.jsx)(
      Icon,
      {
        ref,
        as,
        className: cx("ui-step__icon", className),
        "data-status": status,
        __css: css4,
        ...rest
      }
    );
  }
);
var CheckIcon6 = (props2) => {
  return (0, import_jsx_runtime153.jsx)(
    "svg",
    {
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0",
      viewBox: "0 0 20 20",
      "aria-hidden": "true",
      height: "1em",
      width: "1em",
      ...props2,
      children: (0, import_jsx_runtime153.jsx)(
        "path",
        {
          fillRule: "evenodd",
          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
          clipRule: "evenodd"
        }
      )
    }
  );
};

// node_modules/@yamada-ui/stepper/dist/chunk-4M7J27BP.mjs
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var StepTitle = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { styles: styles2 } = useStepperContext();
    const { status } = useStepContext();
    const css4 = { ...styles2.title };
    return (0, import_jsx_runtime154.jsx)(
      ui.h3,
      {
        ref,
        className: cx("ui-step__title", className),
        "data-status": status,
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/stepper/dist/chunk-NLSB4V5L.mjs
var import_react161 = __toESM(require_react(), 1);
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var Stepper3 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Stepper", props2);
  const { className, steps: steps3, children, ...computedProps } = omitThemeProps(mergedProps);
  const { descendants, getContainerProps, ...rest } = useStepper(computedProps);
  const computedChildren = (0, import_react161.useMemo)(() => {
    const hasChildren = children != null;
    if (hasChildren) {
      return children;
    } else {
      return steps3 == null ? void 0 : steps3.map(
        ({
          title,
          description,
          hasSeparator = true,
          statusProps,
          titleProps,
          descriptionProps,
          separatorProps,
          ...rest2
        }, index) => (0, import_jsx_runtime155.jsxs)(Step, { ...rest2, children: [
          (0, import_jsx_runtime155.jsx)(StepStatus, { ...statusProps }),
          (0, import_jsx_runtime155.jsxs)(ui.div, { flexShrink: 0, children: [
            title ? (0, import_jsx_runtime155.jsx)(StepTitle, { ...titleProps, children: title }) : null,
            description ? (0, import_jsx_runtime155.jsx)(StepDescription, { ...descriptionProps, children: description }) : null
          ] }),
          hasSeparator ? (0, import_jsx_runtime155.jsx)(StepSeparator, { ...separatorProps }) : null
        ] }, index)
      );
    }
  }, [children, steps3]);
  const css4 = { ...styles2.stepper };
  return (0, import_jsx_runtime155.jsx)(StepperDescendantsContextProvider, { value: descendants, children: (0, import_jsx_runtime155.jsx)(StepperProvider, { value: { ...rest, styles: styles2 }, children: (0, import_jsx_runtime155.jsx)(
    ui.div,
    {
      className: cx("ui-stepper", className),
      __css: css4,
      ...getContainerProps({}, ref),
      children: computedChildren
    }
  ) }) });
});

// node_modules/@yamada-ui/stepper/dist/chunk-BENKUDOU.mjs
var import_react162 = __toESM(require_react(), 1);
var useSteps = ({ index = 0, count }) => {
  const [activeStep, setActiveStep] = (0, import_react162.useState)(index);
  const maxStep = typeof count === "number" ? count - 1 : 0;
  const activeStepPercent = activeStep / maxStep;
  const isActiveStep = (0, import_react162.useCallback)(
    (step) => step === activeStep,
    [activeStep]
  );
  const isCompleteStep = (0, import_react162.useCallback)(
    (step) => step < activeStep,
    [activeStep]
  );
  const isIncompleteStep = (0, import_react162.useCallback)(
    (step) => step > activeStep,
    [activeStep]
  );
  const getStepStatus = (0, import_react162.useCallback)(
    (step) => {
      if (step < activeStep) return "complete";
      if (step > activeStep) return "incomplete";
      return "active";
    },
    [activeStep]
  );
  const onStepNext = (0, import_react162.useCallback)(
    () => setActiveStep(
      (step) => typeof count === "number" ? Math.min(count, step + 1) : step + 1
    ),
    [count]
  );
  const onStepPrev = (0, import_react162.useCallback)(
    () => setActiveStep((step) => Math.max(0, step - 1)),
    []
  );
  return {
    activeStep,
    setActiveStep,
    activeStepPercent,
    isActiveStep,
    isCompleteStep,
    isIncompleteStep,
    getStepStatus,
    onStepNext,
    onStepPrev
  };
};

// node_modules/@yamada-ui/native-table/dist/chunk-46RUZ6RP.mjs
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var [TableStyleProvider, useTableStyles] = createContext2({
  name: "TableStyleContext",
  errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Table />" or "<NativeTable />" or "<PagingTable />"`
});
var NativeTable2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("NativeTable", props2);
    const { className, layout: layout2, ...rest } = omitThemeProps(mergedProps, [
      "withBorder",
      "withColumnBorders",
      "highlightOnHover"
    ]);
    const css4 = { tableLayout: layout2, ...styles2.table };
    return (0, import_jsx_runtime156.jsx)(TableStyleProvider, { value: styles2, children: (0, import_jsx_runtime156.jsx)(
      ui.table,
      {
        ref,
        className: cx("ui-table", className),
        __css: css4,
        ...rest
      }
    ) });
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-TCVAGKGE.mjs
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var Thead = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { ...styles2.thead };
    return (0, import_jsx_runtime157.jsx)(
      ui.thead,
      {
        ref,
        className: cx("ui-table__thead", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-C4I2YYWU.mjs
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var Tr = forwardRef22(({ className, ...rest }, ref) => {
  const styles2 = useTableStyles();
  const css4 = { ...styles2.tr };
  return (0, import_jsx_runtime158.jsx)(
    ui.tr,
    {
      ref,
      className: cx("ui-table__tr", className),
      __css: css4,
      ...rest
    }
  );
});

// node_modules/@yamada-ui/native-table/dist/chunk-QGDJRCL5.mjs
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var TableCaption = forwardRef22(
  ({ className, placement = "bottom", ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { captionSide: placement, ...styles2.caption };
    return (0, import_jsx_runtime159.jsx)(
      ui.caption,
      {
        ref,
        className: cx("ui-table__caption", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-DIW3KZOZ.mjs
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var TableContainer = forwardRef22(
  ({ className, overflow, overflowX, ...rest }, ref) => {
    var _a;
    const css4 = {
      display: "block",
      whiteSpace: "nowrap",
      WebkitOverflowScrolling: "touch",
      overflowX: (_a = overflow != null ? overflow : overflowX) != null ? _a : "auto",
      overflowY: "hidden",
      maxW: "100%"
    };
    return (0, import_jsx_runtime160.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-table__container", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-E5ACEM2U.mjs
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var Tbody = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { ...styles2.tbody };
    return (0, import_jsx_runtime161.jsx)(
      ui.tbody,
      {
        ref,
        className: cx("ui-table__tbody", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-CH57RN3P.mjs
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var Td = forwardRef22(
  ({ className, isNumeric: isNumeric3, ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { ...styles2.td };
    return (0, import_jsx_runtime162.jsx)(
      ui.td,
      {
        ref,
        className: cx("ui-table__td", className),
        __css: css4,
        "data-is-numeric": isNumeric3,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-GRDP45DA.mjs
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var Tfoot = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { ...styles2.tfoot };
    return (0, import_jsx_runtime163.jsx)(
      ui.tfoot,
      {
        ref,
        className: cx("ui-table__tfoot", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/native-table/dist/chunk-UWDCTL2V.mjs
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var Th = forwardRef22(
  ({ className, isNumeric: isNumeric3, __css, ...rest }, ref) => {
    const styles2 = useTableStyles();
    const css4 = { ...styles2.th, ...__css };
    return (0, import_jsx_runtime164.jsx)(
      ui.th,
      {
        ref,
        className: cx("ui-table__th", className),
        __css: css4,
        "data-is-numeric": isNumeric3,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/indicator/dist/chunk-WKMXRPIT.mjs
var import_react163 = __toESM(require_react(), 1);
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var getPlacementStyle = (placement, offset2) => {
  const styles2 = {};
  let translateX = "";
  let translateY = "";
  if (placement.includes("top")) {
    styles2.top = offset2;
    translateY = "-50%";
  } else if (placement.includes("bottom")) {
    styles2.bottom = offset2;
    translateY = "50%";
  } else {
    styles2.top = "50%";
    translateY = "-50%";
  }
  if (placement.includes("left")) {
    styles2.left = offset2;
    translateX = "-50%";
  } else if (placement.includes("right")) {
    styles2.right = offset2;
    translateX = "50%";
  } else {
    styles2.left = "50%";
    translateX = "-50%";
  }
  styles2.transform = `translate(${translateX}, ${translateY})`;
  return styles2;
};
var Indicator2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useComponentStyle("Indicator", props2);
  let {
    className,
    inline = false,
    placement = "top-right",
    offset: offset2 = 0,
    label,
    overflowCount = 99,
    showZero = true,
    children,
    isDisabled: isDisabled2,
    containerProps,
    ping,
    pingColor = "$ping",
    pingDuration = "1.4s",
    pingCount = "infinite",
    pingScale = 1.8,
    ...rest
  } = omitThemeProps(mergedProps, ["withBorder"]);
  const animation2 = useAnimation2({
    keyframes: {
      "75%, 100%": {
        transform: `scale(${pingScale})`,
        opacity: 0
      }
    },
    fillMode: "forwards",
    duration: pingDuration,
    timingFunction: "cubic-bezier(0, 0, 0.2, 1)",
    iterationCount: pingCount
  });
  const isNumeric3 = typeof label === "number";
  if (isNumeric3 && !showZero && label <= 0) isDisabled2 != null ? isDisabled2 : isDisabled2 = true;
  const computedInline = useValue(inline);
  const computedPlacement = useValue(placement);
  const computedOffset = useValue(offset2);
  const renderLabel = (0, import_react163.useMemo)(() => {
    if (isNumeric3) {
      if (label > overflowCount) {
        return (0, import_jsx_runtime165.jsxs)(import_jsx_runtime165.Fragment, { children: [
          overflowCount,
          (0, import_jsx_runtime165.jsx)(ui.span, { lineHeight: 1, children: "+" })
        ] });
      } else {
        return label;
      }
    } else {
      return label;
    }
  }, [isNumeric3, label, overflowCount]);
  const css4 = {
    position: "absolute",
    ...getPlacementStyle(computedPlacement, computedOffset),
    ...isNumeric3 ? { fontWeight: "medium" } : {},
    ...styles2
  };
  return (0, import_jsx_runtime165.jsxs)(
    ui.div,
    {
      ref,
      className: cx("ui-indicator", className),
      __css: {
        position: "relative",
        display: computedInline ? "inline-block" : "block"
      },
      ...containerProps,
      children: [
        !isDisabled2 ? (0, import_jsx_runtime165.jsxs)(
          ui.div,
          {
            ref,
            className: cx("ui-indicator__icon", className),
            __css: css4,
            ...rest,
            children: [
              renderLabel,
              ping ? (0, import_jsx_runtime165.jsx)(
                ui.div,
                {
                  className: "ui-indicator__icon__ping",
                  __css: {
                    position: "absolute",
                    boxSize: "100%",
                    rounded: "fallback(full, 9999px)",
                    opacity: 0.75,
                    zIndex: -1,
                    bg: pingColor
                  },
                  animation: animation2
                }
              ) : null
            ]
          }
        ) : null,
        children
      ]
    }
  );
});

// node_modules/@yamada-ui/use-hover/dist/index.mjs
var import_react164 = __toESM(require_react(), 1);
var useHover = () => {
  const [hovered, setHovered] = (0, import_react164.useState)(false);
  const ref = (0, import_react164.useRef)(null);
  const onMouseEnter = (0, import_react164.useCallback)(() => setHovered(true), []);
  const onMouseLeave = (0, import_react164.useCallback)(() => setHovered(false), []);
  (0, import_react164.useEffect)(() => {
    const el = ref.current;
    if (el) {
      el.addEventListener("mouseenter", onMouseEnter);
      el.addEventListener("mouseleave", onMouseLeave);
      return () => {
        el.removeEventListener("mouseenter", onMouseEnter);
        el.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [onMouseEnter, onMouseLeave]);
  return { ref, hovered };
};

// node_modules/@yamada-ui/use-idle/dist/index.mjs
var import_react165 = __toESM(require_react(), 1);
var DEFAULT_EVENTS = [
  "keypress",
  "mousemove",
  "touchmove",
  "click",
  "scroll"
];
var DEFAULT_OPTIONS2 = {
  events: DEFAULT_EVENTS,
  initialState: true
};
var useIdle = (timeout, options) => {
  const { events, initialState: initialState2 } = { ...DEFAULT_OPTIONS2, ...options };
  const [idle, setIdle] = (0, import_react165.useState)(initialState2);
  const timeoutId = (0, import_react165.useRef)(null);
  (0, import_react165.useEffect)(() => {
    const handleEvent = () => {
      setIdle(false);
      if (timeoutId.current) window.clearTimeout(timeoutId.current);
      timeoutId.current = window.setTimeout(() => {
        setIdle(true);
      }, timeout);
    };
    events.forEach((event) => document.addEventListener(event, handleEvent));
    return () => {
      events.forEach(
        (event) => document.removeEventListener(event, handleEvent)
      );
    };
  }, [events, timeout]);
  return idle;
};

// node_modules/@yamada-ui/use-os/dist/index.mjs
var getOS = () => {
  const { userAgent } = window.navigator;
  const macos = /(Macintosh)|(MacIntel)|(MacPPC)|(Mac68K)/i;
  const windows = /(Win32)|(Win64)|(Windows)|(WinCE)/i;
  const ios = /(iPhone)|(iPad)|(iPod)/i;
  const android = /Android/i;
  const linux = /Linux/i;
  if (macos.test(userAgent)) return "macos";
  if (ios.test(userAgent)) return "ios";
  if (windows.test(userAgent)) return "windows";
  if (android.test(userAgent)) return "android";
  if (linux.test(userAgent)) return "linux";
  return "undetermined";
};
var useOS = () => {
  if (typeof window !== "undefined") return getOS();
  return "undetermined";
};

// node_modules/@yamada-ui/use-window-event/dist/index.mjs
var import_react166 = __toESM(require_react(), 1);
var useWindowEvent = (event, handler, options) => {
  const listener = useCallbackRef(
    handler
  );
  (0, import_react166.useEffect)(() => {
    window.addEventListener(event, listener, options);
    return () => {
      window.removeEventListener(event, listener, options);
    };
  }, [event, listener, options]);
};

// node_modules/@yamada-ui/use-local-storage/dist/index.mjs
var import_react167 = __toESM(require_react(), 1);
var serializeJSON = (value, name) => {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`useLocalStorage ${name}: Failed to serialize the value`);
  }
};
var deserializeJSON = (value) => {
  if (!value) return value;
  try {
    return JSON.parse(value);
  } catch {
    return value;
  }
};
var createStorage = (type, name) => {
  const eventName = type === "localStorage" ? "ui-local-storage" : "ui-session-storage";
  return ({
    key,
    defaultValue = void 0,
    getInitialValueInEffect = true,
    deserialize = deserializeJSON,
    serialize: serialize2 = (value) => serializeJSON(value, name)
  }) => {
    const readStorageValue = (0, import_react167.useCallback)(
      (skipStorage) => {
        if (typeof window === "undefined" || !(type in window) || window[type] === null || skipStorage) {
          return defaultValue != null ? defaultValue : "";
        }
        const storageValue = window[type].getItem(key);
        return storageValue !== null ? deserialize(storageValue) : defaultValue != null ? defaultValue : "";
      },
      [key, deserialize, defaultValue]
    );
    const [value, setValue] = (0, import_react167.useState)(
      readStorageValue(getInitialValueInEffect)
    );
    const setStorageValue = (0, import_react167.useCallback)(
      (valOrFunc) => {
        if (isFunction(valOrFunc)) {
          setValue((current) => {
            const result = valOrFunc(current);
            window[type].setItem(key, serialize2(result));
            window.dispatchEvent(
              new CustomEvent(eventName, {
                detail: { key, value: valOrFunc(current) }
              })
            );
            return result;
          });
        } else {
          window[type].setItem(key, serialize2(valOrFunc));
          window.dispatchEvent(
            new CustomEvent(eventName, { detail: { key, value: valOrFunc } })
          );
          setValue(valOrFunc);
        }
      },
      [key, serialize2]
    );
    const removeStorageValue = (0, import_react167.useCallback)(() => {
      window[type].removeItem(key);
      setValue(defaultValue);
    }, [defaultValue, key]);
    useWindowEvent("storage", (ev) => {
      var _a;
      if (ev.storageArea === window[type] && ev.key === key)
        setValue(deserialize((_a = ev.newValue) != null ? _a : void 0));
    });
    useWindowEvent(eventName, (ev) => {
      if (ev.detail.key === key) setValue(ev.detail.value);
    });
    (0, import_react167.useEffect)(() => {
      if (defaultValue !== void 0 && value === void 0)
        setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]);
    (0, import_react167.useEffect)(() => {
      if (getInitialValueInEffect) setValue(readStorageValue());
    }, [getInitialValueInEffect, readStorageValue]);
    return [
      value === void 0 ? defaultValue : value,
      setStorageValue,
      removeStorageValue
    ];
  };
};
var useLocalStorage = (props2) => createStorage("localStorage", "use-local-storage")(props2);

// node_modules/@yamada-ui/use-media-query/dist/index.mjs
var import_react168 = __toESM(require_react(), 1);
var useMediaQuery = (query, { ssr = true, fallback } = {}) => {
  const { getWindow: getWindow2 } = useEnvironment();
  const queries2 = isArray(query) ? query : [query];
  let fallbackValues = isArray(fallback) ? fallback : [fallback];
  fallbackValues = fallbackValues.filter((value2) => value2 != null);
  const [value, setValue] = (0, import_react168.useState)(() => {
    return queries2.map((media, index) => {
      var _a;
      return {
        media,
        matches: ssr ? !!fallbackValues[index] : !!((_a = getWindow2()) == null ? void 0 : _a.matchMedia(media).matches)
      };
    });
  });
  (0, import_react168.useEffect)(() => {
    const win = getWindow2();
    if (!win) return;
    setValue(
      queries2.map((media) => ({
        media,
        matches: win.matchMedia(media).matches
      }))
    );
    const mql = queries2.map((query2) => win.matchMedia(query2));
    const handler = (ev) => {
      setValue(
        (prev2) => prev2.slice().map((item) => {
          if (item.media === ev.media) return { ...item, matches: ev.matches };
          return item;
        })
      );
    };
    mql.forEach((mq) => {
      if (isFunction(mq.addListener)) {
        mq.addListener(handler);
      } else {
        mq.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach((mq) => {
        if (isFunction(mq.removeListener)) {
          mq.removeListener(handler);
        } else {
          mq.removeEventListener("change", handler);
        }
      });
    };
  }, [getWindow2]);
  return value.map((item) => item.matches);
};

// node_modules/@yamada-ui/use-clipboard/dist/index.mjs
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);
var import_react169 = __toESM(require_react(), 1);
var useClipboard = (defaultValue = "", timeoutOrOptions = {}) => {
  const [hasCopied, setHasCopied] = (0, import_react169.useState)(false);
  const [value, setValue] = (0, import_react169.useState)(defaultValue);
  (0, import_react169.useEffect)(() => setValue(defaultValue), [defaultValue]);
  const { timeout = 1500, ...copyOptions } = isNumber(timeoutOrOptions) ? { timeout: timeoutOrOptions } : timeoutOrOptions;
  const onCopy = (0, import_react169.useCallback)(
    (newValue) => {
      if (!isString(newValue)) {
        newValue = value;
      } else {
        setValue(newValue);
      }
      const hasCopied2 = (0, import_copy_to_clipboard.default)(newValue, copyOptions);
      setHasCopied(hasCopied2);
    },
    [value, copyOptions]
  );
  (0, import_react169.useEffect)(() => {
    let timeoutId = null;
    if (hasCopied)
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    return () => {
      if (timeoutId) window.clearTimeout(timeoutId);
    };
  }, [timeout, hasCopied]);
  return {
    value,
    setValue,
    onCopy,
    hasCopied
  };
};

// node_modules/@yamada-ui/use-eye-dropper/dist/index.mjs
var import_react170 = __toESM(require_react(), 1);
var useEyeDropper = () => {
  const [supported, setSupported] = (0, import_react170.useState)(false);
  useSafeLayoutEffect(() => {
    setSupported(typeof window !== "undefined" && "EyeDropper" in window);
  }, []);
  const onOpen = (0, import_react170.useCallback)(
    (options = {}) => {
      if (supported) {
        const eyeDropper = new window.EyeDropper();
        return eyeDropper.open(options);
      }
      return Promise.resolve(void 0);
    },
    [supported]
  );
  return { supported, onOpen };
};

// node_modules/@yamada-ui/color-picker/dist/chunk-HWTRKOHL.mjs
var import_react171 = __toESM(require_react(), 1);
var [ColorPickerProvider, useColorPickerContext] = createContext2({
  name: "ColorPickerContext",
  errorMessage: `useColorPickerContext returned is 'undefined'. Seems you forgot to wrap the components in "<ColorPicker />"`
});
var useColorPicker = ({
  value: valueProp,
  defaultValue,
  fallbackValue,
  defaultColor,
  onChange: onChangeProp,
  onChangeStart,
  onChangeEnd,
  onSwatchClick,
  formatInput = (value) => value,
  closeOnBlur = true,
  closeOnEsc = true,
  placement = "bottom-start",
  duration = 0.2,
  isOpen: isOpenProp,
  defaultIsOpen,
  onOpen: onOpenProp,
  onClose: onCloseProp,
  allowInput = true,
  closeOnSelectSwatch,
  format,
  swatchesLabel,
  swatches,
  swatchesColumns,
  withPicker,
  withChannel,
  withResult = false,
  withColorSelectorEyeDropper = false,
  colorSelectorVariant,
  colorSelectorSize,
  colorSelectorColorScheme,
  ...rest
}) => {
  var _a;
  rest = useFormControlProps(rest);
  const { "aria-readonly": _ariaReadonly, ...formControlProps } = pickObject(
    rest,
    formControlProperties
  );
  const { disabled, readOnly } = formControlProps;
  const [containerProps, inputProps] = splitObject(
    omitObject(rest, [...popoverProperties]),
    layoutStyleProperties
  );
  const containerRef = (0, import_react171.useRef)(null);
  const fieldRef = (0, import_react171.useRef)(null);
  const { supported: eyeDropperSupported, onOpen: onEyeDropperOpen } = useEyeDropper();
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const formatRef = (0, import_react171.useRef)(
    format != null ? format : calcFormat((_a = value != null ? value : defaultColor) != null ? _a : "")
  );
  const isInputFocused = (0, import_react171.useRef)(false);
  const [inputValue, setInputValue] = (0, import_react171.useState)(value != null ? value : "");
  const {
    isOpen,
    onOpen: onInternalOpen,
    onClose: onInternalClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const isColorSelectorFull = colorSelectorSize === "full";
  const onOpen = (0, import_react171.useCallback)(() => {
    if (disabled || readOnly) return;
    onInternalOpen();
  }, [onInternalOpen, disabled, readOnly]);
  const onClose = (0, import_react171.useCallback)(() => {
    if (!isOpen) return;
    const next2 = convertColor(value, fallbackValue)(formatRef.current);
    setValue((prev2) => !next2 || prev2 === next2 ? prev2 : next2);
    setInputValue(formatInput(next2 != null ? next2 : ""));
    onInternalClose();
  }, [
    formatRef,
    isOpen,
    setValue,
    onInternalClose,
    value,
    formatInput,
    setInputValue,
    fallbackValue
  ]);
  const onContainerClick = (0, import_react171.useCallback)(() => {
    if (isOpen) return;
    onOpen();
  }, [isOpen, onOpen]);
  const onInputFocus = (0, import_react171.useCallback)(() => {
    isInputFocused.current = true;
    if (isOpen) return;
    onOpen();
  }, [isOpen, onOpen]);
  const onInputBlur = (0, import_react171.useCallback)(() => {
    isInputFocused.current = false;
  }, []);
  const onContainerBlur = (0, import_react171.useCallback)(
    (ev) => {
      const relatedTarget = getEventRelatedTarget(ev);
      if (isContains(containerRef.current, relatedTarget)) return;
      if (!closeOnBlur) return;
      if (isOpen) onClose();
    },
    [closeOnBlur, isOpen, onClose]
  );
  const onInputKeyDown = (0, import_react171.useCallback)(
    (ev) => {
      if (ev.key === " ") ev.key = ev.code;
      if (disabled || readOnly) return;
      const actions = {
        Space: !isOpen ? onOpen : void 0,
        Enter: !isOpen ? onOpen : void 0,
        Escape: closeOnEsc ? onClose : void 0
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action();
    },
    [disabled, readOnly, isOpen, onOpen, closeOnEsc, onClose]
  );
  const onInputChange = (0, import_react171.useCallback)(
    (ev) => {
      const value2 = ev.target.value;
      setInputValue(formatInput(value2));
      setValue(value2);
    },
    [setInputValue, formatInput, setValue]
  );
  const onColorSelectorChange = (0, import_react171.useCallback)(
    (value2) => {
      setValue(value2);
      setTimeout(() => {
        if (!isInputFocused.current) setInputValue(formatInput(value2));
      });
    },
    [setValue, formatInput]
  );
  const onEyeDropperClick = (0, import_react171.useCallback)(
    async (ev) => {
      var _a2;
      ev.preventDefault();
      ev.stopPropagation();
      try {
        const { sRGBHex } = (_a2 = await onEyeDropperOpen()) != null ? _a2 : {};
        if (!sRGBHex) return;
        onColorSelectorChange(sRGBHex);
        onChangeEnd == null ? void 0 : onChangeEnd(sRGBHex);
      } catch {
      }
    },
    [onEyeDropperOpen, onColorSelectorChange, onChangeEnd]
  );
  useOutsideClick({
    ref: containerRef,
    handler: onClose,
    enabled: isOpen && closeOnBlur
  });
  useUpdateEffect(() => {
    if (!format || !value) return;
    formatRef.current = format;
    const nextValue = convertColor(value, fallbackValue)(format);
    if (!nextValue) return;
    setInputValue(formatInput(nextValue));
    setValue(nextValue);
  }, [format]);
  useUpdateEffect(() => {
    if (isInputFocused.current || !valueProp) return;
    setInputValue(formatInput(valueProp));
  }, [valueProp]);
  const getPopoverProps = (0, import_react171.useCallback)(
    (props2) => ({
      matchWidth: isColorSelectorFull,
      ...rest,
      ...props2,
      isOpen,
      onOpen,
      onClose,
      placement,
      duration,
      trigger: "never",
      closeOnButton: false
    }),
    [isColorSelectorFull, duration, onClose, onOpen, placement, rest, isOpen]
  );
  const getContainerProps = (0, import_react171.useCallback)(
    (props2 = {}, ref = null) => ({
      ref: mergeRefs(containerRef, ref),
      ...containerProps,
      ...props2,
      ...formControlProps,
      onClick: handlerAll(props2.onClick, rest.onClick, onContainerClick),
      onBlur: handlerAll(props2.onBlur, rest.onBlur, onContainerBlur)
    }),
    [containerProps, formControlProps, onContainerBlur, onContainerClick, rest]
  );
  const getFieldProps = (0, import_react171.useCallback)(
    (props2 = {}, ref = null) => ({
      ref: mergeRefs(fieldRef, ref),
      tabIndex: !allowInput ? -1 : 0,
      ...inputProps,
      ...props2,
      style: {
        ...props2.style,
        ...!allowInput ? { pointerEvents: "none" } : {}
      },
      value: inputValue,
      "data-active": dataAttr(isOpen),
      "aria-expanded": dataAttr(isOpen),
      onFocus: handlerAll(props2.onFocus, rest.onFocus, onInputFocus),
      onKeyDown: handlerAll(props2.onKeyDown, rest.onKeyDown, onInputKeyDown),
      onChange: handlerAll(props2.onChange, onInputChange),
      onBlur: handlerAll(props2.onFocus, onInputBlur)
    }),
    [
      allowInput,
      inputProps,
      inputValue,
      isOpen,
      rest,
      onInputFocus,
      onInputKeyDown,
      onInputChange,
      onInputBlur
    ]
  );
  const getEyeDropperProps = (0, import_react171.useCallback)(
    (props2 = {}, ref = null) => ({
      disabled,
      "aria-label": "Pick a color",
      ...props2,
      ref,
      style: { ...props2.style, pointerEvents: readOnly ? "none" : void 0 },
      onClick: handlerAll(props2.onClick, onEyeDropperClick)
    }),
    [disabled, onEyeDropperClick, readOnly]
  );
  const getSelectorProps = (0, import_react171.useCallback)(
    (props2) => ({
      ...formControlProps,
      ...props2,
      value,
      defaultValue: defaultColor,
      fallbackValue,
      onChange: onColorSelectorChange,
      onChangeStart,
      onChangeEnd,
      onSwatchClick: handlerAll(
        onSwatchClick,
        closeOnSelectSwatch ? onClose : void 0
      ),
      format: formatRef.current,
      withPicker,
      withChannel,
      withResult,
      withEyeDropper: withColorSelectorEyeDropper,
      swatchesLabel,
      swatches,
      swatchesColumns,
      variant: colorSelectorVariant,
      size: colorSelectorSize,
      colorScheme: colorSelectorColorScheme
    }),
    [
      formControlProps,
      value,
      fallbackValue,
      defaultColor,
      onColorSelectorChange,
      onChangeStart,
      onChangeEnd,
      onSwatchClick,
      onClose,
      closeOnSelectSwatch,
      formatRef,
      withPicker,
      withChannel,
      withResult,
      withColorSelectorEyeDropper,
      swatchesLabel,
      swatches,
      swatchesColumns,
      colorSelectorColorScheme,
      colorSelectorSize,
      colorSelectorVariant
    ]
  );
  return {
    value,
    eyeDropperSupported,
    allowInput,
    onClose,
    getPopoverProps,
    getContainerProps,
    getFieldProps,
    getSelectorProps,
    getEyeDropperProps
  };
};

// node_modules/@yamada-ui/color-picker/dist/chunk-KKUDFHCJ.mjs
var import_react172 = __toESM(require_react(), 1);
var defaultOverlays = (withShadow) => {
  let overlays = [
    ([h]) => ({
      bg: `hsl(${h}, 100%, 50%)`,
      bgImage: "linear-gradient(0deg, #000, transparent), linear-gradient(90deg, #fff, transparent)"
    })
  ];
  if (withShadow)
    overlays = [
      ...overlays,
      {
        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`
      }
    ];
  return overlays;
};
var useSaturationSlider = ({
  focusThumbOnChange = true,
  ...props2
}) => {
  if (!focusThumbOnChange) props2.isReadOnly = true;
  let {
    id: id4,
    name,
    value: valueProp,
    defaultValue = [0, 0, 1],
    onChange: onChangeProp,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 0.01,
    thumbColor,
    required,
    disabled,
    readOnly,
    withShadow = true,
    overlays: overlaysProp = defaultOverlays(withShadow),
    ...rest
  } = useFormControlProps(props2);
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const [isDragging, setDragging] = (0, import_react172.useState)(false);
  const isInteractive = !(disabled || readOnly);
  let [h, s, v] = value;
  s = clampNumber(s, 0, 1);
  v = clampNumber(v, 0, 1);
  const containerRef = (0, import_react172.useRef)(null);
  const trackRef = (0, import_react172.useRef)(null);
  const thumbRef = (0, import_react172.useRef)(null);
  const latestRef = useLatestRef({
    value,
    step,
    isInteractive,
    eventSource: null,
    focusThumbOnChange
  });
  const thumbSize = useSize(thumbRef);
  const overlays = (0, import_react172.useMemo)(
    () => overlaysProp.map((propsOrFunc) => runIfFunc(propsOrFunc, [h, s, v])),
    [overlaysProp, h, s, v]
  );
  const getValueFromPointer = (0, import_react172.useCallback)(
    (ev) => {
      var _a, _b;
      if (!trackRef.current) return [];
      const { step: step2 } = latestRef.current;
      latestRef.current.eventSource = "pointer";
      const { bottom: bottom2, left: left2, height, width } = trackRef.current.getBoundingClientRect();
      const { clientX, clientY } = (_b = (_a = ev.touches) == null ? void 0 : _a[0]) != null ? _b : ev;
      let s2 = clampNumber((clientX - left2) / width, 0, 1);
      let v2 = clampNumber((bottom2 - clientY) / height, 0, 1);
      if (step2) {
        s2 = parseFloat(roundNumberToStep(s2, 0, step2));
        v2 = parseFloat(roundNumberToStep(v2, 0, step2));
      }
      return [s2, v2];
    },
    [latestRef]
  );
  const setValueFromPointer = (ev) => {
    const { value: value2 } = latestRef.current;
    const [nextS, nextV] = getValueFromPointer(ev);
    if (nextS == null || nextV == null) return;
    const [, s2, v2] = value2;
    if (nextS !== s2 || nextV !== v2) setValue(([h2]) => [h2, nextS, nextV]);
  };
  const focusThumb = (0, import_react172.useCallback)(() => {
    const { focusThumbOnChange: focusThumbOnChange2 } = latestRef.current;
    if (focusThumbOnChange2) setTimeout(() => {
      var _a;
      return (_a = thumbRef.current) == null ? void 0 : _a.focus();
    });
  }, [latestRef]);
  const constrain = (0, import_react172.useCallback)(
    ([s2, v2]) => {
      const { isInteractive: isInteractive2 } = latestRef.current;
      if (!isInteractive2) return;
      s2 = clampNumber(s2, 0, 1);
      v2 = clampNumber(v2, 0, 1);
      setValue(([h2]) => [h2, s2, v2]);
    },
    [latestRef, setValue]
  );
  const onKeyDown = (0, import_react172.useCallback)(
    (ev) => {
      const actions = {
        ArrowRight: () => constrain([s + step, v]),
        ArrowUp: () => constrain([s, v + step]),
        ArrowLeft: () => constrain([s - step, v]),
        ArrowDown: () => constrain([s, v - step])
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action(ev);
      latestRef.current.eventSource = "keyboard";
    },
    [latestRef, constrain, s, v, step]
  );
  usePanEvent(containerRef, {
    onSessionStart: (ev) => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(true);
      focusThumb();
      setValueFromPointer(ev);
      onChangeStart(value2);
    },
    onSessionEnd: () => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(false);
      onChangeEnd(value2);
    },
    onMove: (ev) => {
      const { isInteractive: isInteractive2 } = latestRef.current;
      if (!isInteractive2) return;
      setValueFromPointer(ev);
    }
  });
  useUpdateEffect(() => {
    const { eventSource, value: value2 } = latestRef.current;
    if (eventSource === "keyboard") onChangeEnd(value2);
  }, [value, onChangeEnd]);
  const getContainerProps = (0, import_react172.useCallback)(
    (props22 = {}, ref = null) => ({
      ...props22,
      ...omitObject(rest, ["aria-readonly"]),
      ref: mergeRefs(ref, containerRef),
      tabIndex: -1
    }),
    [rest]
  );
  const getInnerProps = (0, import_react172.useCallback)(
    (props22 = {}, ref = null) => {
      const { width: w } = thumbSize != null ? thumbSize : { width: 0 };
      const style = {
        ...props22.style,
        ...rest.style,
        padding: `${w / 2}px`
      };
      return {
        ...props22,
        ref,
        style
      };
    },
    [rest, thumbSize]
  );
  const getInputProps = (0, import_react172.useCallback)(
    (props22 = {}, ref = null) => ({
      ...pickObject(rest, formControlProperties),
      ...props22,
      id: id4,
      ref,
      type: "hidden",
      name,
      value: [h, s, v].toString(),
      required,
      disabled,
      readOnly
    }),
    [disabled, id4, name, readOnly, required, rest, h, s, v]
  );
  const getTrackProps = (0, import_react172.useCallback)(
    (props22 = {}, ref = null) => ({
      ...pickObject(
        rest,
        getFormControlProperties({ omit: ["aria-readonly"] })
      ),
      ...props22,
      ref: mergeRefs(ref, trackRef)
    }),
    [rest]
  );
  const getThumbProps = (0, import_react172.useCallback)(
    (props22 = {}, ref = null) => {
      const { width, height } = thumbSize != null ? thumbSize : { width: 0, height: 0 };
      const x = s * 100;
      const y = v * 100;
      const style = {
        ...props22.style,
        position: "absolute",
        userSelect: "none",
        touchAction: "none",
        left: `calc(${x}% - ${width / 2}px)`,
        bottom: `calc(${y}% - ${height / 2}px)`
      };
      return {
        "aria-label": "Saturation and brightness thumb",
        bg: thumbColor != null ? thumbColor : hsvTo([h, s, v])(),
        ...pickObject(rest, formControlProperties),
        ...props22,
        ref: mergeRefs(ref, thumbRef),
        tabIndex: isInteractive && focusThumbOnChange ? 0 : void 0,
        role: "slider",
        "aria-valuenow": s,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `saturation ${s}, brightness ${v}`,
        "data-active": dataAttr(isDragging && focusThumbOnChange),
        onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
        onFocus: handlerAll(props22.onFocus, rest.onFocus),
        onBlur: handlerAll(props22.onBlur, rest.onBlur),
        style
      };
    },
    [
      h,
      s,
      v,
      thumbColor,
      focusThumbOnChange,
      isDragging,
      isInteractive,
      onKeyDown,
      rest,
      thumbSize
    ]
  );
  return {
    value,
    overlays,
    getContainerProps,
    getInnerProps,
    getTrackProps,
    getInputProps,
    getThumbProps
  };
};

// node_modules/@yamada-ui/color-picker/dist/chunk-VZQ3PFLT.mjs
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var SaturationSlider2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle(
      "SaturationSlider",
      props2
    );
    const {
      className,
      ratio = 16 / 9,
      innerProps,
      inputProps,
      trackProps,
      thumbProps,
      __css,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      overlays,
      getContainerProps,
      getInnerProps,
      getTrackProps,
      getInputProps,
      getThumbProps
    } = useSaturationSlider(computedProps);
    const css4 = {
      position: "relative",
      _before: {
        content: `""`,
        display: "block",
        h: 0,
        pb: replaceObject(ratio, (r2) => `${1 / r2 * 100}%`)
      },
      "& > *": {
        position: "absolute",
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        w: "100%",
        h: "100%"
      },
      ...styles2.container,
      ...__css
    };
    return (0, import_jsx_runtime166.jsx)(
      ui.div,
      {
        className: cx("ui-saturation-slider", className),
        __css: css4,
        ...getContainerProps(),
        children: (0, import_jsx_runtime166.jsxs)(
          ui.div,
          {
            className: cx("ui-saturation-slider__inner", className),
            __css: { ...styles2.inner },
            ...getInnerProps(innerProps),
            children: [
              (0, import_jsx_runtime166.jsx)(ui.input, { ...getInputProps(inputProps, ref) }),
              overlays.map((props22, index) => (0, import_jsx_runtime166.jsx)(
                ui.div,
                {
                  className: "ui-saturation-slider__overlay",
                  __css: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    ...styles2.overlay
                  },
                  ...props22
                },
                index
              )),
              (0, import_jsx_runtime166.jsx)(
                ui.div,
                {
                  className: "ui-saturation-slider__track",
                  __css: {
                    position: "relative",
                    w: "100%",
                    h: "100%",
                    ...styles2.track
                  },
                  ...getTrackProps(trackProps),
                  children: (0, import_jsx_runtime166.jsx)(
                    ui.div,
                    {
                      className: "ui-saturation-slider__thumb",
                      __css: { ...styles2.thumb },
                      ...getThumbProps(thumbProps)
                    }
                  )
                }
              )
            ]
          }
        )
      }
    );
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-RJYO5QKN.mjs
var import_react173 = __toESM(require_react(), 1);
var convertHsla = (value, fallback) => {
  var _a;
  let [h, s, l, a] = (_a = parseToHsla2(value, fallback)) != null ? _a : [0, 0, 1, 1];
  if (a > 1) a = 1;
  return { h, s, l, a };
};
var convertRgba = (value, fallback) => {
  var _a;
  let [r2, g, b, a] = (_a = parseToRgba2(value, fallback)) != null ? _a : [255, 255, 255, 1];
  if (r2 > 255) r2 = 255;
  if (g > 255) g = 255;
  if (b > 255) b = 255;
  if (a > 1) a = 1;
  return { r: r2, g, b, a };
};
var convertHsva = (value, fallback) => {
  const [h, s, v, a] = parseToHsv(value, fallback);
  return { h, s, v, a };
};
var [ColorSelectorProvider, useColorSelectorContext] = createContext2({
  name: "ColorSelectorContext",
  errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in "<ColorSelector />"`
});
var useColorSelector = ({
  isInvalid,
  ...props2
}) => {
  let {
    id: id4,
    name,
    value: valueProp,
    defaultValue,
    fallbackValue,
    onChange: onChangeProp,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    format: formatProp,
    required,
    disabled,
    readOnly,
    onSwatchClick,
    ...rest
  } = useFormControlProps({ isInvalid, ...props2 });
  const onChangeStartRef = useCallbackRef(onChangeStartProp);
  const onChangeEndRef = useCallbackRef(onChangeEndProp);
  const { supported: eyeDropperSupported, onOpen } = useEyeDropper();
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : fallbackValue,
    onChange: onChangeProp
  });
  const format = (0, import_react173.useMemo)(
    () => formatProp != null ? formatProp : calcFormat(value != null ? value : "#ffffff"),
    [value, formatProp]
  );
  const resolvedValue = convertColor(value, "#ffffff")(format);
  const timeoutId = (0, import_react173.useRef)(void 0);
  const isDraggingRef = (0, import_react173.useRef)(false);
  const [parsedValue, setParsedValue] = (0, import_react173.useState)(
    convertHsva(resolvedValue, fallbackValue)
  );
  const { h, s, v, a } = parsedValue;
  const withAlpha = format.endsWith("a");
  const isInteractive = !(disabled || readOnly);
  const channels = (0, import_react173.useMemo)(() => {
    if (resolvedValue.startsWith("hsl")) {
      const { h: h2, s: s2, l, a: a2 } = convertHsla(resolvedValue, fallbackValue);
      let channels2 = [
        { label: "H", space: "h", value: Math.round(h2), min: 0, max: 360 },
        {
          label: "S(%)",
          space: "s",
          value: Math.round(s2 * 100),
          min: 0,
          max: 100
        },
        {
          label: "L(%)",
          space: "l",
          value: Math.round(l * 100),
          min: 0,
          max: 100
        }
      ];
      if (withAlpha) {
        channels2 = [
          ...channels2,
          {
            label: "A(%)",
            space: "a",
            value: Math.round(a2 * 100),
            min: 0,
            max: 100
          }
        ];
      }
      return channels2;
    } else {
      const { r: r2, g, b, a: a2 } = convertRgba(resolvedValue, fallbackValue);
      let channels2 = [
        { label: "R", space: "r", value: Math.round(r2), min: 0, max: 255 },
        { label: "G", space: "g", value: Math.round(g), min: 0, max: 255 },
        { label: "B", space: "b", value: Math.round(b), min: 0, max: 255 }
      ];
      if (withAlpha) {
        channels2 = [
          ...channels2,
          {
            label: "A(%)",
            space: "a",
            value: Math.round(a2 * 100),
            min: 0,
            max: 100
          }
        ];
      }
      return channels2;
    }
  }, [resolvedValue, withAlpha, fallbackValue]);
  const onChange = (0, import_react173.useCallback)(
    (value2) => {
      if (isString(value2)) {
        setParsedValue(convertHsva(value2, fallbackValue));
      } else {
        setParsedValue((prev2) => ({ ...prev2, ...value2 }));
      }
    },
    [fallbackValue]
  );
  const onChangeStart = (0, import_react173.useCallback)(
    (value2) => {
      window.clearTimeout(timeoutId.current);
      isDraggingRef.current = true;
      const { h: h2, s: s2, v: v2, a: a2 } = { ...parsedValue, ...value2 };
      const nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(format);
      if (nextValue) onChangeStartRef(nextValue);
    },
    [onChangeStartRef, fallbackValue, parsedValue, format]
  );
  const onChangeEnd = (0, import_react173.useCallback)(
    (value2) => {
      window.clearTimeout(timeoutId.current);
      timeoutId.current = window.setTimeout(() => {
        isDraggingRef.current = false;
      }, 200);
      let nextValue;
      if (isString(value2)) {
        nextValue = convertColor(value2, fallbackValue)(format);
      } else {
        const { h: h2, s: s2, v: v2, a: a2 } = { ...parsedValue, ...value2 };
        nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(format);
      }
      if (nextValue) onChangeEndRef(nextValue);
    },
    [onChangeEndRef, fallbackValue, parsedValue, format]
  );
  const onChannelChange = (0, import_react173.useCallback)(
    (ev, space) => {
      let n = Math.floor(parseFloat(ev.target.value));
      if (isNaN(n)) n = 0;
      if (["s", "l", "a"].includes(space)) n = n / 100;
      let nextValue;
      if (resolvedValue.startsWith("hsl")) {
        const { h: h2, s: s2, l, a: a2 } = Object.assign(
          convertHsla(resolvedValue, fallbackValue),
          { [space]: n }
        );
        nextValue = hslaTo([h2, s2, l, a2], fallbackValue)(format);
      } else {
        const { r: r2, g, b, a: a2 } = Object.assign(
          convertRgba(resolvedValue, fallbackValue),
          { [space]: n }
        );
        nextValue = rgbaTo([r2, g, b, a2], fallbackValue)(format);
      }
      if (!nextValue) return;
      onChange(nextValue);
      onChangeEnd(nextValue);
    },
    [resolvedValue, onChange, onChangeEnd, fallbackValue, format]
  );
  const onEyeDropperClick = (0, import_react173.useCallback)(async () => {
    var _a;
    try {
      const { sRGBHex } = (_a = await onOpen()) != null ? _a : {};
      if (!sRGBHex) return;
      onChange(sRGBHex);
      onChangeEnd(sRGBHex);
    } catch {
    }
  }, [onOpen, onChange, onChangeEnd]);
  useUpdateEffect(() => {
    const nextValue = hsvTo([h, s, v, a], fallbackValue)(format);
    if (nextValue) setValue(nextValue);
  }, [h, s, v, a]);
  useUpdateEffect(() => {
    if (isDraggingRef.current) return;
    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue));
  }, [valueProp]);
  useUpdateEffect(() => {
    if (!format || !value) return;
    const nextValue = convertColor(value, fallbackValue)(format);
    if (nextValue) setValue(nextValue);
  }, [format]);
  const getContainerProps = (props22 = {}, ref = null) => ({
    ...props22,
    ref,
    ...omitObject(rest, ["aria-readonly"])
  });
  const getInputProps = (0, import_react173.useCallback)(
    (props22 = {}, ref = null) => ({
      ...pickObject(rest, formControlProperties),
      ...props22,
      id: id4,
      ref,
      type: "hidden",
      name,
      value: resolvedValue,
      required,
      disabled,
      readOnly
    }),
    [disabled, id4, name, readOnly, required, rest, resolvedValue]
  );
  const getSaturationSliderProps = (0, import_react173.useCallback)(
    (props22 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props22,
      ref,
      value: [h, s, v],
      onChange: handlerAll(props22.onChange, ([, s2, v2]) => onChange({ s: s2, v: v2 })),
      onChangeStart: handlerAll(
        props22.onChangeStart,
        ([, s2, v2]) => onChangeStart({ s: s2, v: v2 })
      ),
      onChangeEnd: handlerAll(
        props22.onChangeEnd,
        ([, s2, v2]) => onChangeEnd({ s: s2, v: v2 })
      )
    }),
    [
      required,
      disabled,
      readOnly,
      isInvalid,
      h,
      s,
      v,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getHueSliderProps = (0, import_react173.useCallback)(
    (props22 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props22,
      ref,
      value: h,
      onChange: handlerAll(props22.onChange, (h2) => onChange({ h: h2 })),
      onChangeStart: handlerAll(
        props22.onChangeStart,
        (h2) => onChangeStart({ h: h2 })
      ),
      onChangeEnd: handlerAll(props22.onChangeEnd, (h2) => onChangeEnd({ h: h2 }))
    }),
    [
      required,
      disabled,
      readOnly,
      isInvalid,
      h,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getAlphaSliderProps = (0, import_react173.useCallback)(
    (props22 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props22,
      ref,
      value: a,
      color: hsvTo([h, s, v, a], fallbackValue)(format),
      onChange: handlerAll(props22.onChange, (a2) => onChange({ a: a2 })),
      onChangeStart: handlerAll(
        props22.onChangeStart,
        (a2) => onChangeStart({ a: a2 })
      ),
      onChangeEnd: handlerAll(props22.onChangeEnd, (a2) => onChangeEnd({ a: a2 }))
    }),
    [
      fallbackValue,
      required,
      disabled,
      readOnly,
      isInvalid,
      format,
      h,
      s,
      v,
      a,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getChannelProps = (0, import_react173.useCallback)(
    ({ space, ...props22 }, ref = null) => {
      return {
        required,
        disabled,
        readOnly,
        isInvalid,
        ...props22,
        ref,
        type: "number",
        step: 1,
        onChange: handlerAll(
          props22.onChange,
          (ev) => onChannelChange(ev, space)
        )
      };
    },
    [required, disabled, readOnly, isInvalid, onChannelChange]
  );
  const getEyeDropperProps = (0, import_react173.useCallback)(
    (props22 = {}, ref = null) => ({
      disabled,
      "aria-label": "Pick a color",
      ...props22,
      ref,
      onClick: handlerAll(props22.onClick, onEyeDropperClick)
    }),
    [disabled, onEyeDropperClick]
  );
  const getSwatchProps = (0, import_react173.useCallback)(
    ({ color: color2, ...props22 } = {}, ref = null) => ({
      "aria-label": `Select ${color2} as the color`,
      disabled,
      readOnly,
      ...props22,
      ref,
      color: color2,
      onClick: handlerAll(props22.onClick, () => {
        if (!isString(color2)) return;
        onSwatchClick == null ? void 0 : onSwatchClick(color2);
        onChange(color2);
        onChangeEnd(color2);
      })
    }),
    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd]
  );
  return {
    value: resolvedValue,
    onChange,
    eyeDropperSupported,
    withAlpha,
    isInteractive,
    disabled,
    readOnly,
    channels,
    getContainerProps,
    getInputProps,
    getSaturationSliderProps,
    getHueSliderProps,
    getAlphaSliderProps,
    getEyeDropperProps,
    getChannelProps,
    getSwatchProps
  };
};

// node_modules/@yamada-ui/color-picker/dist/chunk-JQNM475T.mjs
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var ColorSelectorEyeDropper = forwardRef22(({ className, ...rest }, ref) => {
  const { getEyeDropperProps, readOnly, size, styles: styles2 } = useColorSelectorContext();
  const css4 = {
    h: "auto",
    minW: "auto",
    pointerEvents: readOnly ? "none" : void 0,
    ...styles2.eyeDropper
  };
  return (0, import_jsx_runtime167.jsx)(
    IconButton,
    {
      className: cx("ui-color-selector__eye-dropper", className),
      variant: "outline",
      size,
      __css: css4,
      ...getEyeDropperProps(rest, ref),
      children: (0, import_jsx_runtime167.jsx)(EyeDropperIcon, { className: "ui-color-selector__eye-dropper__icon" })
    }
  );
});
var EyeDropperIcon = ({ ...rest }) => {
  return (0, import_jsx_runtime167.jsxs)(
    Icon,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...rest,
      children: [
        (0, import_jsx_runtime167.jsx)("path", { d: "m2 22 1-1h3l9-9" }),
        (0, import_jsx_runtime167.jsx)("path", { d: "M3 21v-3l9-9" }),
        (0, import_jsx_runtime167.jsx)("path", { d: "m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.4.4a2.1 2.1 0 1 1-3 3l-3.8-3.8a2.1 2.1 0 1 1 3-3l.4.4Z" })
      ]
    }
  );
};

// node_modules/@yamada-ui/color-picker/dist/chunk-WRHKYN3W.mjs
var import_react174 = __toESM(require_react(), 1);
var useColorSlider = ({
  focusThumbOnChange = true,
  ...props2
}) => {
  if (!focusThumbOnChange) props2.isReadOnly = true;
  let {
    id: id4,
    name,
    value: valueProp,
    defaultValue,
    min: min2 = 0,
    max: max2,
    step = 1,
    onChange: onChangeProp,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    thumbColor,
    required,
    disabled,
    readOnly,
    ...rest
  } = useFormControlProps(props2);
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const [computedValue, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : min2 + (max2 - min2) / 2,
    onChange: onChangeProp
  });
  const value = clampNumber(computedValue, min2, max2);
  const thumbPercent = valueToPercent(value, min2, max2);
  const [isDragging, setDragging] = (0, import_react174.useState)(false);
  const isInteractive = !(disabled || readOnly);
  const oneStep = step || (max2 - min2) / 100;
  const tenStep = (max2 - min2) / 10;
  const containerRef = (0, import_react174.useRef)(null);
  const trackRef = (0, import_react174.useRef)(null);
  const thumbRef = (0, import_react174.useRef)(null);
  const latestRef = useLatestRef({
    value,
    min: min2,
    max: max2,
    step,
    isInteractive,
    eventSource: null,
    focusThumbOnChange
  });
  const thumbSize = useSize(thumbRef);
  const getValueFromPointer = (0, import_react174.useCallback)(
    (ev) => {
      var _a, _b;
      if (!trackRef.current) return;
      const { min: min22, max: max22, step: step2 } = latestRef.current;
      latestRef.current.eventSource = "pointer";
      const { left: left2, width } = trackRef.current.getBoundingClientRect();
      const { clientX } = (_b = (_a = ev.touches) == null ? void 0 : _a[0]) != null ? _b : ev;
      let percent2 = (clientX - left2) / width;
      let nextValue = percentToValue(percent2, min22, max22);
      if (step2) nextValue = parseFloat(roundNumberToStep(nextValue, min22, step2));
      nextValue = clampNumber(nextValue, min22, max22);
      return nextValue;
    },
    [latestRef]
  );
  const setValueFromPointer = (ev) => {
    const { value: value2 } = latestRef.current;
    const nextValue = getValueFromPointer(ev);
    if (nextValue != null && nextValue !== value2) setValue(nextValue);
  };
  const focusThumb = (0, import_react174.useCallback)(() => {
    const { focusThumbOnChange: focusThumbOnChange2 } = latestRef.current;
    if (focusThumbOnChange2) setTimeout(() => {
      var _a;
      return (_a = thumbRef.current) == null ? void 0 : _a.focus();
    });
  }, [latestRef]);
  const constrain = (0, import_react174.useCallback)(
    (value2) => {
      const { isInteractive: isInteractive2, min: min22, max: max22 } = latestRef.current;
      if (!isInteractive2) return;
      value2 = parseFloat(roundNumberToStep(value2, min22, oneStep));
      value2 = clampNumber(value2, min22, max22);
      setValue(value2);
    },
    [setValue, latestRef, oneStep]
  );
  const stepUp = (0, import_react174.useCallback)(
    (step2 = oneStep) => constrain(value + step2),
    [constrain, value, oneStep]
  );
  const stepDown = (0, import_react174.useCallback)(
    (step2 = oneStep) => constrain(value - step2),
    [constrain, value, oneStep]
  );
  const onKeyDown = (0, import_react174.useCallback)(
    (ev) => {
      const { min: min22, max: max22 } = latestRef.current;
      const actions = {
        ArrowRight: () => stepUp(),
        ArrowUp: () => stepUp(),
        ArrowLeft: () => stepDown(),
        ArrowDown: () => stepDown(),
        PageUp: () => stepUp(tenStep),
        PageDown: () => stepDown(tenStep),
        Home: () => constrain(min22),
        End: () => constrain(max22)
      };
      const action = actions[ev.key];
      if (!action) return;
      ev.preventDefault();
      ev.stopPropagation();
      action(ev);
      latestRef.current.eventSource = "keyboard";
    },
    [constrain, latestRef, stepDown, stepUp, tenStep]
  );
  usePanEvent(containerRef, {
    onSessionStart: (ev) => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(true);
      focusThumb();
      setValueFromPointer(ev);
      onChangeStart(value2);
    },
    onSessionEnd: () => {
      const { isInteractive: isInteractive2, value: value2 } = latestRef.current;
      if (!isInteractive2) return;
      setDragging(false);
      onChangeEnd(value2);
    },
    onMove: (ev) => {
      const { isInteractive: isInteractive2 } = latestRef.current;
      if (!isInteractive2) return;
      setValueFromPointer(ev);
    }
  });
  useUpdateEffect(() => {
    const { eventSource, value: value2 } = latestRef.current;
    if (eventSource === "keyboard") onChangeEnd(value2);
  }, [value, onChangeEnd]);
  const getContainerProps = (0, import_react174.useCallback)(
    (props22 = {}, ref = null) => {
      const { width: w } = thumbSize != null ? thumbSize : { width: 0 };
      const style = {
        ...props22.style,
        ...rest.style,
        paddingInline: `${w / 2}px`
      };
      return {
        ...props22,
        ...omitObject(rest, ["aria-readonly"]),
        ref: mergeRefs(ref, containerRef),
        tabIndex: -1,
        style
      };
    },
    [rest, thumbSize]
  );
  const getInputProps = (0, import_react174.useCallback)(
    (props22 = {}, ref = null) => ({
      ...pickObject(rest, formControlProperties),
      ...props22,
      id: id4,
      ref,
      type: "hidden",
      name,
      value,
      required,
      disabled,
      readOnly
    }),
    [disabled, id4, name, readOnly, required, rest, value]
  );
  const getTrackProps = (0, import_react174.useCallback)(
    (props22 = {}, ref = null) => ({
      ...pickObject(
        rest,
        getFormControlProperties({ omit: ["aria-readonly"] })
      ),
      ...props22,
      ref: mergeRefs(ref, trackRef)
    }),
    [rest]
  );
  const getThumbProps = (0, import_react174.useCallback)(
    (props22 = {}, ref = null) => {
      const n = thumbPercent;
      const { width: w } = thumbSize != null ? thumbSize : { width: 0 };
      const style = {
        ...props22.style,
        position: "absolute",
        userSelect: "none",
        touchAction: "none",
        left: `calc(${n}% - ${w / 2}px)`
      };
      return {
        "aria-label": "Slider thumb",
        bg: thumbColor != null ? thumbColor : `hsl(${value}, 100%, 50%)`,
        ...pickObject(rest, formControlProperties),
        ...props22,
        ref: mergeRefs(ref, thumbRef),
        tabIndex: isInteractive && focusThumbOnChange ? 0 : void 0,
        role: "slider",
        "aria-valuenow": value,
        "aria-valuemin": min2,
        "aria-valuemax": max2,
        "data-active": dataAttr(isDragging && focusThumbOnChange),
        onKeyDown: handlerAll(props22.onKeyDown, onKeyDown),
        onFocus: handlerAll(props22.onFocus, rest.onFocus),
        onBlur: handlerAll(props22.onBlur, rest.onBlur),
        style
      };
    },
    [
      thumbColor,
      focusThumbOnChange,
      isDragging,
      isInteractive,
      min2,
      max2,
      onKeyDown,
      rest,
      thumbPercent,
      thumbSize,
      value
    ]
  );
  return {
    value,
    getContainerProps,
    getTrackProps,
    getInputProps,
    getThumbProps
  };
};

// node_modules/@yamada-ui/color-picker/dist/chunk-C2WB3OWR.mjs
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var defaultOverlays2 = (min2, max2, withShadow) => {
  let overlays = [
    {
      bgGradient: `linear(to-r, ${[...Array(7)].map(
        (_, index) => `hsl(${Math.round(min2 + (max2 - min2) / 6 * index)}, 100%, 50%)`
      ).join(", ")})`
    }
  ];
  if (withShadow)
    overlays = [
      ...overlays,
      {
        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`
      }
    ];
  return overlays;
};
var HueSlider2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("HueSlider", props2);
  const {
    className,
    inputProps,
    trackProps,
    thumbProps,
    min: min2 = 0,
    max: max2 = 360,
    withShadow = true,
    overlays = defaultOverlays2(min2, max2, withShadow),
    __css,
    ...computedProps
  } = omitThemeProps(mergedProps);
  const { getContainerProps, getTrackProps, getInputProps, getThumbProps } = useColorSlider({ min: min2, max: max2, step: 1, ...computedProps });
  const css4 = {
    position: "relative",
    ...styles2.container,
    ...__css
  };
  return (0, import_jsx_runtime168.jsxs)(
    ui.div,
    {
      className: cx("ui-hue-slider", className),
      __css: css4,
      ...getContainerProps(),
      children: [
        (0, import_jsx_runtime168.jsx)(ui.input, { ...getInputProps(inputProps, ref) }),
        overlays.map((props22, index) => (0, import_jsx_runtime168.jsx)(
          ui.div,
          {
            className: "ui-hue-slider__overlay",
            __css: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              ...styles2.overlay
            },
            ...props22
          },
          index
        )),
        (0, import_jsx_runtime168.jsx)(
          ui.div,
          {
            className: "ui-hue-slider__track",
            __css: { position: "relative", w: "100%", h: "100%", ...styles2.track },
            ...getTrackProps(trackProps),
            children: (0, import_jsx_runtime168.jsx)(
              ui.div,
              {
                className: "ui-hue-slider__thumb",
                __css: { ...styles2.thumb },
                ...getThumbProps(thumbProps)
              }
            )
          }
        )
      ]
    }
  );
});

// node_modules/@yamada-ui/color-picker/dist/chunk-WMK2LEF6.mjs
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var defaultOverlays3 = (color2, min2, max2, withShadow) => {
  let overlays = [
    {
      bgImage: "linear-gradient(45deg, $checkers 25%, transparent 25%), linear-gradient(-45deg, $checkers 25%, transparent 25%), linear-gradient(45deg, transparent 75%, $checkers 75%), linear-gradient(-45deg, $body 75%, $checkers 75%)",
      bgSize: `8px 8px`,
      bgPosition: `0 0, 0 4px, 4px -4px, -4px 0`,
      var: [
        {
          name: "checkers",
          token: "colors",
          value: ["blackAlpha.300", "whiteAlpha.300"]
        },
        {
          name: "body",
          token: "colors",
          value: ["whiteAlpha.500", "blackAlpha.500"]
        }
      ]
    },
    {
      bgGradient: `linear(to-r, ${convertColor(color2)("hex") + alphaToHex(min2)}, ${convertColor(color2)("hex") + alphaToHex(max2)})`
    }
  ];
  if (withShadow)
    overlays = [
      ...overlays,
      {
        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`
      }
    ];
  return overlays;
};
var AlphaSlider2 = forwardRef22(
  (props2, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("AlphaSlider", props2);
    const {
      className,
      inputProps,
      trackProps,
      thumbProps,
      color: color2 = "#ffffff",
      min: min2 = 0,
      max: max2 = 1,
      withShadow = true,
      overlays = defaultOverlays3(color2, min2, max2, withShadow),
      __css,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const { getContainerProps, getTrackProps, getInputProps, getThumbProps } = useColorSlider({
      min: min2,
      max: max2,
      step: 0.01,
      thumbColor: "transparent",
      ...computedProps
    });
    const css4 = {
      position: "relative",
      ...styles2.container,
      ...__css
    };
    return (0, import_jsx_runtime169.jsxs)(
      ui.div,
      {
        className: cx("ui-alpha-slider", className),
        __css: css4,
        ...getContainerProps(),
        children: [
          (0, import_jsx_runtime169.jsx)(ui.input, { ...getInputProps(inputProps, ref) }),
          overlays.map((props22, index) => (0, import_jsx_runtime169.jsx)(
            ui.div,
            {
              className: "ui-alpha-slider__overlay",
              __css: {
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                ...styles2.overlay
              },
              ...props22
            },
            index
          )),
          (0, import_jsx_runtime169.jsx)(
            ui.div,
            {
              className: "ui-alpha-slider__track",
              __css: {
                position: "relative",
                w: "100%",
                h: "100%",
                ...styles2.track
              },
              ...getTrackProps(trackProps),
              children: (0, import_jsx_runtime169.jsx)(
                ui.div,
                {
                  className: "ui-alpha-slider__thumb",
                  __css: { ...styles2.thumb },
                  ...getThumbProps(thumbProps)
                }
              )
            }
          )
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-2IDWFNI5.mjs
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var ColorSelectorSliders = forwardRef22(
  ({
    className,
    hueSliderRef,
    hueSliderProps,
    alphaSliderRef,
    alphaSliderProps,
    ...rest
  }, ref) => {
    let { size, withAlpha, getHueSliderProps, getAlphaSliderProps, styles: styles2 } = useColorSelectorContext();
    if (size === "full") size = "lg";
    const css4 = {
      display: "flex",
      flexDirection: "column",
      ...styles2.sliders
    };
    return (0, import_jsx_runtime170.jsxs)(
      ui.div,
      {
        ref,
        className: cx("ui-color-selector__sliders", className),
        __css: css4,
        ...rest,
        children: [
          (0, import_jsx_runtime170.jsx)(
            HueSlider2,
            {
              size,
              className: "ui-color-selector__hue-slider",
              __css: { ...styles2.hueSlider },
              ...getHueSliderProps(hueSliderProps, hueSliderRef)
            }
          ),
          withAlpha ? (0, import_jsx_runtime170.jsx)(
            AlphaSlider2,
            {
              size,
              className: "ui-color-selector__alpha-slider",
              __css: { ...styles2.alphaSlider },
              ...getAlphaSliderProps(alphaSliderProps, alphaSliderRef)
            }
          ) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-JLB77W4O.mjs
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var defaultOverlays4 = (background, withShadow) => {
  let overlays = [
    {
      bgImage: "linear-gradient(45deg, $checkers 25%, transparent 25%), linear-gradient(-45deg, $checkers 25%, transparent 25%), linear-gradient(45deg, transparent 75%, $checkers 75%), linear-gradient(-45deg, $body 75%, $checkers 75%)",
      bgSize: `8px 8px`,
      bgPosition: `0 0, 0 4px, 4px -4px, -4px 0`,
      var: [
        {
          name: "checkers",
          token: "colors",
          value: ["blackAlpha.300", "whiteAlpha.300"]
        },
        {
          name: "body",
          token: "colors",
          value: ["whiteAlpha.500", "blackAlpha.500"]
        }
      ]
    },
    { background }
  ];
  if (withShadow)
    overlays = [
      ...overlays,
      {
        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`
      }
    ];
  return overlays;
};
var ColorSwatch2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("ColorSwatch", props2);
  const {
    className,
    color: color2 = "#ffffff00",
    withShadow = true,
    overlays = defaultOverlays4(color2, withShadow),
    isRounded,
    __css,
    ...rest
  } = omitThemeProps(mergedProps);
  const css4 = {
    position: "relative",
    _before: {
      content: `""`,
      display: "block",
      h: 0,
      pb: "100%"
    },
    "& > *": {
      overflow: "hidden",
      position: "absolute",
      top: "0",
      right: "0",
      bottom: "0",
      left: "0",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      w: "100%",
      h: "100%"
    },
    ...styles2.container,
    ...__css
  };
  return (0, import_jsx_runtime171.jsx)(
    ui.div,
    {
      ref,
      className: cx("ui-color-swatch", className),
      ...isRounded ? { rounded: "fallback(full, 9999px)" } : {},
      __css: css4,
      ...rest,
      children: (0, import_jsx_runtime171.jsx)(ui.div, { ...isRounded ? { rounded: "fallback(full, 9999px)" } : {}, children: overlays.map((props22, index) => (0, import_jsx_runtime171.jsx)(
        ui.div,
        {
          __css: {
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            ...styles2.overlay
          },
          ...isRounded ? { rounded: "fallback(full, 9999px)" } : {},
          ...props22
        },
        index
      )) })
    }
  );
});

// node_modules/@yamada-ui/color-picker/dist/chunk-GCD4HUDL.mjs
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var ColorSelectorBody = forwardRef22(
  ({
    className,
    withEyeDropper = true,
    withResult,
    eyeDropperRef,
    eyeDropperProps,
    hueSliderRef,
    hueSliderProps,
    alphaSliderRef,
    alphaSliderProps,
    ...rest
  }, ref) => {
    const { value, eyeDropperSupported, styles: styles2 } = useColorSelectorContext();
    const css4 = {
      display: "flex",
      w: "100%",
      ...styles2.body
    };
    return (0, import_jsx_runtime172.jsxs)(
      ui.div,
      {
        ref,
        className: cx("ui-color-selector__body", className),
        __css: css4,
        ...rest,
        children: [
          (0, import_jsx_runtime172.jsx)(
            ColorSelectorSliders,
            {
              ...{
                hueSliderRef,
                hueSliderProps,
                alphaSliderRef,
                alphaSliderProps
              }
            }
          ),
          withEyeDropper && eyeDropperSupported ? (0, import_jsx_runtime172.jsx)(ColorSelectorEyeDropper, { ref: eyeDropperRef, ...eyeDropperProps }) : null,
          withResult ? (0, import_jsx_runtime172.jsx)(
            ColorSwatch2,
            {
              className: "ui-color-selector__result",
              color: value,
              __css: { ...styles2.result }
            }
          ) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-OPW3VO2U.mjs
var import_react175 = __toESM(require_react(), 1);
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var ColorSelectorChannels = forwardRef22(({ className, channelProps, ...rest }, ref) => {
  const { withAlpha, channels, getChannelProps, styles: styles2 } = useColorSelectorContext();
  const css4 = {
    display: "grid",
    gridTemplateColumns: `repeat(${withAlpha ? "4" : "3"}, 1fr)`,
    ...styles2.channels
  };
  return (0, import_jsx_runtime173.jsx)(
    ui.div,
    {
      ref,
      className: cx("ui-color-selector__channels", className),
      __css: css4,
      ...rest,
      children: channels.map(({ label, space, value, min: min2, max: max2 }) => (0, import_jsx_runtime173.jsx)(
        ColorSelectorChannel,
        {
          channelLabel: label,
          ...getChannelProps({ ...channelProps, space, value, min: min2, max: max2 })
        },
        label
      ))
    }
  );
});
var ColorSelectorChannel = forwardRef22(({ className, channelLabel, ...rest }, ref) => {
  const id4 = (0, import_react175.useId)();
  let { size, disabled, readOnly, styles: styles2 } = useColorSelectorContext();
  if (size === "full") size = "lg";
  const css4 = { ...styles2.channel };
  return (0, import_jsx_runtime173.jsxs)(ui.div, { className: cx("ui-color-selector__channel", className), children: [
    channelLabel ? (0, import_jsx_runtime173.jsx)(
      ui.label,
      {
        htmlFor: id4,
        style: { cursor: disabled ? "not-allowed" : void 0 },
        __css: {
          display: "block",
          pointerEvents: readOnly ? "none" : void 0,
          ...styles2.channelLabel
        },
        children: channelLabel
      }
    ) : null,
    (0, import_jsx_runtime173.jsx)(Input2, { ref, id: id4, size, __css: css4, ...rest })
  ] });
});

// node_modules/@yamada-ui/color-picker/dist/chunk-UW5UBWKO.mjs
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var ColorSelectorSwatches = forwardRef22(
  ({
    className,
    swatchesLabel,
    swatches,
    swatchesContainerProps,
    swatchProps,
    swatchesColumns,
    ...rest
  }, ref) => {
    const { getSwatchProps, readOnly, styles: styles2 } = useColorSelectorContext();
    const css4 = {
      display: "grid",
      gridTemplateColumns: replaceObject(
        swatchesColumns,
        (value) => value != null ? `repeat(${value}, minmax(0, 1fr))` : void 0
      ),
      ...styles2.swatches
    };
    return (swatches == null ? void 0 : swatches.length) ? (0, import_jsx_runtime174.jsxs)(ui.div, { ...swatchesContainerProps, children: [
      swatchesLabel ? (0, import_jsx_runtime174.jsx)(
        ui.p,
        {
          className: "ui-color-selector__swatches__label",
          __css: { ...styles2.swatchesLabel },
          children: swatchesLabel
        }
      ) : null,
      (0, import_jsx_runtime174.jsx)(
        ui.div,
        {
          ref,
          className: cx("ui-color-selector__swatches", className),
          __css: css4,
          ...rest,
          children: swatches.map((color2) => (0, import_jsx_runtime174.jsx)(
            ColorSwatch2,
            {
              as: "button",
              __css: {
                boxSize: "100%",
                pointerEvents: readOnly ? "none" : void 0,
                ...styles2.swatch
              },
              ...getSwatchProps({ color: color2, ...swatchProps })
            },
            color2
          ))
        }
      )
    ] }) : null;
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-XDU3RSVW.mjs
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var ColorSelector2 = forwardRef22(
  ({ size, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("ColorSelector", {
      size,
      ...props2
    });
    const {
      className,
      children,
      withResult = true,
      withPicker = true,
      withChannel = true,
      swatches,
      swatchesColumns = 7,
      inputProps,
      withEyeDropper,
      eyeDropperRef,
      eyeDropperProps,
      saturationSliderRef,
      saturationSliderProps,
      hueSliderRef,
      hueSliderProps,
      alphaSliderRef,
      alphaSliderProps,
      swatchesLabel,
      swatchProps,
      swatchesProps,
      channelsProps,
      channelProps,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      value,
      getContainerProps,
      getInputProps,
      getSaturationSliderProps,
      ...rest
    } = useColorSelector(computedProps);
    const css4 = {
      display: "flex",
      flexDirection: "column",
      ...styles2.container
    };
    return (0, import_jsx_runtime175.jsx)(ColorSelectorProvider, { value: { styles: styles2, size, value, ...rest }, children: (0, import_jsx_runtime175.jsxs)(
      ui.div,
      {
        ref,
        className: cx("ui-color-selector", className),
        __css: css4,
        ...getContainerProps(),
        children: [
          (0, import_jsx_runtime175.jsx)(ui.input, { ...getInputProps(inputProps, ref) }),
          withPicker ? (0, import_jsx_runtime175.jsx)(
            SaturationSlider2,
            {
              size,
              className: "ui-color-selector__saturation-slider",
              __css: { ...styles2.saturationSlider },
              ...getSaturationSliderProps(
                saturationSliderProps,
                saturationSliderRef
              )
            }
          ) : null,
          withPicker ? (0, import_jsx_runtime175.jsx)(
            ColorSelectorBody,
            {
              ...{
                withResult,
                withEyeDropper,
                eyeDropperRef,
                eyeDropperProps,
                hueSliderRef,
                hueSliderProps,
                alphaSliderRef,
                alphaSliderProps
              }
            }
          ) : null,
          withPicker && withChannel ? (0, import_jsx_runtime175.jsx)(ColorSelectorChannels, { ...{ channelProps, ...channelsProps } }) : null,
          (0, import_jsx_runtime175.jsx)(
            ColorSelectorSwatches,
            {
              ...{
                swatchesLabel,
                swatches,
                swatchesColumns,
                swatchProps,
                ...swatchesProps
              }
            }
          ),
          runIfFunc(children, { value })
        ]
      }
    ) });
  }
);

// node_modules/@yamada-ui/color-picker/dist/chunk-DWY4PYII.mjs
var import_react176 = __toESM(require_react(), 1);
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var ColorPicker2 = forwardRef22(
  ({ withSwatch = true, ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("ColorPicker", {
      withSwatch,
      ...props2
    });
    let {
      className,
      children,
      withEyeDropper = true,
      color: color2,
      h,
      height,
      minH,
      minHeight,
      containerProps,
      inputProps,
      swatchProps,
      eyeDropperProps,
      saturationSliderRef,
      saturationSliderProps,
      swatchesProps,
      hueSliderRef,
      hueSliderProps,
      alphaSliderRef,
      alphaSliderProps,
      channelsProps,
      channelProps,
      portalProps = { isDisabled: true },
      ...computedProps
    } = omitThemeProps(mergedProps, ["withSwatch"]);
    const {
      value,
      allowInput,
      eyeDropperSupported,
      getPopoverProps,
      getContainerProps,
      getFieldProps,
      getSelectorProps,
      getEyeDropperProps,
      onClose,
      ...rest
    } = useColorPicker(computedProps);
    h != null ? h : h = height;
    minH != null ? minH : minH = minHeight;
    const css4 = {
      w: "100%",
      h: "fit-content",
      color: color2,
      ...styles2.container
    };
    return (0, import_jsx_runtime176.jsx)(ColorPickerProvider, { value: { styles: styles2, value, ...rest }, children: (0, import_jsx_runtime176.jsx)(Popover2, { ...getPopoverProps(), children: (0, import_jsx_runtime176.jsxs)(
      ui.div,
      {
        className: cx("ui-color-picker", className),
        __css: css4,
        ...getContainerProps(containerProps),
        children: [
          (0, import_jsx_runtime176.jsxs)(
            ui.div,
            {
              className: "ui-color-picker__inner",
              __css: {
                position: "relative",
                cursor: !allowInput ? "pointer" : void 0,
                ...styles2.inner
              },
              children: [
                withSwatch ? (0, import_jsx_runtime176.jsx)(ColorPickerSwatch, { ...swatchProps }) : null,
                (0, import_jsx_runtime176.jsx)(PopoverTrigger, { children: (0, import_jsx_runtime176.jsx)(
                  ColorPickerField,
                  {
                    h,
                    minH,
                    ...getFieldProps(inputProps, ref)
                  }
                ) }),
                eyeDropperSupported && withEyeDropper ? (0, import_jsx_runtime176.jsx)(
                  ColorPickerEyeDropper,
                  {
                    ...getEyeDropperProps(eyeDropperProps)
                  }
                ) : null
              ]
            }
          ),
          (0, import_jsx_runtime176.jsx)(Portal, { ...portalProps, children: (0, import_jsx_runtime176.jsx)(
            PopoverContent,
            {
              className: "ui-color-picker__content",
              __css: { ...styles2.content },
              children: (0, import_jsx_runtime176.jsx)(
                ColorSelector2,
                {
                  className: "ui-color-picker__picker",
                  ...getSelectorProps({
                    saturationSliderRef,
                    saturationSliderProps,
                    swatchesProps,
                    hueSliderRef,
                    hueSliderProps,
                    alphaSliderRef,
                    alphaSliderProps,
                    channelsProps,
                    channelProps
                  }),
                  children: runIfFunc(children, { value, onClose })
                }
              )
            }
          ) })
        ]
      }
    ) }) });
  }
);
var ColorPickerField = forwardRef22(
  ({ className, h, minH, ...rest }, ref) => {
    const { styles: styles2 } = useColorPickerContext();
    const css4 = {
      ps: "2rem",
      pe: "2rem",
      h,
      minH,
      display: "flex",
      alignItems: "center",
      ...styles2.field
    };
    return (0, import_jsx_runtime176.jsx)(
      ui.input,
      {
        ref,
        className: cx("ui-color-picker__field", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var ColorPickerSwatch = forwardRef22(
  ({ className, ...rest }, ref) => {
    const { value, styles: styles2 } = useColorPickerContext();
    const css4 = {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      zIndex: 2,
      ...styles2.swatch
    };
    return (0, import_jsx_runtime176.jsx)(
      ColorSwatch2,
      {
        ref,
        className: cx("ui-color-picker__swatch", className),
        __css: css4,
        color: value,
        isRounded: true,
        ...rest
      }
    );
  }
);
var ColorPickerEyeDropper = forwardRef22(
  ({ className, children, ...rest }, ref) => {
    const { styles: styles2 } = useColorPickerContext();
    const css4 = {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 1,
      ...styles2.eyeDropper
    };
    const validChildren = getValidChildren(children);
    const cloneChildren = validChildren.map(
      (child) => (0, import_react176.cloneElement)(child, {
        focusable: false,
        "aria-hidden": true,
        style: {
          maxWidth: "1em",
          maxHeight: "1em",
          color: "currentColor"
        }
      })
    );
    return (0, import_jsx_runtime176.jsx)(
      ui.button,
      {
        ref,
        className: cx("ui-color-picker__eye-dropper", className),
        __css: css4,
        ...rest,
        children: isValidElement2(children) ? cloneChildren : (0, import_jsx_runtime176.jsx)(EyeDropperIcon, { className: "ui-color-picker__eye-dropper__icon" })
      }
    );
  }
);

// node_modules/@yamada-ui/rating/dist/chunk-2YEE4YES.mjs
var import_react177 = __toESM(require_react(), 1);
var import_react178 = __toESM(require_react(), 1);
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var RatingGroup = motionForwardRef(
  ({ className, value: groupValue, items, color: color2, ...rest }, ref) => {
    const { styles: styles2, decimal, groupProps, getGroupProps } = useRatingContext();
    const computedGroupProps = runIfFunc(groupProps, groupValue);
    const css4 = { ...styles2.group };
    return (0, import_jsx_runtime177.jsx)(
      Motion,
      {
        className: cx("ui-rating__group", className),
        __css: css4,
        ...getGroupProps(
          { value: groupValue, ...computedGroupProps, ...rest },
          ref
        ),
        children: Array(items).fill(0).map((_, index) => {
          const fractionValue = decimal * (groupValue === 1 ? index : index + 1);
          const value = getRoundedValue(
            groupValue - 1 + fractionValue,
            decimal
          );
          return (0, import_jsx_runtime177.jsx)(
            RatingItem,
            {
              groupValue,
              value,
              fractionValue,
              color: color2
            },
            `${groupValue}-${fractionValue}`
          );
        })
      }
    );
  }
);
var getRoundedValue = (value, to) => {
  var _a;
  const rounded = Math.round(value / to) * to;
  const precision = ((_a = `${to}`.split(".")[1]) == null ? void 0 : _a.length) || 0;
  return Number(rounded.toFixed(precision));
};
var [RatingProvider, useRatingContext] = createContext2({
  name: "RatingContext",
  errorMessage: `useRatingContext returned is 'undefined'. Seems you forgot to wrap the components in "<Rating />"`
});
var useRating = ({
  name,
  color: color2,
  value: valueProp,
  defaultValue = 0,
  onChange: onChangeProp,
  items = 5,
  fractions = 1,
  highlightSelectedOnly = false,
  onHover,
  groupProps,
  itemProps,
  inputProps,
  emptyIcon,
  filledIcon,
  ...props2
}) => {
  let { id: id4, "aria-readonly": _isReadOnly, ...rest } = useFormControlProps(props2);
  const { disabled, readOnly } = rest;
  const containerRef = (0, import_react178.useRef)(null);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const [hoveredValue, setHoveredValue] = (0, import_react178.useState)(-1);
  const [isOutside, setIsOutside] = (0, import_react178.useState)(true);
  id4 != null ? id4 : id4 = (0, import_react178.useId)();
  name != null ? name : name = `rating-${id4}`;
  const formControlProps = pickObject(rest, formControlProperties);
  const resolvedFractions = Math.floor(fractions);
  const resolvedItems = Math.floor(items);
  const decimal = 1 / resolvedFractions;
  const roundedValue = getRoundedValue(value, decimal);
  const resolvedValue = hoveredValue !== -1 ? hoveredValue : roundedValue;
  const getHoveredValue = (0, import_react178.useCallback)(
    (x) => {
      const { left: left2, width } = containerRef.current.getBoundingClientRect();
      const itemWidth = width / resolvedItems;
      const hoveredValue2 = (x - left2) / itemWidth;
      const value2 = clampNumber(
        getRoundedValue(hoveredValue2 + decimal / 2, decimal),
        decimal,
        resolvedItems
      );
      return value2;
    },
    [decimal, resolvedItems]
  );
  const onMouseEnter = (0, import_react178.useCallback)(() => {
    if (!disabled && !readOnly) setIsOutside(false);
  }, [disabled, readOnly]);
  const onMouseLeave = (0, import_react178.useCallback)(() => {
    if (disabled || readOnly) return;
    setHoveredValue(-1);
    setIsOutside(true);
    if (hoveredValue !== -1) onHover == null ? void 0 : onHover(-1);
  }, [disabled, hoveredValue, onHover, readOnly, setHoveredValue]);
  const onTouchStart = (0, import_react178.useCallback)(
    (ev) => {
      ev.preventDefault();
      const el = ev.touches[0];
      if (!el) return;
      const value2 = getHoveredValue(el.clientX);
      setValue(value2);
    },
    [getHoveredValue, setValue]
  );
  const onTouchEnd = (0, import_react178.useCallback)((ev) => {
    ev.preventDefault();
  }, []);
  const onMouseMove = (0, import_react178.useCallback)(
    (ev) => {
      if (disabled || readOnly) return;
      const roundedValue2 = getHoveredValue(ev.clientX);
      setHoveredValue(roundedValue2);
      if (roundedValue2 !== hoveredValue) onHover == null ? void 0 : onHover(roundedValue2);
    },
    [disabled, getHoveredValue, hoveredValue, readOnly, onHover]
  );
  const getContainerProps = (0, import_react178.useCallback)(
    (props22 = {}, ref = null) => ({
      ref: mergeRefs(ref, containerRef),
      ...rest,
      ...props22,
      id: id4,
      onMouseEnter: handlerAll(
        onMouseEnter,
        props22.onMouseEnter,
        rest.onMouseEnter
      ),
      onMouseMove: handlerAll(onMouseMove, props22.onMouseMove, rest.onMouseMove),
      onMouseLeave: handlerAll(
        onMouseLeave,
        props22.onMouseLeave,
        rest.onMouseLeave
      ),
      onTouchStart: handlerAll(
        onTouchStart,
        props22.onTouchStart,
        rest.onTouchStart
      ),
      onTouchEnd: handlerAll(onTouchEnd, props22.onTouchEnd, rest.onTouchEnd)
    }),
    [
      onMouseEnter,
      onMouseLeave,
      onMouseMove,
      onTouchEnd,
      onTouchStart,
      id4,
      rest
    ]
  );
  const getGroupProps = (0, import_react178.useCallback)(
    ({ value: value2, ...props22 }, ref = null) => {
      const isActive = !readOnly && Math.ceil(hoveredValue) === value2;
      return {
        ref,
        whileTap: !disabled && !readOnly ? { y: -4 } : void 0,
        ...props22,
        tabIndex: -1,
        "data-active": dataAttr(isActive)
      };
    },
    [disabled, hoveredValue, readOnly]
  );
  const children = Array(resolvedItems).fill(0).map((_, index) => {
    const value2 = index + 1;
    return (0, import_jsx_runtime178.jsx)(
      RatingGroup,
      {
        value: value2,
        color: runIfFunc(color2, value2),
        items: index === 0 ? resolvedFractions + 1 : resolvedFractions
      },
      value2
    );
  });
  return {
    getContainerProps,
    getGroupProps,
    id: id4,
    name,
    value,
    roundedValue,
    hoveredValue,
    resolvedValue,
    isOutside,
    setValue,
    setHoveredValue,
    decimal,
    highlightSelectedOnly,
    formControlProps,
    groupProps,
    itemProps,
    inputProps,
    children,
    emptyIcon,
    filledIcon
  };
};
var useRatingItem = ({
  groupValue,
  fractionValue,
  value
}) => {
  const {
    id: id4,
    name,
    formControlProps,
    isOutside,
    highlightSelectedOnly,
    roundedValue,
    resolvedValue,
    setValue,
    setHoveredValue
  } = useRatingContext();
  const { readOnly, disabled } = formControlProps;
  const [isFocused, setFocused] = (0, import_react178.useState)(false);
  const [isFocusVisible2, setIsFocusVisible] = (0, import_react178.useState)(false);
  const isActive = value === resolvedValue;
  const isChecked = value === roundedValue;
  const isFilled = highlightSelectedOnly ? value === resolvedValue : value <= resolvedValue;
  const onBlur4 = (0, import_react178.useCallback)(() => {
    setFocused(false);
    if (isOutside) setHoveredValue(-1);
  }, [isOutside, setHoveredValue]);
  const onInputChange = (0, import_react178.useCallback)(
    (ev) => {
      if (readOnly || disabled) return;
      const value2 = parseFloat(ev.target.value);
      setHoveredValue(value2);
    },
    [disabled, readOnly, setHoveredValue]
  );
  const onChange = (0, import_react178.useCallback)(
    (value2) => {
      if (readOnly || disabled) return;
      setValue(value2);
    },
    [disabled, readOnly, setValue]
  );
  const onMouseDown = (0, import_react178.useCallback)(() => {
    if (readOnly || disabled) return;
    onChange(value);
  }, [disabled, onChange, readOnly, value]);
  const onTouchStart = (0, import_react178.useCallback)(() => {
    if (readOnly || disabled) return;
    onChange(value);
  }, [disabled, onChange, readOnly, value]);
  const getItemProps = (0, import_react178.useCallback)(
    (props2 = {}, ref = null) => {
      const zIndex = isActive ? 1 : -1;
      return {
        ref,
        htmlFor: `${id4}-${groupValue}-${value}`,
        ...formControlProps,
        ...props2,
        zIndex: fractionValue !== 1 ? zIndex : void 0,
        onMouseDown: handlerAll(onMouseDown, props2.onMouseDown),
        onTouchStart: handlerAll(onTouchStart, props2.onTouchStart),
        "data-active": dataAttr(isActive),
        "data-filled": dataAttr(isFilled),
        "data-focus": dataAttr(isFocused),
        "data-focus-visible": dataAttr(isFocused && isFocusVisible2)
      };
    },
    [
      formControlProps,
      fractionValue,
      groupValue,
      id4,
      isActive,
      isFilled,
      isFocusVisible2,
      isFocused,
      onMouseDown,
      onTouchStart,
      value
    ]
  );
  const getInputProps = (0, import_react178.useCallback)(
    (props2 = {}, ref = null) => {
      return {
        ref,
        "aria-label": `${value}`,
        ...formControlProps,
        ...props2,
        style: {
          border: "0px",
          clip: "rect(0px, 0px, 0px, 0px)",
          height: "1px",
          width: "1px",
          margin: "-1px",
          padding: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          position: "absolute"
        },
        type: "radio",
        id: `${id4}-${groupValue}-${value}`,
        name,
        value,
        checked: isChecked,
        onChange: handlerAll(onInputChange, props2.onChange),
        onFocus: handlerAll(() => setFocused(true), props2.onFocus),
        onBlur: handlerAll(onBlur4, props2.onBlur),
        onKeyDown: handlerAll(
          (ev) => ev.key === " " ? onChange(value) : void 0,
          props2.onKeyDown
        ),
        "data-active": dataAttr(isActive),
        "data-checked": dataAttr(isChecked)
      };
    },
    [
      value,
      formControlProps,
      id4,
      groupValue,
      name,
      isChecked,
      onInputChange,
      onBlur4,
      isActive,
      onChange
    ]
  );
  (0, import_react178.useEffect)(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  return {
    isActive,
    isChecked,
    isFilled,
    getItemProps,
    getInputProps
  };
};
var RatingItem = forwardRef22(
  ({ className, groupValue, value, fractionValue, color: color2, ...rest }, ref) => {
    const {
      styles: styles2,
      inputProps,
      emptyIcon = (0, import_jsx_runtime179.jsx)(StarIcon, {}),
      filledIcon = (0, import_jsx_runtime179.jsx)(StarIcon, {}),
      itemProps
    } = useRatingContext();
    const { isActive, isFilled, getInputProps, getItemProps } = useRatingItem({
      value,
      groupValue,
      fractionValue
    });
    const computedItemProps = runIfFunc(itemProps, value);
    const computedInputProps = runIfFunc(inputProps, value);
    const customColor = color2 ? {
      _filled: {
        color: isString(color2) ? [color2, color2] : color2
      }
    } : {};
    const css4 = {
      display: "block",
      lineHeight: "0",
      ...styles2.item,
      ...customColor
    };
    return (0, import_jsx_runtime179.jsxs)(import_jsx_runtime179.Fragment, { children: [
      (0, import_jsx_runtime179.jsx)(ui.input, { ...getInputProps(computedInputProps, ref) }),
      (0, import_jsx_runtime179.jsx)(
        ui.label,
        {
          className: cx("ui-rating__item", className),
          __css: css4,
          ...getItemProps({ ...computedItemProps, ...rest }),
          children: (0, import_jsx_runtime179.jsx)(
            RatingIcon,
            {
              clipPath: fractionValue !== 1 ? `inset(0 ${isActive ? 100 - fractionValue * 100 : 100}% 0 0)` : void 0,
              children: isFilled ? runIfFunc(filledIcon, groupValue) : runIfFunc(emptyIcon, groupValue)
            }
          )
        }
      )
    ] });
  }
);
var RatingIcon = ({ className, children, ...rest }) => {
  const { styles: styles2 } = useRatingContext();
  const validChildren = getValidChildren(children);
  const cloneChildren = validChildren.map(
    (child) => (0, import_react177.cloneElement)(child, {
      focusable: false,
      "aria-hidden": true,
      style: {
        maxWidth: "1em",
        maxHeight: "1em"
      }
    })
  );
  const css4 = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    ...styles2.icon
  };
  return (0, import_jsx_runtime179.jsx)(
    ui.div,
    {
      className: cx("ui-rating__item__icon", className),
      __css: css4,
      ...rest,
      children: cloneChildren
    }
  );
};
var StarIcon = ({ ...rest }) => {
  return (0, import_jsx_runtime179.jsx)(
    Icon,
    {
      viewBox: "0 0 24 24",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...rest,
      children: (0, import_jsx_runtime179.jsx)("path", { d: "M12 17.75l-6.172 3.245l1.179 -6.873l-5 -4.867l6.9 -1l3.086 -6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z" })
    }
  );
};

// node_modules/@yamada-ui/rating/dist/chunk-IQ475QUX.mjs
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var Rating2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Rating", props2);
  const { className, ...computedProps } = omitThemeProps(mergedProps);
  const { getContainerProps, children, ...rest } = useRating(computedProps);
  const css4 = { display: "flex", ...styles2.container };
  return (0, import_jsx_runtime180.jsx)(RatingProvider, { value: { styles: styles2, ...rest }, children: (0, import_jsx_runtime180.jsx)(
    ui.div,
    {
      className: cx("ui-rating", className),
      __css: css4,
      ...getContainerProps({}, ref),
      children
    }
  ) });
});

// node_modules/@yamada-ui/stat/dist/chunk-R7OLUTS7.mjs
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var StatIcon = forwardRef22(
  ({ className, type = "increase", ...rest }, ref) => {
    const styles2 = useStat();
    const css4 = { ...styles2.icon };
    return (0, import_jsx_runtime181.jsx)(
      Icon,
      {
        ref,
        className: cx("ui-stat__icon", className),
        "aria-label": type === "increase" ? "Increased by" : "Decreased by",
        viewBox: "0 0 24 24",
        __css: css4,
        ...rest,
        children: type === "increase" ? (0, import_jsx_runtime181.jsx)(
          ui.path,
          {
            fill: "$increase",
            d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
          }
        ) : (0, import_jsx_runtime181.jsx)(
          ui.path,
          {
            fill: "$decrease",
            d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
          }
        )
      }
    );
  }
);
var StatLabel = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useStat();
    const css4 = { ...styles2.label };
    return (0, import_jsx_runtime182.jsx)(
      ui.dt,
      {
        ref,
        className: cx("ui-stat__label", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var StatNumber = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useStat();
    const css4 = {
      ...styles2.number
    };
    return (0, import_jsx_runtime183.jsx)(
      ui.dd,
      {
        ref,
        className: cx("ui-stat__number", className),
        __css: css4,
        ...rest
      }
    );
  }
);
var [StatProvider, useStat] = createContext2({
  name: "StatContext",
  errorMessage: `useStat returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />"`
});
var Stat2 = forwardRef22((props2, ref) => {
  const [styles2, mergedProps] = useMultiComponentStyle("Stat", props2);
  const {
    className,
    label,
    labelProps,
    number: number2,
    numberProps,
    icon,
    iconProps,
    helperMessage,
    helperMessageProps,
    centerContent = false,
    children,
    ...rest
  } = omitThemeProps(mergedProps);
  const css4 = {
    display: "flex",
    flexDirection: "column",
    alignItems: centerContent ? "center" : "flex-start",
    ...styles2.container
  };
  const validChildren = getValidChildren(children);
  const [customStatLabel] = findChildren(validChildren, StatLabel);
  const [customStatNumber] = findChildren(validChildren, StatNumber);
  const [customStatHelperMessage] = findChildren(
    validChildren,
    StatHelperMessage
  );
  const cloneChildren = !isEmpty(validChildren) ? omitChildren(validChildren, StatLabel, StatNumber, StatHelperMessage) : children;
  return (0, import_jsx_runtime184.jsx)(StatProvider, { value: styles2, children: (0, import_jsx_runtime184.jsxs)(
    ui.dl,
    {
      ref,
      className: cx("ui-stat", className),
      __css: css4,
      ...rest,
      children: [
        customStatLabel != null ? customStatLabel : (0, import_jsx_runtime184.jsx)(StatLabel, { ...labelProps, children: label }),
        customStatNumber != null ? customStatNumber : (0, import_jsx_runtime184.jsx)(StatNumber, { ...numberProps, children: number2 }),
        customStatHelperMessage != null ? customStatHelperMessage : (0, import_jsx_runtime184.jsxs)(StatHelperMessage, { ...helperMessageProps, children: [
          icon ? (0, import_jsx_runtime184.jsx)(StatIcon, { type: icon, ...iconProps }) : null,
          helperMessage
        ] }),
        cloneChildren
      ]
    }
  ) });
});
var StatHelperMessage = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useStat();
    const css4 = { ...styles2.helperMessage };
    return (0, import_jsx_runtime185.jsx)(
      ui.dd,
      {
        ref,
        className: cx("ui-stat__helper-message", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/resizable/dist/chunk-IIKCEUSE.mjs
var import_react179 = __toESM(require_react(), 1);

// node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js
var React28 = __toESM(require_react());
var {
  createElement: createElement21,
  createContext: createContext15,
  createRef: createRef3,
  forwardRef: forwardRef16,
  useCallback: useCallback64,
  useContext: useContext26,
  useEffect: useEffect66,
  useImperativeHandle,
  useLayoutEffect: useLayoutEffect6,
  useMemo: useMemo47,
  useRef: useRef69,
  useState: useState69
} = React28;
var useId19 = React28[`useId${Math.random()}`.slice(0, 5)];
var useLayoutEffect_do_not_use_directly = useLayoutEffect6;
var PanelGroupContext = createContext15(null);
PanelGroupContext.displayName = "PanelGroupContext";
var useIsomorphicLayoutEffect3 = useLayoutEffect_do_not_use_directly;
var wrappedUseId = typeof useId19 === "function" ? useId19 : () => null;
var counter2 = 0;
function useUniqueId(idFromParams = null) {
  const idFromUseId = wrappedUseId();
  const idRef = useRef69(idFromParams || idFromUseId || null);
  if (idRef.current === null) {
    idRef.current = "" + counter2++;
  }
  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;
}
function PanelWithForwardedRef({
  children,
  className: classNameFromProps = "",
  collapsedSize,
  collapsible,
  defaultSize,
  forwardedRef,
  id: idFromProps,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order: order2,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const context = useContext26(PanelGroupContext);
  if (context === null) {
    throw Error(`Panel components must be rendered within a PanelGroup container`);
  }
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context;
  const panelId = useUniqueId(idFromProps);
  const panelDataRef = useRef69({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order: order2
  });
  const devWarningsRef = useRef69({
    didLogMissingDefaultSizeWarning: false
  });
  {
    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;
  }
  useIsomorphicLayoutEffect3(() => {
    const {
      callbacks,
      constraints
    } = panelDataRef.current;
    const prevConstraints = {
      ...constraints
    };
    panelDataRef.current.id = panelId;
    panelDataRef.current.idIsFromProps = idFromProps !== void 0;
    panelDataRef.current.order = order2;
    callbacks.onCollapse = onCollapse;
    callbacks.onExpand = onExpand;
    callbacks.onResize = onResize;
    constraints.collapsedSize = collapsedSize;
    constraints.collapsible = collapsible;
    constraints.defaultSize = defaultSize;
    constraints.maxSize = maxSize;
    constraints.minSize = minSize;
    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {
      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
    }
  });
  useIsomorphicLayoutEffect3(() => {
    const panelData = panelDataRef.current;
    registerPanel(panelData);
    return () => {
      unregisterPanel(panelData);
    };
  }, [order2, panelId, registerPanel, unregisterPanel]);
  useImperativeHandle(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size) => {
      resizePanel2(panelDataRef.current, size);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style = getPanelStyle(panelDataRef.current, defaultSize);
  return createElement21(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": collapsible || void 0,
    "data-panel-group-id": groupId,
    "data-panel-id": panelId,
    "data-panel-size": parseFloat("" + style.flexGrow).toFixed(1)
  });
}
var Panel = forwardRef16((props2, ref) => createElement21(PanelWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
var nonce;
function getNonce2() {
  return nonce;
}
var currentCursorStyle = null;
var enabled = true;
var styleElement = null;
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) {
      if (verticalMin) {
        return "se-resize";
      } else if (verticalMax) {
        return "ne-resize";
      } else {
        return "e-resize";
      }
    } else if (horizontalMax) {
      if (verticalMin) {
        return "sw-resize";
      } else if (verticalMax) {
        return "nw-resize";
      } else {
        return "w-resize";
      }
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
  }
}
function setGlobalCursorStyle(state, constraintFlags) {
  if (!enabled) {
    return;
  }
  const style = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style) {
    return;
  }
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    const nonce2 = getNonce2();
    if (nonce2) {
      styleElement.setAttribute("nonce", nonce2);
    }
    document.head.appendChild(styleElement);
  }
  styleElement.innerHTML = `*{cursor: ${style}!important;}`;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent2(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
  } else if (isMouseEvent2(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: Infinity,
    y: Infinity
  };
}
function getInputType() {
  if (typeof matchMedia === "function") {
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
}
function intersects(rectOne, rectTwo, strict) {
  if (strict) {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  } else {
    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
}
function compare(a, b) {
  if (a === b) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a),
    b: get_ancestors(b)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node3) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node3)) !== null && _get_parent !== void 0 ? _get_parent : node3).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node3) {
  const style = getComputedStyle(node3);
  if (style.position === "fixed") return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || is_flex_item(node3))) return true;
  if (+style.opacity < 1) return true;
  if ("transform" in style && style.transform !== "none") return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none") return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal") return true;
  if ("filter" in style && style.filter !== "none") return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none") return true;
  if ("isolation" in style && style.isolation === "isolate") return true;
  if (props.test(style.willChange)) return true;
  if (style.webkitOverflowScrolling === "touch") return true;
  return false;
}
function find_stacking_context(nodes) {
  let i = nodes.length;
  while (i--) {
    const node3 = nodes[i];
    assert(node3, "Missing node");
    if (creates_stacking_context(node3)) return node3;
  }
  return null;
}
function get_z_index(node3) {
  return node3 && Number(getComputedStyle(node3).zIndex) || 0;
}
function get_ancestors(node3) {
  const ancestors = [];
  while (node3) {
    ancestors.push(node3);
    node3 = get_parent(node3);
  }
  return ancestors;
}
function get_parent(node3) {
  const {
    parentNode
  } = node3;
  if (parentNode && parentNode instanceof ShadowRoot) {
    return parentNode.host;
  }
  return parentNode;
}
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument
  } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  ownerDocumentCounts.set(ownerDocument, count + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count2 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    ownerDocumentCounts.set(ownerDocument, count2 - 1);
    updateListeners();
    if (count2 === 1) {
      ownerDocumentCounts.delete(ownerDocument);
    }
    if (intersectingHandles.includes(data)) {
      const index = intersectingHandles.indexOf(data);
      if (index >= 0) {
        intersectingHandles.splice(index, 1);
      }
      updateCursor();
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event;
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
    event.stopPropagation();
  }
}
function handlePointerMove(event) {
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  if (isPointerDown && event.buttons === 0) {
    isPointerDown = false;
    updateResizeHandlerStates("up", event);
  }
  if (!isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x,
      y
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
}
function handlePointerUp(event) {
  const {
    target
  } = event;
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateCursor();
  updateListeners();
}
function recalculateIntersectingHandles({
  target,
  x,
  y
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement) {
    targetElement = target;
  }
  registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const {
      bottom: bottom2,
      left: left2,
      right: right2,
      top: top2
    } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x >= left2 - margin && x <= right2 + margin && y >= top2 - margin && y <= bottom2 + margin;
    if (eventIntersects) {
      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) {
          return;
        }
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    if (direction === "horizontal") {
      intersectsHorizontal = true;
    } else {
      intersectsVertical = true;
    }
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) {
    setGlobalCursorStyle("intersection", constraintFlags);
  } else if (intersectsHorizontal) {
    setGlobalCursorStyle("horizontal", constraintFlags);
  } else if (intersectsVertical) {
    setGlobalCursorStyle("vertical", constraintFlags);
  } else {
    resetGlobalCursorStyle();
  }
}
function updateListeners() {
  ownerDocumentCounts.forEach((_, ownerDocument) => {
    const {
      body
    } = ownerDocument;
    body.removeEventListener("contextmenu", handlePointerUp);
    body.removeEventListener("pointerdown", handlePointerDown);
    body.removeEventListener("pointerleave", handlePointerMove);
    body.removeEventListener("pointermove", handlePointerMove);
  });
  window.removeEventListener("pointerup", handlePointerUp);
  window.removeEventListener("pointercancel", handlePointerUp);
  if (registeredResizeHandlers.size > 0) {
    if (isPointerDown) {
      if (intersectingHandles.length > 0) {
        ownerDocumentCounts.forEach((count, ownerDocument) => {
          const {
            body
          } = ownerDocument;
          if (count > 0) {
            body.addEventListener("contextmenu", handlePointerUp);
            body.addEventListener("pointerleave", handlePointerMove);
            body.addEventListener("pointermove", handlePointerMove);
          }
        });
      }
      window.addEventListener("pointerup", handlePointerUp);
      window.addEventListener("pointercancel", handlePointerUp);
    } else {
      ownerDocumentCounts.forEach((count, ownerDocument) => {
        const {
          body
        } = ownerDocument;
        if (count > 0) {
          body.addEventListener("pointerdown", handlePointerDown, {
            capture: true
          });
          body.addEventListener("pointermove", handlePointerMove);
        }
      });
    }
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}
function useForceUpdate2() {
  const [_, setCount] = useState69(0);
  return useCallback64(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message) {
  if (!expectedCondition) {
    console.error(message);
    throw Error(message);
  }
}
var PRECISION = 10;
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index = 0; index < actual.length; index++) {
    const actualSize = actual[index];
    const expectedSize = expected[index];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {
        size = collapsedSize;
      } else {
        size = minSize;
      }
    } else {
      size = minSize;
    }
  }
  size = Math.min(maxSize, size);
  size = parseFloat(size.toFixed(PRECISION));
  return size;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger: trigger2
}) {
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialLayout;
  }
  const nextLayout = [...initialLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index");
  assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger2 === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `Panel constraints not found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `No panel constraints found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= panelConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index}`);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index--;
        } else {
          index++;
        }
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevLayout;
  }
  return nextLayout;
}
function calculateAriaValues({
  layout: layout2,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null, "No pivot index found");
  panelsArray.forEach((panelData, index) => {
    const {
      constraints
    } = panelData;
    const {
      maxSize = 100,
      minSize = 0
    } = constraints;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout2[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id4, scope = document) {
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handles.findIndex((handle) => handle.getAttribute("data-panel-resize-handle-id") === id4);
  return index !== null && index !== void 0 ? index : null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index != null ? [index, index + 1] : [-1, -1];
}
function getPanelGroupElement(id4, rootElement = document) {
  var _dataset;
  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id4) {
    return rootElement;
  }
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id4}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandleElement(id4, scope = document) {
  const element = scope.querySelector(`[data-panel-resize-handle-id="${id4}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;
  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout: layout2,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  const devWarningsRef = useRef69({
    didWarnAboutMissingResizeHandle: false
  });
  useIsomorphicLayoutEffect3(() => {
    if (!panelGroupElement) {
      return;
    }
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    for (let index = 0; index < panelDataArray.length - 1; index++) {
      const {
        valueMax,
        valueMin,
        valueNow
      } = calculateAriaValues({
        layout: layout2,
        panelsArray: panelDataArray,
        pivotIndices: [index, index + 1]
      });
      const resizeHandleElement = resizeHandleElements[index];
      if (resizeHandleElement == null) {
        {
          const {
            didWarnAboutMissingResizeHandle
          } = devWarningsRef.current;
          if (!didWarnAboutMissingResizeHandle) {
            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;
            console.warn(`WARNING: Missing resize handle for PanelGroup "${groupId}"`);
          }
        }
      } else {
        const panelData = panelDataArray[index];
        assert(panelData, `No panel data found for index "${index}"`);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax));
        resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin));
        resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
      }
    }
    return () => {
      resizeHandleElements.forEach((resizeHandleElement, index) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    };
  }, [groupId, layout2, panelDataArray, panelGroupElement]);
  useEffect66(() => {
    if (!panelGroupElement) {
      return;
    }
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, `Eager values not found`);
    const {
      panelDataArray: panelDataArray2
    } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute("data-panel-resize-handle-id");
      assert(handleId, `Resize handle element has no handle id attribute`);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null) {
        return () => {
        };
      }
      const onKeyDown = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
            if (index >= 0) {
              const panelData = panelDataArray2[index];
              assert(panelData, `No panel data found for index ${index}`);
              const size = layout2[index];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,
                  initialLayout: layout2,
                  panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                  prevLayout: layout2,
                  trigger: "keyboard"
                });
                if (layout2 !== nextLayout) {
                  setLayout(nextLayout);
                }
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout2, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (let index = 0; index < arrayA.length; index++) {
    if (arrayA[index] !== arrayB[index]) {
      return false;
    }
  }
  return true;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x : y;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute("data-panel-group-id");
  assert(groupId, `Resize handle element has no group id attribute`);
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) {
      return 0;
    }
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout2 = Array(panelDataArray.length);
  const panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout2[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout2[index] = size;
    remainingSize -= size;
  }
  return layout2;
}
function callPanelCallbacks(panelsArray, layout2, panelIdToLastNotifiedSizeMap) {
  layout2.forEach((size, index) => {
    const panelData = panelsArray[index];
    assert(panelData, `Panel data not found for index ${index}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData;
    const {
      collapsedSize = 0,
      collapsible
    } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      if (onResize) {
        onResize(size, lastNotifiedSize);
      }
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {
          onCollapse();
        }
      }
    }
  });
}
function compareLayouts(a, b) {
  if (a.length !== b.length) {
    return false;
  } else {
    for (let index = 0; index < a.length; index++) {
      if (a[index] != b[index]) {
        return false;
      }
    }
  }
  return true;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout: layout2,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size = layout2[panelIndex];
  let flexGrow;
  if (size == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce2(callback, durationMs = 10) {
  let timeoutId = null;
  let callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const {
      constraints,
      id: id4,
      idIsFromProps,
      order: order2
    } = panel;
    if (idIsFromProps) {
      return id4;
    } else {
      return order2 ? `${order2}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a, b) => a.localeCompare(b)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) {
        return parsed;
      }
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  var _loadSerializedPanelG, _state$panelKey;
  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};
  const panelKey = getPanelKey(panels);
  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes2, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes2
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
function validatePanelConstraints({
  panelConstraints: panelConstraintsArray,
  panelId,
  panelIndex
}) {
  {
    const warnings = [];
    const panelConstraints = panelConstraintsArray[panelIndex];
    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);
    const {
      collapsedSize = 0,
      collapsible = false,
      defaultSize,
      maxSize = 100,
      minSize = 0
    } = panelConstraints;
    if (minSize > maxSize) {
      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);
    }
    if (defaultSize != null) {
      if (defaultSize < 0) {
        warnings.push("default size should not be less than 0");
      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {
        warnings.push("default size should not be less than min size");
      }
      if (defaultSize > 100) {
        warnings.push("default size should not be greater than 100");
      } else if (defaultSize > maxSize) {
        warnings.push("default size should not be greater than max size");
      }
    }
    if (collapsedSize > minSize) {
      warnings.push("collapsed size should not be greater than min size");
    }
    if (warnings.length > 0) {
      const name = panelId != null ? `Panel "${panelId}"` : "Panel";
      console.warn(`${name} has an invalid configuration:

${warnings.join("\n")}`);
      return false;
    }
  }
  return true;
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) {
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {
    {
      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size) => `${size}%`).join(", ")}. Layout normalization will be applied.`);
    }
    for (let index = 0; index < panelConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null, `No layout data found for index ${index}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panelConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null, `No layout data found for index ${index}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index = 0; index < panelConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null, `No layout data found for index ${index}`);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var debounceMap = {};
function PanelGroupWithForwardedRef({
  autoSaveId = null,
  children,
  className: classNameFromProps = "",
  direction,
  forwardedRef,
  id: idFromProps = null,
  onLayout = null,
  keyboardResizeBy = null,
  storage = defaultStorage,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const groupId = useUniqueId(idFromProps);
  const panelGroupElementRef = useRef69(null);
  const [dragState, setDragState] = useState69(null);
  const [layout2, setLayout] = useState69([]);
  const forceUpdate = useForceUpdate2();
  const panelIdToLastNotifiedSizeMapRef = useRef69({});
  const panelSizeBeforeCollapseRef = useRef69(/* @__PURE__ */ new Map());
  const prevDeltaRef = useRef69(0);
  const committedValuesRef = useRef69({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  });
  const eagerValuesRef = useRef69({
    layout: layout2,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  const devWarningsRef = useRef69({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  });
  useImperativeHandle(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout3
      } = eagerValuesRef.current;
      return layout3;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, safeLayout)) {
        setLayout(safeLayout);
        eagerValuesRef.current.layout = safeLayout;
        if (onLayout2) {
          onLayout2(safeLayout);
        }
        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  }), []);
  useIsomorphicLayoutEffect3(() => {
    committedValuesRef.current.autoSaveId = autoSaveId;
    committedValuesRef.current.direction = direction;
    committedValuesRef.current.dragState = dragState;
    committedValuesRef.current.id = groupId;
    committedValuesRef.current.onLayout = onLayout;
    committedValuesRef.current.storage = storage;
  });
  useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout: layout2,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  });
  useEffect66(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout2.length === 0 || layout2.length !== panelDataArray.length) {
        return;
      }
      let debouncedSave = debounceMap[autoSaveId];
      if (debouncedSave == null) {
        debouncedSave = debounce2(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
        debounceMap[autoSaveId] = debouncedSave;
      }
      const clonedPanelDataArray = [...panelDataArray];
      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout2, storage);
    }
  }, [autoSaveId, layout2, storage]);
  useEffect66(() => {
    {
      const {
        panelDataArray
      } = eagerValuesRef.current;
      const {
        didLogIdAndOrderWarning,
        didLogPanelConstraintsWarning,
        prevPanelIds
      } = devWarningsRef.current;
      if (!didLogIdAndOrderWarning) {
        const panelIds = panelDataArray.map(({
          id: id4
        }) => id4);
        devWarningsRef.current.prevPanelIds = panelIds;
        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);
        if (panelsHaveChanged) {
          if (panelDataArray.find(({
            idIsFromProps,
            order: order2
          }) => !idIsFromProps || order2 == null)) {
            devWarningsRef.current.didLogIdAndOrderWarning = true;
            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);
          }
        }
      }
      if (!didLogPanelConstraintsWarning) {
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {
          const panelData = panelDataArray[panelIndex];
          assert(panelData, `Panel data not found for index ${panelIndex}`);
          const isValid = validatePanelConstraints({
            panelConstraints,
            panelId: panelData.id,
            panelIndex
          });
          if (!isValid) {
            devWarningsRef.current.didLogPanelConstraintsWarning = true;
            break;
          }
        }
      }
    }
  });
  const collapsePanel = useCallback64((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const expandPanel = useCallback64((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);
        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const getPanelSize = useCallback64((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return panelSize;
  }, []);
  const getPanelStyle = useCallback64((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout: layout2,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout2]);
  const isPanelCollapsed = useCallback64((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []);
  const isPanelExpanded = useCallback64((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []);
  const registerPanel = useCallback64((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData);
    panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order;
      const orderB = panelB.order;
      if (orderA == null && orderB == null) {
        return 0;
      } else if (orderA == null) {
        return -1;
      } else if (orderB == null) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    eagerValuesRef.current.panelDataArrayChanged = true;
    forceUpdate();
  }, [forceUpdate]);
  useIsomorphicLayoutEffect3(() => {
    if (eagerValuesRef.current.panelDataArrayChanged) {
      eagerValuesRef.current.panelDataArrayChanged = false;
      const {
        autoSaveId: autoSaveId2,
        onLayout: onLayout2,
        storage: storage2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      let unsafeLayout = null;
      if (autoSaveId2) {
        const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
        if (state) {
          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));
          unsafeLayout = state.layout;
        }
      }
      if (unsafeLayout == null) {
        unsafeLayout = calculateUnsafeDefaultLayout({
          panelDataArray
        });
      }
      const nextLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  });
  useIsomorphicLayoutEffect3(() => {
    const eagerValues = eagerValuesRef.current;
    return () => {
      eagerValues.layout = [];
    };
  }, []);
  const registerResizeHandle2 = useCallback64((dragHandleId) => {
    return function resizeHandler(event) {
      event.preventDefault();
      const panelGroupElement = panelGroupElementRef.current;
      if (!panelGroupElement) {
        return () => null;
      }
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const {
        initialLayout
      } = dragState2 !== null && dragState2 !== void 0 ? dragState2 : {};
      const pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement);
      const isHorizontal = direction2 === "horizontal";
      if (document.dir === "rtl" && isHorizontal) {
        delta = -delta;
      }
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !compareLayouts(prevLayout, nextLayout);
      if (isPointerEvent(event) || isMouseEvent2(event)) {
        if (prevDeltaRef.current != delta) {
          prevDeltaRef.current = delta;
          if (!layoutChanged && delta !== 0) {
            if (isHorizontal) {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            } else {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            }
          } else {
            reportConstraintsViolation(dragHandleId, 0);
          }
        }
      }
      if (layoutChanged) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    };
  }, []);
  const resizePanel2 = useCallback64((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
    const {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    if (!compareLayouts(prevLayout, nextLayout)) {
      setLayout(nextLayout);
      eagerValuesRef.current.layout = nextLayout;
      if (onLayout2) {
        onLayout2(nextLayout);
      }
      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
    }
  }, []);
  const reevaluatePanelConstraints = useCallback64((panelData, prevConstraints) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints;
    const {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints;
    const {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    if (prevPanelSize == null) {
      return;
    }
    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {
      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {
        resizePanel2(panelData, nextCollapsedSize);
      }
    } else if (prevPanelSize < nextMinSize) {
      resizePanel2(panelData, nextMinSize);
    } else if (prevPanelSize > nextMaxSize) {
      resizePanel2(panelData, nextMaxSize);
    }
  }, [resizePanel2]);
  const startDragging = useCallback64((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current;
    const {
      layout: layout3
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current) {
      return;
    }
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout3
    });
  }, []);
  const stopDragging = useCallback64(() => {
    setDragState(null);
  }, []);
  const unregisterPanel = useCallback64((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const index = findPanelDataIndex(panelDataArray, panelData);
    if (index >= 0) {
      panelDataArray.splice(index, 1);
      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];
      eagerValuesRef.current.panelDataArrayChanged = true;
      forceUpdate();
    }
  }, [forceUpdate]);
  const context = useMemo47(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]);
  const style = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return createElement21(PanelGroupContext.Provider, {
    value: context
  }, createElement21(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId
  }));
}
var PanelGroup = forwardRef16((props2, ref) => createElement21(PanelGroupWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout2) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData);
  const isLastPanel = panelIndex === panelDataArray.length - 1;
  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
  const panelSize = layout2[panelIndex];
  return {
    ...panelData.constraints,
    panelSize,
    pivotIndices
  };
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  useEffect66(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null) {
      return;
    }
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute("data-panel-group-id");
          assert(groupId, `No group element found for id "${groupId}"`);
          const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
          const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
          assert(index !== null, `No resize element found for id "${handleId}"`);
          const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    return () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle({
  children = null,
  className: classNameFromProps = "",
  disabled = false,
  hitAreaMargins,
  id: idFromProps,
  onBlur: onBlur4,
  onDragging,
  onFocus: onFocus4,
  style: styleFromProps = {},
  tabIndex = 0,
  tagName: Type = "div",
  ...rest
}) {
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = useRef69(null);
  const callbacksRef = useRef69({
    onDragging
  });
  useEffect66(() => {
    callbacksRef.current.onDragging = onDragging;
  });
  const panelGroupContext = useContext26(PanelGroupContext);
  if (panelGroupContext === null) {
    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
  }
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext;
  const resizeHandleId = useUniqueId(idFromProps);
  const [state, setState] = useState69("inactive");
  const [isFocused, setIsFocused] = useState69(false);
  const [resizeHandler, setResizeHandler] = useState69(null);
  const committedValuesRef = useRef69({
    state
  });
  useIsomorphicLayoutEffect3(() => {
    committedValuesRef.current.state = state;
  });
  useEffect66(() => {
    if (disabled) {
      setResizeHandler(null);
    } else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;
  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  useEffect66(() => {
    if (disabled || resizeHandler == null) {
      return;
    }
    const element = elementRef.current;
    assert(element, "Element ref not attached");
    const setResizeHandlerState = (action, isActive, event) => {
      if (isActive) {
        switch (action) {
          case "down": {
            setState("drag");
            startDragging(resizeHandleId, event);
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            if (onDragging2) {
              onDragging2(true);
            }
            break;
          }
          case "move": {
            const {
              state: state2
            } = committedValuesRef.current;
            if (state2 !== "drag") {
              setState("hover");
            }
            resizeHandler(event);
            break;
          }
          case "up": {
            setState("hover");
            stopDragging();
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            if (onDragging2) {
              onDragging2(false);
            }
            break;
          }
        }
      } else {
        setState("inactive");
      }
    };
    return registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, setResizeHandlerState);
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);
  useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  });
  const style = {
    touchAction: "none",
    userSelect: "none"
  };
  return createElement21(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(false);
      onBlur4 === null || onBlur4 === void 0 ? void 0 : onBlur4();
    },
    onFocus: () => {
      setIsFocused(true);
      onFocus4 === null || onFocus4 === void 0 ? void 0 : onFocus4();
    },
    ref: elementRef,
    role: "separator",
    style: {
      ...style,
      ...styleFromProps
    },
    tabIndex,
    // CSS selectors
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId,
    "data-resize-handle": "",
    "data-resize-handle-active": state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    "data-resize-handle-state": state,
    "data-panel-resize-handle-enabled": !disabled,
    "data-panel-resize-handle-id": resizeHandleId
  });
}
PanelResizeHandle.displayName = "PanelResizeHandle";
function getPanelElement(id4, scope = document) {
  const element = scope.querySelector(`[data-panel-id="${id4}"]`);
  if (element) {
    return element;
  }
  return null;
}

// node_modules/@yamada-ui/resizable/dist/chunk-IIKCEUSE.mjs
var [ResizableProvider, useResizableContext] = createContext2({
  name: "ResizableContext",
  errorMessage: `useResizableContext returned is 'undefined'. Seems you forgot to wrap the components in "<Resizable />"`
});
var useResizable = ({
  id: id4,
  direction = "horizontal",
  storageKey,
  keyboardStep,
  isDisabled: isDisabled2 = false,
  onLayout,
  storage,
  ref,
  groupProps,
  ...rest
}) => {
  id4 != null ? id4 : id4 = (0, import_react179.useId)();
  const getContainerProps = (0, import_react179.useCallback)(
    (props2 = {}, ref2 = null) => ({ ...props2, ref: ref2, ...rest }),
    [rest]
  );
  const getGroupProps = (0, import_react179.useCallback)(
    (props2 = {}) => {
      const { as, ...rest2 } = groupProps != null ? groupProps : {};
      return {
        ...props2,
        id: id4,
        direction,
        tagName: as,
        autoSaveId: storageKey,
        keyboardResizeBy: keyboardStep,
        onLayout,
        storage,
        ...rest2
      };
    },
    [id4, direction, groupProps, storageKey, keyboardStep, onLayout, storage]
  );
  (0, import_react179.useEffect)(() => {
    if (!id4) return;
    const el = getPanelGroupElement(id4);
    if (ref) ref.current = el;
  }, [ref, id4]);
  return {
    isDisabled: isDisabled2,
    getContainerProps,
    getGroupProps
  };
};
var useResizableItem = ({
  id: id4,
  ref,
  collapsedSize,
  collapsible,
  defaultSize,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order: order2,
  controlRef,
  containerProps,
  ...innerProps
}) => {
  id4 != null ? id4 : id4 = (0, import_react179.useId)();
  const getPanelProps = (0, import_react179.useCallback)(
    (props2 = {}) => {
      const { as, ...rest } = containerProps != null ? containerProps : {};
      return {
        ...props2,
        ref: controlRef,
        id: id4,
        tagName: as,
        collapsible,
        defaultSize,
        maxSize,
        minSize,
        collapsedSize,
        onCollapse,
        onExpand,
        onResize,
        order: order2,
        ...collapsible ? { "aria-labelledby": id4 } : { "aria-label": id4 },
        ...rest
      };
    },
    [
      id4,
      controlRef,
      containerProps,
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize,
      onCollapse,
      onExpand,
      onResize,
      order2
    ]
  );
  const getItemProps = (0, import_react179.useCallback)(
    (props2 = {}, ref2 = null) => ({ ...props2, ref: ref2, ...innerProps }),
    [innerProps]
  );
  (0, import_react179.useEffect)(() => {
    if (!id4) return;
    const el = getPanelElement(id4);
    if (ref) ref.current = el;
  }, [ref, id4]);
  return {
    getPanelProps,
    getItemProps
  };
};
var useResizableTrigger = ({
  id: id4,
  ref,
  as,
  disabled,
  isDisabled: isDisabled2,
  onDragging,
  ...rest
}) => {
  id4 != null ? id4 : id4 = (0, import_react179.useId)();
  const { isDisabled: isGroupDisabled } = useResizableContext();
  const [isActive, setIsActive] = (0, import_react179.useState)(false);
  const trulyDisabled = disabled || isDisabled2 || isGroupDisabled;
  const getTriggerProps = (0, import_react179.useCallback)(
    (props2 = {}) => ({
      ...props2,
      id: id4,
      tagName: as,
      disabled: trulyDisabled,
      onDragging: handlerAll(onDragging, (isActive2) => setIsActive(isActive2)),
      ...rest,
      "data-active": dataAttr(isActive),
      style: {
        ...props2.style,
        ...rest.style,
        ...trulyDisabled ? { cursor: "default" } : {}
      }
    }),
    [id4, as, trulyDisabled, onDragging, rest, isActive]
  );
  const getIconProps = (0, import_react179.useCallback)(
    (props2 = {}, ref2 = null) => ({
      ...props2,
      ref: ref2,
      "data-active": dataAttr(isActive)
    }),
    [isActive]
  );
  (0, import_react179.useEffect)(() => {
    if (!id4) return;
    const el = getResizeHandleElement(id4);
    if (ref) ref.current = el;
  }, [ref, id4]);
  return {
    getTriggerProps,
    getIconProps
  };
};

// node_modules/@yamada-ui/resizable/dist/chunk-OC4OPFF5.mjs
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var panelProps = /* @__PURE__ */ new Set(["order"]);
var UIPanel = ui(Panel, { disableStyleProp: (prop) => panelProps.has(prop) });
var ResizableItem = forwardRef22(
  ({
    className,
    children,
    innerRef,
    w,
    width,
    minW,
    minWidth,
    maxW,
    maxWidth,
    h,
    height,
    minH,
    minHeight,
    maxH,
    maxHeight,
    boxSize,
    ...rest
  }, ref) => {
    const { styles: styles2 } = useResizableContext();
    const { getPanelProps, getItemProps } = useResizableItem({
      ref,
      ...rest
    });
    const css4 = { boxSize: "100%", ...styles2.item };
    return (0, import_jsx_runtime186.jsx)(
      UIPanel,
      {
        ...getPanelProps({
          w,
          width,
          minW,
          minWidth,
          maxW,
          maxWidth,
          h,
          height,
          minH,
          minHeight,
          maxH,
          maxHeight,
          boxSize
        }),
        children: (0, import_jsx_runtime186.jsx)(
          ui.div,
          {
            className: cx("ui-resizable__item", className),
            __css: css4,
            ...getItemProps({}, innerRef),
            children
          }
        )
      }
    );
  }
);

// node_modules/@yamada-ui/resizable/dist/chunk-BWGY44LK.mjs
var import_react180 = __toESM(require_react(), 1);
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var ResizableTrigger = (0, import_react180.forwardRef)(
  ({ className, icon, children, iconProps, ...rest }, ref) => {
    const { styles: styles2 } = useResizableContext();
    const { getTriggerProps, getIconProps } = useResizableTrigger({
      ref,
      ...rest
    });
    const css4 = { position: "relative", ...styles2.trigger };
    return (0, import_jsx_runtime187.jsxs)(
      ui.div,
      {
        as: PanelResizeHandle,
        className: cx("ui-resizable__trigger", className),
        __css: css4,
        ...getTriggerProps(),
        children: [
          icon ? (0, import_jsx_runtime187.jsx)(
            ui.div,
            {
              className: "ui-resizable__trigger__icon",
              __css: {
                position: "absolute",
                top: "50%",
                left: "50%",
                transform: "auto",
                translateY: "-50%",
                translateX: "-50%",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                ...styles2.icon
              },
              ...getIconProps(iconProps),
              children: icon
            }
          ) : null,
          children
        ]
      }
    );
  }
);
ResizableTrigger.displayName = "ResizableTrigger";
var ResizableTriggerIcon = (rest) => {
  return (0, import_jsx_runtime187.jsxs)(Icon, { viewBox: "0 0 23 39", w: "0.5rem", h: "1rem", ...rest, children: [
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 5 0 C 7.761 0 10 2.239 10 5 C 10 7.761 7.761 10 5 10 C 2.239 10 0 7.761 0 5 C 0 2.239 2.239 0 5 0 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 19 0 C 21.761 0 24 2.239 24 5 C 24 7.761 21.761 10 19 10 C 16.239 10 14 7.761 14 5 C 14 2.239 16.239 0 19 0 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 19 14 C 21.761 14 24 16.239 24 19 C 24 21.761 21.761 24 19 24 C 16.239 24 14 21.761 14 19 C 14 16.239 16.239 14 19 14 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 5 14 C 7.761 14 10 16.239 10 19 C 10 21.761 7.761 24 5 24 C 2.239 24 0 21.761 0 19 C 0 16.239 2.239 14 5 14 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 5 28 C 7.761 28 10 30.239 10 33 C 10 35.761 7.761 38 5 38 C 2.239 38 0 35.761 0 33 C 0 30.239 2.239 28 5 28 Z",
        fill: "currentColor"
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "path",
      {
        d: "M 19 28 C 21.761 28 24 30.239 24 33 C 24 35.761 21.761 38 19 38 C 16.239 38 14 35.761 14 33 C 14 30.239 16.239 28 19 28 Z",
        fill: "currentColor"
      }
    )
  ] });
};

// node_modules/@yamada-ui/resizable/dist/chunk-YFQD6ESN.mjs
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var Resizable2 = forwardRef22(
  ({ direction = "horizontal", ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("Resizable", {
      direction,
      ...props2
    });
    const { className, children, containerRef, ...computedProps } = omitThemeProps(mergedProps);
    const { getContainerProps, getGroupProps, ...rest } = useResizable({
      ref,
      ...computedProps
    });
    const css4 = { w: "100%", h: "100%", ...styles2.container };
    return (0, import_jsx_runtime188.jsx)(ResizableProvider, { value: { styles: styles2, ...rest }, children: (0, import_jsx_runtime188.jsx)(
      ui.div,
      {
        className: cx("ui-resizable", className),
        __css: css4,
        ...getContainerProps({}, containerRef),
        children: (0, import_jsx_runtime188.jsx)(PanelGroup, { ...getGroupProps(), children })
      }
    ) });
  }
);

// node_modules/@yamada-ui/snacks/dist/chunk-IP5KKKZ3.mjs
var import_react181 = __toESM(require_react(), 1);
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var defaultContainerVariants = {
  initial: { padding: 0 },
  animate: ({ gutter }) => ({
    padding: `${gutter[0]} 0 ${gutter[1]}`,
    transition: { duration: 0.4 }
  }),
  exit: { padding: 0 }
};
var defaultListVariants = {
  initial: { opacity: 1, height: 0 },
  animate: ({ height }) => ({
    opacity: 1,
    height,
    transition: { duration: 0.4 }
  }),
  exit: { opacity: 0, height: 0 }
};
var Snacks = motionForwardRef(
  ({
    className,
    snacks,
    containerVariants = defaultContainerVariants,
    listVariants = defaultListVariants,
    listProps,
    ...props2
  }, ref) => {
    var _a, _b;
    const { items, ...computedSnacks } = snacks;
    const count = items.length;
    const refMap = (0, import_react181.useRef)(/* @__PURE__ */ new Map());
    const [height, setHeight] = (0, import_react181.useState)(0);
    const [isExist, setIsExist] = (0, import_react181.useState)(!!count);
    const { theme } = useTheme2();
    const {
      variants: variants6,
      direction = "top",
      startIndex = 0,
      gutter = [0, 0],
      gap = "fallback(4, 1rem)",
      negateMargin = true,
      ...rest
    } = (0, import_react181.useMemo)(
      () => {
        var _a2;
        return { ...computedSnacks, ...(_a2 = theme.__config) == null ? void 0 : _a2.snacks, ...props2 };
      },
      [computedSnacks, theme, props2]
    );
    const top2 = (_a = useToken("spaces", useValue(gutter[0]))) != null ? _a : 0;
    const bottom2 = (_b = useToken("spaces", useValue(gutter[1]))) != null ? _b : 0;
    const negatedTop = calc(top2).negate().toString();
    const negatedBottom = calc(bottom2).negate().toString();
    const isShow = !!count || isExist;
    const css4 = {
      w: "100%",
      var: [{ name: "space", token: "spaces", value: gap }],
      margin: negateMargin ? `${negatedTop} 0 ${negatedBottom}` : void 0
    };
    (0, import_react181.useEffect)(() => {
      let height2 = 0;
      if (!count) return;
      const refs = [...refMap.current.values()].slice(0, count);
      for (const ref2 of refs) {
        if (!ref2.current) continue;
        let { offsetHeight, offsetTop } = ref2.current;
        offsetHeight += offsetTop;
        if (offsetHeight > height2) height2 = offsetHeight;
      }
      setHeight(height2);
    }, [count, direction]);
    useUpdateEffect(() => {
      if (!!count) setIsExist(true);
    }, [count]);
    return (0, import_jsx_runtime189.jsx)(AnimatePresence, { initial: false, children: isShow ? (0, import_jsx_runtime189.jsx)(
      Motion,
      {
        ref,
        className: cx("ui-snacks", className),
        __css: css4,
        variants: containerVariants,
        custom: { gutter: [top2, bottom2] },
        initial: "initial",
        animate: "animate",
        exit: "exit",
        ...rest,
        children: (0, import_jsx_runtime189.jsx)(
          Motion,
          {
            as: "ul",
            className: "ui-snacks__list",
            variants: listVariants,
            custom: { height },
            initial: "initial",
            animate: "animate",
            exit: "exit",
            __css: {
              position: "relative",
              w: "100%"
            },
            ...listProps,
            children: (0, import_jsx_runtime189.jsx)(
              AnimatePresence,
              {
                onExitComplete: () => {
                  if (!count) setIsExist(false);
                },
                children: items.map((props22, index) => {
                  const ref2 = (0, import_react181.createRef)();
                  refMap.current.set(index, ref2);
                  return (0, import_jsx_runtime189.jsx)(
                    SnackComponent,
                    {
                      ref: ref2,
                      index,
                      lastIndex: count - index - 1,
                      startIndex,
                      variants: variants6,
                      direction,
                      ...props22
                    },
                    props22.id
                  );
                })
              }
            )
          }
        )
      }
    ) : null });
  }
);
var defaultItemVariants = {
  initial: ({ index, direction }) => ({
    opacity: 0,
    ...index ? { y: (direction === "top" ? -1 : 1) * 16 } : {}
  }),
  animate: ({ index }) => ({
    opacity: 1,
    y: 0,
    transition: {
      delay: !index ? 0.4 : 0,
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  }),
  exit: {
    opacity: 0,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var SnackComponent = (0, import_react181.memo)(
  forwardRef22(
    ({
      index,
      lastIndex,
      startIndex,
      direction,
      variants: variants6 = defaultItemVariants,
      duration = null,
      message,
      onClose: onCloseProp,
      onCloseComplete,
      style
    }, ref) => {
      const [delay2, setDelay] = (0, import_react181.useState)(duration);
      const isPresent2 = useIsPresent();
      const onClose = isPresent2 ? onCloseProp : noop;
      const onMouseEnter = () => setDelay(null);
      const onMouseLeave = () => setDelay(duration);
      const zIndex = startIndex + index;
      const space = `calc($space * ${direction === "top" ? lastIndex : index})`;
      const css4 = {
        position: "absolute",
        top: space,
        left: 0,
        right: 0,
        zIndex,
        w: "100%",
        maxW: "100%",
        ...style
      };
      useUpdateEffect(() => {
        if (!isPresent2) onCloseComplete == null ? void 0 : onCloseComplete();
      }, [isPresent2]);
      useUpdateEffect(() => {
        setDelay(duration);
      }, [duration]);
      useTimeout(onClose, delay2);
      return (0, import_jsx_runtime189.jsx)(ui.li, { ref, className: "ui-snacks__item", __css: css4, children: (0, import_jsx_runtime189.jsx)(
        Motion,
        {
          className: "ui-snacks__item-inner",
          layout: true,
          variants: variants6,
          custom: { index, lastIndex, direction },
          initial: "initial",
          animate: "animate",
          exit: "exit",
          onHoverStart: onMouseEnter,
          onHoverEnd: onMouseLeave,
          children: runIfFunc(message, { index, onClose })
        }
      ) });
    }
  )
);
SnackComponent.displayName = "SnackComponent";

// node_modules/@yamada-ui/snacks/dist/chunk-4AN4GKPU.mjs
var import_react182 = __toESM(require_react(), 1);
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var createRender2 = (options) => {
  const { component } = options;
  const Render2 = (props2) => {
    if (typeof component === "function") {
      return component({ ...props2, ...options });
    } else {
      return (0, import_jsx_runtime190.jsx)(Snack, { ...props2, ...options });
    }
  };
  return Render2;
};
var counter3 = 0;
var useSnacks = (defaultOptions2 = {}) => {
  const [items, setItems] = (0, import_react182.useState)([]);
  const { theme } = useTheme2();
  const themeOptions = (0, import_react182.useMemo)(
    () => {
      var _a, _b, _c;
      return (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.snacks) == null ? void 0 : _b.options) != null ? _c : {};
    },
    [theme]
  );
  const computedOptions = (0, import_react182.useMemo)(
    () => merge(themeOptions, defaultOptions2),
    [defaultOptions2, themeOptions]
  );
  const { direction, startIndex, limit = 3 } = computedOptions;
  const getOptions = (0, import_react182.useCallback)(
    (options) => merge(computedOptions, options),
    [computedOptions]
  );
  const snack = (0, import_react182.useMemo)(() => {
    const methods2 = (options = {}) => {
      options = getOptions(options);
      const message = createRender2(options);
      counter3 += 1;
      let {
        id: id4 = counter3,
        duration,
        onCloseComplete,
        status,
        boxShadow,
        style
      } = options;
      const onClose = () => setItems((prev2) => prev2.filter((child) => child.id !== id4));
      const snack2 = {
        id: id4,
        status,
        duration,
        message,
        onClose,
        onCloseComplete,
        boxShadow,
        style
      };
      setItems((prev2) => [
        ...prev2.splice(-1 * ((limit != null ? limit : Infinity) - 1)),
        snack2
      ]);
      return id4;
    };
    methods2.update = (id4, options) => {
      options = getOptions(options);
      setItems(
        (prev2) => prev2.map((props2) => {
          if (props2.id === id4) {
            return { ...props2, ...options, message: createRender2(options) };
          } else {
            return props2;
          }
        })
      );
    };
    methods2.closeAll = () => {
      setItems([]);
    };
    methods2.close = (id4) => {
      setItems((prev2) => prev2.filter((props2) => props2.id !== id4));
    };
    methods2.isActive = (id4) => !!items.find((props2) => props2.id === id4);
    return methods2;
  }, [items, limit, getOptions]);
  const snacks = (0, import_react182.useMemo)(
    () => ({ direction, startIndex, items }),
    [direction, startIndex, items]
  );
  return { snack, snacks };
};
var defaultBoxShadow = [
  "0 -1px 3px 0 rgba(0, 0, 0, 0.1), 0 -1px 2px 0 rgba(0, 0, 0, 0.06), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  "0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px -1px 2px rgba(0, 0, 0, 0.2), 0px 1px 2px rgba(0, 0, 0, 0.2)"
];
var Snack = forwardRef22(
  ({
    variant = "basic",
    colorScheme,
    status,
    icon,
    title,
    description,
    isClosable = true,
    closeStrategy = "button",
    boxShadow = defaultBoxShadow,
    className,
    index,
    onClose
  }, ref) => {
    const isButtonClosable = isClosable && (closeStrategy === "button" || closeStrategy === "both");
    const isElementClosable = isClosable && (closeStrategy === "element" || closeStrategy === "both");
    return (0, import_jsx_runtime190.jsxs)(
      Alert,
      {
        ref,
        className: cx("ui-snack", className),
        status,
        variant,
        colorScheme,
        alignItems: "start",
        boxShadow: index ? boxShadow : void 0,
        pe: isButtonClosable ? 8 : void 0,
        onClick: isElementClosable ? onClose : void 0,
        children: [
          (0, import_jsx_runtime190.jsx)(
            AlertIcon,
            {
              variant: icon == null ? void 0 : icon.variant,
              className: "ui-snack__icon",
              ...(icon == null ? void 0 : icon.color) ? { color: icon.color } : {},
              children: icon == null ? void 0 : icon.children
            }
          ),
          (0, import_jsx_runtime190.jsxs)(ui.div, { flex: "1", children: [
            title ? (0, import_jsx_runtime190.jsx)(AlertTitle, { className: "ui-snack__title", lineClamp: 1, children: title }) : null,
            description ? (0, import_jsx_runtime190.jsx)(AlertDescription, { className: "ui-snack__desc", lineClamp: 3, children: description }) : null
          ] }),
          isButtonClosable ? (0, import_jsx_runtime190.jsx)(
            CloseButton,
            {
              className: "ui-snack__close-button",
              size: "sm",
              onClick: (ev) => {
                ev.stopPropagation();
                onClose == null ? void 0 : onClose();
              },
              position: "absolute",
              top: 2,
              right: 2
            }
          ) : null
        ]
      }
    );
  }
);

// node_modules/@yamada-ui/use-infinite-scroll/dist/index.mjs
var import_react183 = __toESM(require_react(), 1);
var isScrollable = (el, isVertical) => {
  const style = getComputedStyle(el);
  if (["auto", "scroll", "overlay"].includes(style.overflow)) return true;
  if (isVertical) {
    return ["auto", "scroll", "overlay"].includes(style.overflowY);
  } else {
    return ["auto", "scroll", "overlay"].includes(style.overflowX);
  }
};
var onScroll = ({
  root,
  isVertical,
  isReverse,
  behavior,
  position: position2
}) => {
  let options;
  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    options = { top: position2 != null ? position2 : isReverse ? el.scrollHeight : 0, behavior };
  } else {
    options = { left: position2 != null ? position2 : isReverse ? el.scrollWidth : 0, behavior };
  }
  if (el === document.body) {
    window.scrollTo(options);
  } else {
    el.scrollTo(options);
  }
};
var getScrollPosition = (root, isVertical) => {
  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    return el.scrollHeight - el.scrollTop;
  } else {
    return el.scrollWidth - el.scrollLeft;
  }
};
var useInfiniteScroll = ({
  orientation = "vertical",
  rootRef,
  rootMargin,
  threshold,
  initialLoad = false,
  startIndex = initialLoad ? 0 : 1,
  onLoad: onLoadProp,
  resetRef,
  indexRef: indexRefProp,
  isDisabled: isDisabled2 = false,
  isReverse = false,
  behavior
} = {}) => {
  const ref = (0, import_react183.useRef)(null);
  const indexRef = (0, import_react183.useRef)(startIndex);
  const processingRef = (0, import_react183.useRef)(false);
  const observerRef = (0, import_react183.useRef)(void 0);
  const isMountedRef = (0, import_react183.useRef)(false);
  const prevScrollPosition = (0, import_react183.useRef)(0);
  const [isFinish, setIsFinish] = (0, import_react183.useState)(false);
  const onLoad = useCallbackRef(onLoadProp);
  const isVertical = orientation === "vertical";
  const options = (0, import_react183.useMemo)(() => {
    const root = rootRef == null ? void 0 : rootRef.current;
    return { root, rootMargin, threshold };
  }, [rootMargin, rootRef, threshold]);
  const onReset = (0, import_react183.useCallback)(
    (index = 1, runScroll = true) => {
      indexRef.current = index;
      setIsFinish(false);
      if (runScroll) {
        const root = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root, isVertical, isReverse, behavior });
      }
      if (isDisabled2) return;
      setTimeout(() => {
        const observer2 = observerRef.current;
        const el = ref.current;
        if (el) observer2 == null ? void 0 : observer2.observe(el);
      });
    },
    [isDisabled2, isReverse, rootRef, isVertical, behavior]
  );
  const onFinish = (0, import_react183.useCallback)(() => {
    const observer2 = observerRef.current;
    const el = ref.current;
    if (el) observer2 == null ? void 0 : observer2.unobserve(el);
    setIsFinish(true);
  }, []);
  const createObserver = (0, import_react183.useCallback)(() => {
    const observer2 = new IntersectionObserver(async ([entry]) => {
      if (!entry.isIntersecting || processingRef.current) return;
      const props2 = { index: indexRef.current, entry, finish: onFinish };
      processingRef.current = true;
      const root = rootRef == null ? void 0 : rootRef.current;
      if (root) root.ariaBusy = "true";
      if (isReverse) {
        prevScrollPosition.current = getScrollPosition(root, isVertical);
      }
      await (onLoad == null ? void 0 : onLoad(props2));
      if (isReverse) {
        const position2 = prevScrollPosition.current;
        onScroll({ root, isVertical, position: position2 });
      }
      indexRef.current += 1;
      processingRef.current = false;
      if (root) root.ariaBusy = "false";
    }, options);
    return observer2;
  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical]);
  (0, import_react183.useEffect)(() => {
    const setupObserver = async () => {
      const el = ref.current;
      const isMounted = isMountedRef.current;
      const index = indexRef.current;
      const root = rootRef == null ? void 0 : rootRef.current;
      if (initialLoad && !isMounted) {
        processingRef.current = true;
        if (root) root.ariaBusy = "true";
        await onLoad({ index, finish: onFinish });
        indexRef.current += 1;
        processingRef.current = false;
        if (root) root.ariaBusy = "false";
      }
      if (isDisabled2) return;
      observerRef.current = createObserver();
      const observer2 = observerRef.current;
      if (isReverse && !isMounted) {
        const root2 = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root: root2, isVertical, isReverse });
        isMountedRef.current = true;
      }
      setTimeout(() => {
        if (el) observer2.observe(el);
      });
      return () => {
        if (el) observer2.unobserve(el);
      };
    };
    setupObserver();
  }, [
    createObserver,
    initialLoad,
    isDisabled2,
    isReverse,
    isVertical,
    onFinish,
    onLoad,
    rootRef
  ]);
  useUnmountEffect(() => isMountedRef.current = false);
  assignRef(resetRef, onReset);
  assignRef(indexRefProp, (index) => indexRef.current = index);
  return { ref, isFinish };
};

// node_modules/@yamada-ui/infinite-scroll-area/dist/chunk-D3K2SLYF.mjs
var import_react184 = __toESM(require_react(), 1);
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var [InfiniteScrollAreaProvider, useInfiniteScrollAreaContext] = createContext2({
  name: "InfiniteScrollAreaContext",
  errorMessage: `useInfiniteScrollAreaContext returned is 'undefined'. Seems you forgot to wrap the components in "<InfiniteScrollArea />"`
});
var InfiniteScrollArea2 = forwardRef22(
  ({ orientation: _orientation = "vertical", ...props2 }, ref) => {
    const [styles2, mergedProps] = useMultiComponentStyle("InfiniteScrollArea", {
      orientation: _orientation,
      ...props2
    });
    const {
      rootRef: rootRefProp,
      orientation,
      rootMargin,
      threshold,
      startIndex,
      onLoad,
      resetRef,
      indexRef,
      className,
      children,
      triggerProps,
      loading,
      finish,
      isDisabled: isDisabled2,
      isReverse,
      initialLoad,
      ...rest
    } = omitThemeProps(mergedProps);
    const isVertical = orientation === "vertical";
    const rootRef = (0, import_react184.useRef)(null);
    const { ref: triggerRef, isFinish } = useInfiniteScroll({
      orientation,
      rootRef: rootRefProp != null ? rootRefProp : rootRef,
      rootMargin,
      threshold,
      startIndex,
      onLoad,
      resetRef,
      indexRef,
      isDisabled: isDisabled2,
      isReverse,
      initialLoad
    });
    const css4 = (0, import_react184.useMemo)(
      () => ({
        w: "100%",
        display: "flex",
        flexDirection: isVertical ? "column" : "row",
        gap: "1rem",
        ...styles2.container
      }),
      [isVertical, styles2]
    );
    const hasFinish = !!finish;
    const showTrigger = !isDisabled2 && (hasFinish || !isFinish);
    return (0, import_jsx_runtime191.jsx)(InfiniteScrollAreaProvider, { value: styles2, children: (0, import_jsx_runtime191.jsxs)(
      ui.div,
      {
        ref: mergeRefs(rootRef, ref),
        tabIndex: 0,
        className: cx("ui-infinite-scroll-area", className),
        role: "feed",
        "aria-busy": "false",
        __css: css4,
        ...rest,
        children: [
          isReverse && showTrigger ? (0, import_jsx_runtime191.jsx)(InfiniteScrollTrigger, { ref: triggerRef, ...triggerProps, children: isFinish ? finish : loading }) : null,
          children,
          !isReverse && showTrigger ? (0, import_jsx_runtime191.jsx)(InfiniteScrollTrigger, { ref: triggerRef, ...triggerProps, children: isFinish ? finish : loading }) : null
        ]
      }
    ) });
  }
);
var InfiniteScrollTrigger = forwardRef22(
  ({ className, ...rest }, ref) => {
    const styles2 = useInfiniteScrollAreaContext();
    const css4 = (0, import_react184.useMemo)(
      () => ({
        w: "100%",
        flex: 1,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        ...styles2.trigger
      }),
      [styles2]
    );
    return (0, import_jsx_runtime191.jsx)(
      ui.div,
      {
        ref,
        className: cx("ui-infinite-scroll-area__trigger", className),
        __css: css4,
        ...rest
      }
    );
  }
);

// node_modules/@yamada-ui/toggle/dist/chunk-5WV3HGXS.mjs
var import_react185 = __toESM(require_react(), 1);
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var [ToggleGroupProvider, useToggleGroup] = createContext2(
  {
    strict: false,
    name: "ToggleGroupContext"
  }
);
var ToggleGroup = forwardRef22(
  ({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    className,
    size,
    variant,
    direction: flexDirection,
    isDisabled: isDisabled2,
    isReadOnly,
    ...rest
  }, ref) => {
    const [value, setValue] = useControllableState({
      value: valueProp,
      defaultValue,
      onChange: onChangeProp
    });
    const isControlledRef = (0, import_react185.useRef)(!isUndefined(value));
    const onChange = (0, import_react185.useCallback)(
      (value2) => {
        if (isUndefined(value2)) return;
        setValue((prev2) => {
          if (isArray(prev2)) {
            const isIncluded = prev2.includes(value2);
            if (isIncluded) {
              return prev2.filter((prevValue) => prevValue !== value2);
            } else {
              return [...prev2, value2];
            }
          } else {
            if (value2 === prev2) {
              return void 0;
            } else {
              return value2;
            }
          }
        });
      },
      [setValue]
    );
    const css4 = {
      display: "inline-flex",
      gap: "0.5rem",
      flexDirection
    };
    const values = (0, import_react185.useMemo)(
      () => ({
        value,
        size,
        variant,
        isDisabled: isDisabled2,
        isReadOnly,
        isControlled: isControlledRef.current,
        onChange
      }),
      [value, size, variant, isDisabled2, isReadOnly, onChange]
    );
    useUpdateEffect(() => {
      if (isUndefined(value)) return;
      isControlledRef.current = true;
    }, [valueProp]);
    return (0, import_jsx_runtime192.jsx)(ToggleGroupProvider, { value: values, children: (0, import_jsx_runtime192.jsx)(
      ui.div,
      {
        ref,
        role: "group",
        className: cx("ui-toggle-group", className),
        __css: css4,
        ...rest
      }
    ) });
  }
);
ToggleGroup.displayName = "ToggleGroup";

// node_modules/@yamada-ui/toggle/dist/chunk-HRYWNAEZ.mjs
var import_react186 = __toESM(require_react(), 1);
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var Toggle2 = forwardRef22(
  (props2, ref) => {
    var _a;
    const {
      value: groupValue,
      onChange: onChangeGroup,
      isControlled,
      ...group
    } = (_a = useToggleGroup()) != null ? _a : {};
    const [styles2, mergedProps] = useMultiComponentStyle("Toggle", {
      ...group,
      ...props2
    });
    const {
      value,
      className,
      icon,
      isSelected: isSelectedProp,
      defaultIsSelected = false,
      onChange,
      isRounded,
      isActive,
      isDisabled: isDisabled2 = group == null ? void 0 : group.isDisabled,
      isReadOnly = group == null ? void 0 : group.isReadOnly,
      disableRipple,
      children,
      ...rest
    } = omitThemeProps(mergedProps);
    const [isSelected, setIsSelected] = useControllableState({
      value: isSelectedProp,
      defaultValue: defaultIsSelected,
      onChange
    });
    if (isControlled && isUndefined(value)) {
      console.warn(`Toggle: value is required. Please set the value.`);
    }
    const isMulti = isArray(groupValue);
    const isIncluded = isMulti ? groupValue.includes(value != null ? value : "") : value === groupValue;
    const trulySelected = isControlled ? isIncluded : isSelected;
    const { onPointerDown, ...rippleProps } = useRipple({
      ...rest,
      isDisabled: disableRipple || isDisabled2
    });
    const onClick2 = () => {
      setIsSelected((prev2) => !prev2);
      onChangeGroup == null ? void 0 : onChangeGroup(value);
    };
    const css4 = (0, import_react186.useMemo)(
      () => ({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "fallback(2, 0.5rem)",
        appearance: "none",
        userSelect: "none",
        position: "relative",
        verticalAlign: "middle",
        overflow: "hidden",
        outline: "none",
        pointerEvents: isReadOnly ? "none" : "auto",
        ...styles2,
        ...isRounded ? { borderRadius: "fallback(full, 9999px)" } : {}
      }),
      [isRounded, styles2, isReadOnly]
    );
    return (0, import_jsx_runtime193.jsxs)(
      ui.button,
      {
        ref,
        type: "button",
        tabIndex: isReadOnly ? -1 : 0,
        disabled: isDisabled2,
        "data-active": dataAttr(isActive),
        "data-selected": dataAttr(trulySelected),
        "data-readonly": dataAttr(isReadOnly),
        "aria-pressed": trulySelected,
        className: cx("ui-toggle", className),
        __css: css4,
        ...rest,
        onClick: handlerAll(rest.onClick, onClick2),
        onPointerDown,
        children: [
          children || icon,
          (0, import_jsx_runtime193.jsx)(Ripple, { isDisabled: disableRipple || isDisabled2, ...rippleProps })
        ]
      }
    );
  }
);
Toggle2.displayName = "Toggle";
export {
  AcceleratedAnimation,
  Accordion2 as Accordion,
  AccordionItem,
  AccordionLabel,
  AccordionPanel,
  Alert,
  AlertDescription,
  AlertIcon,
  AlertTitle,
  AlphaSlider2 as AlphaSlider,
  AnimatePresence,
  AnimateSharedLayout,
  AspectRatio,
  Autocomplete2 as Autocomplete,
  AutocompleteCreate,
  AutocompleteEmpty,
  AutocompleteOption,
  AutocompleteOptionGroup,
  Avatar2 as Avatar,
  AvatarBadge,
  AvatarGroup,
  Badge2 as Badge,
  Box,
  Breadcrumb2 as Breadcrumb,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbSeparator,
  Button2 as Button,
  ButtonGroup,
  COLOR_MODE_STORAGE_KEY,
  COLOR_SCHEMES,
  CSSVars,
  Card2 as Card,
  CardBody,
  CardFooter,
  CardHeader,
  Center,
  CheckIcon,
  Checkbox2 as Checkbox,
  CheckboxGroup,
  CheckboxIcon,
  ChevronIcon,
  CircleProgress2 as CircleProgress,
  CircleProgressLabel,
  CloseButton,
  CloseIcon,
  Collapse2 as Collapse,
  ColorModeContext,
  ColorModeProvider,
  ColorModeScript,
  ColorPicker2 as ColorPicker,
  ColorSelector2 as ColorSelector,
  ColorSwatch2 as ColorSwatch,
  Container2 as Container,
  ContainerPortal,
  ContextMenu2 as ContextMenu,
  ContextMenuTrigger,
  DecimalList,
  DefaultPortal,
  DeprecatedLayoutGroupContext,
  Dialog2 as Dialog,
  DialogBody,
  DialogCloseButton,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DiscList,
  Divider2 as Divider,
  DragControls,
  Drawer2 as Drawer,
  DrawerBody,
  DrawerCloseButton,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  Editable2 as Editable,
  EditableInput,
  EditablePreview,
  EditableTextarea,
  EnvironmentProvider,
  ErrorMessage,
  Fade2 as Fade,
  Fieldset2 as Fieldset,
  FileButton2 as FileButton,
  FileInput2 as FileInput,
  FlatTree,
  Flex,
  FocusLock2 as FocusLock,
  FormControl2 as FormControl,
  GlobalStyle,
  Grid2 as Grid,
  GridItem,
  HStack,
  Heading2 as Heading,
  HelperMessage,
  Highlight,
  HueSlider2 as HueSlider,
  Icon,
  IconButton,
  Image3 as Image,
  Image3 as Img,
  Indicator2 as Indicator,
  InfiniteScrollArea2 as InfiniteScrollArea,
  InfoIcon,
  Input2 as Input,
  InputGroup,
  InputLeftAddon,
  InputLeftElement,
  InputRightAddon,
  InputRightElement,
  Kbd2 as Kbd,
  Label,
  LayoutGroup,
  LayoutGroupContext,
  LazyMotion,
  Legend,
  Link2 as Link,
  LinkBox,
  LinkOverlay,
  List2 as List,
  ListIcon,
  ListItem,
  Loading,
  LoadingProvider,
  MOTION_TRANSITION_DEFAULTS,
  MOTION_TRANSITION_EASINGS,
  MOTION_TRANSITION_VARIANTS,
  Mark2 as Mark,
  Menu2 as Menu,
  MenuButton,
  MenuCommand,
  MenuDivider,
  MenuGroup,
  MenuIcon,
  MenuItem,
  MenuItemButton,
  MenuList,
  MenuOptionGroup,
  MenuOptionItem,
  Modal2 as Modal,
  ModalBody,
  ModalCloseButton,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Motion,
  MotionConfig,
  MotionConfigContext,
  MotionContext,
  MotionGlobalConfig,
  Reorder as MotionReorder,
  MultiAutocomplete2 as MultiAutocomplete,
  MultiSelect2 as MultiSelect,
  NativeImage,
  NativeImage as NativeImg,
  NativeOption,
  NativeOptionGroup,
  NativeSelect2 as NativeSelect,
  NativeTable2 as NativeTable,
  NoticeProvider,
  NumberInput2 as NumberInput,
  Option,
  OptionGroup,
  Pagination2 as Pagination,
  PinInput2 as PinInput,
  PinInputField,
  Popover2 as Popover,
  PopoverAnchor,
  PopoverBody,
  PopoverCloseButton,
  PopoverContent,
  PopoverFooter,
  PopoverHeader,
  PopoverTrigger,
  Portal,
  PresenceContext,
  Progress2 as Progress,
  Radio2 as Radio,
  RadioGroup,
  RangeSlider2 as RangeSlider,
  RangeSliderEndThumb,
  RangeSliderFilledTrack,
  RangeSliderMark,
  RangeSliderStartThumb,
  RangeSliderTrack,
  Rating2 as Rating,
  Reorder3 as Reorder,
  ReorderItem2 as ReorderItem,
  ReorderTrigger,
  ResetStyle,
  Resizable2 as Resizable,
  ResizableItem,
  ResizableTrigger,
  ResizableTriggerIcon,
  Ripple,
  SEMANTIC_COLOR_SCHEMES,
  SaturationSlider2 as SaturationSlider,
  ScaleFade2 as ScaleFade,
  ScrollArea2 as ScrollArea,
  SegmentedControl2 as SegmentedControl,
  SegmentedControlButton,
  Select2 as Select,
  SimpleGrid,
  Skeleton2 as Skeleton,
  SkeletonCircle,
  SkeletonText,
  Slide2 as Slide,
  SlideFade2 as SlideFade,
  Slider2 as Slider,
  SliderFilledTrack,
  SliderMark,
  SliderThumb,
  SliderTrack,
  Snacks,
  Spacer,
  Stack,
  Stat2 as Stat,
  StatHelperMessage,
  StatIcon,
  StatLabel,
  StatNumber,
  Step,
  StepDescription,
  StepIcon,
  StepNumber,
  StepSeparator,
  StepStatus,
  StepTitle,
  Stepper3 as Stepper,
  Switch2 as Switch,
  SwitchLayoutGroupContext,
  THEME_SCHEME_STORAGE_KEY,
  TONES,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  TableCaption,
  TableContainer,
  TableStyleProvider,
  Tabs2 as Tabs,
  Tag2 as Tag,
  Tbody,
  Td,
  Text2 as Text,
  Textarea2 as Textarea,
  Tfoot,
  Th,
  Thead,
  ThemeProvider3 as ThemeProvider,
  ThemeSchemeScript,
  Toggle2 as Toggle,
  ToggleGroup,
  Tooltip2 as Tooltip,
  Tr,
  UIProvider,
  VStack,
  VisualElement,
  VisuallyHidden,
  WarningIcon,
  Wrap,
  ZStack,
  addDomEvent,
  addPointerEvent,
  addPointerInfo,
  addScaleCorrector,
  alphaToHex,
  analyzeBreakpoints,
  animate,
  animateValue,
  animateVisualElement,
  animation,
  animationControls,
  animations,
  anticipate,
  antonym,
  ariaAttr,
  assignAfter,
  assignRef,
  atRuleStyles,
  backIn,
  backInOut,
  backOut,
  baseTheme,
  buildTransform,
  calc,
  calcFormat,
  calcLength,
  cancelFrame,
  cancelSync,
  cast,
  circIn,
  circInOut,
  circOut,
  clamp,
  clampNumber,
  collapseProps,
  color,
  colorModeManager,
  complex,
  convertColor,
  countDecimal,
  createBox,
  createColorModeManager,
  createContext2 as createContext,
  createDescendant,
  createDomMotionComponent,
  createId,
  createMotionComponent,
  createQuery,
  createScopedAnimate,
  createStorage,
  createThemeSchemeManager,
  createVars,
  createdDom,
  css3 as css,
  cubicBezier,
  cx,
  darkenColor,
  dataAttr,
  defaultConfig,
  defaultTheme,
  delay,
  disableInstantTransitions,
  distance,
  distance2D,
  domAnimation,
  domMax,
  easeIn,
  easeInOut,
  easeOut,
  escape,
  extendBaseTheme,
  extendComponent,
  extendComponentDefaultProps,
  extendComponentSize,
  extendComponentVariant,
  extendConfig,
  extendStyle,
  extendTheme,
  extendToken,
  fadeProps,
  filterEmpty,
  filterObject,
  filterProps,
  filterUndefined,
  findChildren,
  flattenObject,
  formControlProperties,
  forwardRef22 as forwardRef,
  frame,
  frameData,
  funcAll,
  generate,
  getActiveElement,
  getAllFocusable,
  getAlpha,
  getBreakpointValue,
  getCSS2 as getCSS,
  getColor,
  getColorModeScript,
  getColorModeValue,
  getEventPoint,
  getEventRelatedTarget,
  getEventWindow,
  getFormControlProperties,
  getMemoizedObject,
  getMinMaxQuery,
  getObject,
  getOwnerDocument,
  getOwnerWindow,
  getPlatform,
  getPx,
  getThemeSchemeScript,
  getToken,
  getValidChildren,
  getValue3 as getValue,
  getVar,
  gradient,
  handlerAll,
  hasNegativeTabIndex,
  hasTabIndex,
  hslaTo,
  hsvTo,
  inView,
  includesChildren,
  interopDefault,
  interpolate,
  invariant,
  is,
  isAccessible,
  isActiveElement,
  isApple,
  isArray,
  isBoolean,
  isBrowser3 as isBrowser,
  isContains,
  isContentEditable,
  isDark,
  isDisabled,
  isDragActive,
  isElement,
  isEmpty,
  isFocusable,
  isFunction,
  isGray,
  isHTMLElement,
  isHidden,
  isLight,
  isMac,
  isMotionComponent,
  isMotionValue,
  isMouseEvent,
  isMultiTouchEvent,
  isNotNumber,
  isNull,
  isNumber,
  isNumeric,
  isObject,
  isRefObject,
  isSafari,
  isString,
  isTabbable,
  isTone,
  isTouchDevice,
  isTouchEvent,
  isUndefined,
  isUnit,
  isValidElement2 as isValidElement,
  isValidMotionProp,
  keyframes4 as keyframes,
  keysFormObject,
  layoutStyleProperties,
  lightenColor,
  m,
  makeUseVisualState,
  memoizeObject,
  merge,
  mergeMultiStyle,
  mergeRefs,
  mergeStyle,
  mirrorEasing,
  mix2 as mix,
  mode,
  motion,
  motionForwardRef,
  motionValue,
  noop,
  noticeStore,
  objectFromEntries,
  omitChildren,
  omitObject,
  omitThemeProps,
  optimizedAppearDataAttribute,
  parseToHsla2 as parseToHsla,
  parseToHsv,
  parseToRgba2 as parseToRgba,
  percentToValue,
  pickChildren,
  pickObject,
  pickStyle,
  pipe2 as pipe,
  platform,
  pointFromMouse,
  pointFromTouch,
  popoverProperties,
  popperProperties,
  processSkipProperties,
  progress,
  pseudoStyles,
  pseudos,
  pseudosProperties,
  pseudosSelectors,
  px,
  randomColor,
  replaceObject,
  resolveMotionValue,
  reverseEasing,
  rgbaTo,
  roundNumberToStep,
  runIfFunc,
  sameColor,
  scaleFadeProps,
  scroll,
  scrollInfo,
  shadeColor,
  shorthandStyles,
  shouldForwardProp,
  slideFadeProps,
  slideProps,
  splitObject,
  spring,
  stagger,
  standardStyles,
  startOptimizedAppearAnimation,
  steps,
  styleProperties,
  styled,
  styles,
  sync,
  themeSchemeManager,
  tintColor,
  toCSSObject,
  toCamelCase,
  toKebabCase,
  toNumber,
  toPrecision,
  toTitleCase,
  trackElementSize,
  trackFocusVisible,
  transform2 as transform,
  transformTheme,
  transforms,
  transitionEnter,
  transitionExit,
  transparentizeColor,
  ui,
  uiStyles,
  unwrapMotionComponent,
  useAnimate,
  useAnimation2 as useAnimation,
  useAnimationControls,
  useAnimationFrame,
  useAnimationObserver,
  useAsync,
  useAsyncFunc,
  useAsyncRetry,
  useBoolean,
  useBreakpoint,
  useBreakpointEffect,
  useBreakpointState,
  useBreakpointValue,
  useCSS,
  useCallbackRef,
  useCheckbox,
  useCheckboxGroup,
  useClickable,
  useClipboard,
  useColorMode,
  useColorModeValue,
  useComponentStyle,
  useControllableState,
  useCounter,
  useCycle,
  useAnimatedState as useDeprecatedAnimatedState,
  useInvertedScale as useDeprecatedInvertedScale,
  useDisclosure,
  useDomEvent,
  useDragControls,
  useDynamicAnimation,
  useEditable,
  useEditableControl,
  useElementScroll,
  useElementSize,
  useEnvironment,
  useEventListener,
  useEventListeners,
  useEyeDropper,
  useFocusOnHide,
  useFocusOnPointerDown,
  useFocusOnShow,
  useFocusVisible,
  useForceUpdate,
  useFormControl,
  useFormControlProps,
  useHighlight,
  useHover,
  useIdle,
  useImage,
  useInView,
  useInfiniteScroll,
  useInstantLayoutTransition,
  useInstantTransition,
  useInterval,
  useIsMounted,
  useIsPresent,
  useIsomorphicLayoutEffect,
  useLatestRef,
  useLazyDisclosure,
  useLoading,
  useLocalStorage,
  useMediaQuery,
  useMergeRefs,
  useAnimation as useMotionAnimation,
  useMotionTemplate,
  useMotionValue,
  useMotionValueEvent,
  useMultiComponentStyle,
  useNotice,
  useNumberInput,
  useOS,
  useOutsideClick,
  usePagination,
  usePanEvent,
  usePopper,
  usePresence,
  usePrevious,
  useRadio,
  useRadioGroup,
  useReducedMotion,
  useReducedMotionConfig,
  useResetProjection,
  useResizeObserver,
  useRipple,
  useSafeLayoutEffect,
  useScroll,
  useSize,
  useSizes,
  useSnacks,
  useSpring,
  useSteps,
  useTableStyles,
  useTheme2 as useTheme,
  useTime,
  useTimeout,
  useToken,
  useTransform,
  useUnmountEffect,
  useUpdateBreakpointEffect,
  useUpdateEffect,
  useValue,
  useVelocity,
  useViewportScroll,
  useWillChange,
  useWindowEvent,
  valueToPercent,
  vendor,
  visualElementStore,
  warning,
  withDefaultColorScheme,
  withDefaultProps,
  withDefaultSize,
  withDefaultVariant,
  wrap2 as wrap
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=@yamada-ui_react.js.map
